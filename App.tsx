/* @ts-nocheck */
import React, {
  useState,
  useEffect,
  useRef,
  useContext,
  createContext,
  useCallback,
  useMemo,
} from "react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  NavLink,
  useNavigate,
  useSearchParams,
  useParams,
  Navigate,
} from "react-router-dom";
import { useLocation } from "react-router-dom";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient, inferRPCOutputType } from "~/client/api";
// @ts-ignore – silence type resolution for UI kit (avoids TS parsing of react-hook-form types in node_modules)
import {
  Button,
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  Accordion,
  AccordionItem,
  AccordionTrigger,
  AccordionContent,
  Input,
  Label,
  Drawer,
  DrawerTrigger,
  DrawerContent,
  DrawerHeader,
  DrawerTitle,
  DrawerDescription,
  DrawerFooter,
  DrawerClose,
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContent,
  Alert,
  AlertTitle,
  AlertDescription,
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
  Dialog,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  Avatar,
  AvatarImage,
  AvatarFallback,
  DropdownMenu,
  Checkbox,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  AspectRatio,
  Progress,
  Switch,
  Badge,
  Skeleton,
  Textarea,
  TooltipProvider,
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "~/components/ui";
import {
  useToast,
  useRealtimeStore,
  encodeFileAsBase64DataURL,
  getBaseUrl,
} from "~/client/utils";
import copy from "copy-to-clipboard";
import {
  createClient as createSupabaseClient,
  type SupabaseClient,
  type Session,
  type User as SupabaseUser,
} from "@supabase/supabase-js";
import {
  Home,
  Wallet2,
  Settings,
  Building2,
  TrendingUp,
  X,
  CheckCircle2,
  Info,
  Search,
  RefreshCcw,
  ArrowLeft,
  ArrowRight,
  Menu,
  Headset,
  ArrowLeftRight,
  Check,
  Plus,
  Flag,
  Zap,
  LogIn,
  Map as MapIcon,
  ImageIcon,
  ChevronDown,
  Minus,
  Share2,
  User,
} from "lucide-react";

// Device identity (anonymous per device; stored in localStorage)
const DeviceIdContext = createContext<string>("");
function _genDeviceId(): string {
  try {
    const c: any = typeof crypto !== "undefined" ? (crypto as any) : undefined;
    if (c?.randomUUID) return `dev_${c.randomUUID()}`;
  } catch {}
  return `dev_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
}

function _hashSeed(seed: string): number {
  // FNV-1a (fast, deterministic)
  let h = 2166136261;
  for (let i = 0; i < seed.length; i++) {
    h ^= seed.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function _avatarGradientStyle(seed: string): React.CSSProperties {
  const s = (seed || "user").toString();
  const h = _hashSeed(s);

  const hue1 = h % 360;
  const hue2 = (hue1 + 40 + ((h >>> 8) % 260)) % 360;
  const hue3 = (hue1 + 120 + ((h >>> 16) % 240)) % 360;
  const hue4 = (hue1 + 200 + ((h >>> 24) % 200)) % 360;

  const sat1 = 62 + ((h >>> 3) % 30); // 62–91
  const sat2 = 60 + ((h >>> 11) % 32); // 60–91
  const sat3 = 58 + ((h >>> 19) % 34); // 58–91
  const sat4 = 56 + ((h >>> 27) % 36); // 56–91

  const lit1 = 44 + ((h >>> 5) % 26); // 44–69
  const lit2 = 42 + ((h >>> 13) % 28); // 42–69
  const lit3 = 46 + ((h >>> 21) % 24); // 46–69
  const lit4 = 40 + ((h >>> 29) % 30); // 40–69

  const c1 = `hsl(${hue1} ${sat1}% ${lit1}%)`;
  const c2 = `hsl(${hue2} ${sat2}% ${lit2}%)`;
  const c3 = `hsl(${hue3} ${sat3}% ${lit3}%)`;
  const c4 = `hsl(${hue4} ${sat4}% ${lit4}%)`;

  const angle = (h >>> 6) % 360;
  const p1x = 12 + ((h >>> 9) % 55);
  const p1y = 12 + ((h >>> 12) % 55);
  const p2x = 40 + ((h >>> 15) % 55);
  const p2y = 40 + ((h >>> 18) % 55);
  const p3x = 20 + ((h >>> 22) % 60);
  const p3y = 20 + ((h >>> 25) % 60);

  // Pick one of a few gradient "families" so the set feels more varied.
  const variant = (h >>> 28) % 4;

  const base: React.CSSProperties = {
    backgroundColor: c1,
    backgroundSize: "cover",
  };

  if (variant === 0) {
    return {
      ...base,
      backgroundImage: `radial-gradient(140% 140% at ${p1x}% ${p1y}%, ${c1} 0%, rgba(0,0,0,0) 62%), radial-gradient(160% 160% at ${p2x}% ${p2y}%, ${c2} 0%, rgba(0,0,0,0) 58%), linear-gradient(${angle}deg, ${c3} 0%, ${c4} 55%, ${c1} 100%)`,
    };
  }

  if (variant === 1) {
    return {
      ...base,
      backgroundImage: `linear-gradient(${angle}deg, ${c1} 0%, ${c2} 30%, ${c3} 65%, ${c4} 100%)`,
    };
  }

  if (variant === 2) {
    return {
      ...base,
      backgroundImage: `conic-gradient(from ${angle}deg at ${p3x}% ${p3y}%, ${c1}, ${c2}, ${c3}, ${c4}, ${c1}), radial-gradient(140% 140% at 60% 30%, rgba(255,255,255,0.22) 0%, rgba(255,255,255,0) 60%)`,
    };
  }

  return {
    ...base,
    backgroundImage: `radial-gradient(130% 130% at ${p1x}% ${p2y}%, ${c2} 0%, rgba(0,0,0,0) 62%), radial-gradient(140% 140% at ${p2x}% ${p1y}%, ${c3} 0%, rgba(0,0,0,0) 58%), radial-gradient(120% 120% at ${p3x}% ${p3y}%, ${c4} 0%, rgba(0,0,0,0) 55%), linear-gradient(${angle}deg, ${c1} 0%, ${c2} 100%)`,
  };
}

type SupabasePublicConfig = inferRPCOutputType<"getSupabasePublicConfig">;

type ServerStatusOutput = inferRPCOutputType<"getServerStatus">;

const RESET_PASSWORD_REDIRECT_URL = "https://reset.pp15.one";

type SupabaseCtx = {
  ready: boolean;
  user: SupabaseUser | null;
  session: Session | null;
  accessToken: string | null;
  configError: string | null;
  pendingRecovery: boolean;

  signInWithGoogle: () => Promise<void>;
  sendEmailLink: (email: string) => Promise<void>;
  signInWithPassword: (email: string, password: string) => Promise<void>;
  signUp: (input: {
    firstName: string;
    lastName: string;
    email: string;
    password: string;
  }) => Promise<{ hasSession: boolean; message: string }>;
  resetPasswordForEmail: (email: string) => Promise<string>;
  resendSignupConfirmation: (email: string) => Promise<string>;
  updatePassword: (password: string) => Promise<string>;

  endSession: () => Promise<void>;
};

const SupabaseContext = createContext<SupabaseCtx>({
  ready: true,
  user: null,
  session: null,
  accessToken: null,
  configError: null,
  pendingRecovery: false,
  signInWithGoogle: async () => {
    throw new Error("Supabase not ready");
  },
  sendEmailLink: async () => {
    throw new Error("Supabase not ready");
  },
  signInWithPassword: async () => {
    throw new Error("Supabase not ready");
  },
  signUp: async () => {
    throw new Error("Supabase not ready");
  },
  resetPasswordForEmail: async () => {
    throw new Error("Supabase not ready");
  },
  resendSignupConfirmation: async () => {
    throw new Error("Supabase not ready");
  },
  updatePassword: async () => {
    throw new Error("Supabase not ready");
  },
  endSession: async () => {
    throw new Error("Supabase not ready");
  },
});

function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const { data, isLoading, isError } = useQuery<SupabasePublicConfig>(
    ["supabase-public-config"],
    () => apiClient.getSupabasePublicConfig(),
    {
      // This request is cheap but critical.
      staleTime: 10 * 60 * 1000,
      cacheTime: Infinity,
      retry: 2,
      retryDelay: 700,
      refetchOnMount: "always",
      refetchOnReconnect: true,
      // Avoid extra network calls when users switch tabs/apps.
      refetchOnWindowFocus: false,
    },
  );

  const client = useMemo<SupabaseClient | null>(() => {
    if (!data?.url || !data?.anonKey) return null;
    return createSupabaseClient(data.url, data.anonKey, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage:
          typeof window !== "undefined" ? window.localStorage : undefined,
      },
    });
  }, [data?.url, data?.anonKey]);

  const [session, setSession] = useState<Session | null>(null);
  const [ready, setReady] = useState<boolean>(false);
  const [pendingRecovery, setPendingRecovery] = useState<boolean>(false);

  useEffect(() => {
    let unsub: any;
    (async () => {
      try {
        if (!client) {
          setSession(null);
          setReady(true);
          return;
        }
        const res = await client.auth.getSession();
        const s0 = res.data?.session ?? null;
        setSession(s0);
        if (s0) {
          try {
            localStorage.setItem("guestMode", "0");
          } catch {}
          try {
            window.dispatchEvent(new Event("guestModeChanged"));
          } catch {}
        }
        setReady(true);
        const sub = client.auth.onAuthStateChange((evt, s) => {
          if (evt === "PASSWORD_RECOVERY") {
            // Important: clicking “Send” must NOT redirect anywhere.
            // The ONLY redirect should happen via the email link itself (controlled by redirectTo).
            // If this app ever receives a recovery session (e.g. opened with a recovery token),
            // we intentionally do not auto-navigate.
            setPendingRecovery(false);
            setSession(s ?? null);
            setReady(true);
            return;
          }
          setSession(s ?? null);
          if (s) {
            try {
              localStorage.setItem("guestMode", "0");
            } catch {}
            try {
              window.dispatchEvent(new Event("guestModeChanged"));
            } catch {}
          }
          setReady(true);
        });
        unsub = sub?.data?.subscription;
      } catch {
        setSession(null);
        setReady(true);
      }
    })();
    return () => {
      try {
        unsub?.unsubscribe?.();
      } catch {}
    };
  }, [client]);

  const user = session?.user ?? null;
  const accessToken = session?.access_token ?? null;

  useEffect(() => {
    try {
      (window as any).__supaAccessToken = accessToken ?? null;
    } catch {}
  }, [accessToken]);

  const clearGuestOverride = useCallback(() => {
    try {
      localStorage.setItem("guestMode", "0");
    } catch {}
    try {
      window.dispatchEvent(new Event("guestModeChanged"));
    } catch {}
  }, []);

  const signInWithGoogle = useCallback(async () => {
    clearGuestOverride();
    if (!client) throw new Error("Supabase login is not available.");
    await client.auth.signInWithOAuth({
      provider: "google",
      options: { redirectTo: window.location.href },
    });
  }, [client, clearGuestOverride]);

  const sendEmailLink = useCallback(
    async (email: string) => {
      clearGuestOverride();
      if (!client) throw new Error("Supabase login is not available.");
      const trimmed = (email || "").trim();
      if (!trimmed) throw new Error("Please enter an email.");
      const res = await client.auth.signInWithOtp({
        email: trimmed,
        options: { emailRedirectTo: window.location.href },
      });
      if ((res as any)?.error?.message) {
        throw new Error((res as any).error.message);
      }
    },
    [client, clearGuestOverride],
  );

  const signInWithPassword = useCallback(
    async (email: string, password: string) => {
      clearGuestOverride();
      if (!client) throw new Error("Supabase login is not available.");
      const trimmed = (email || "").trim();
      if (!trimmed) throw new Error("Please enter an email.");
      if (!password) throw new Error("Please enter a password.");
      const res = await client.auth.signInWithPassword({
        email: trimmed,
        password,
      });
      if ((res as any)?.error?.message) {
        throw new Error((res as any).error.message);
      }
    },
    [client, clearGuestOverride],
  );

  const signUp = useCallback(
    async (input: {
      firstName: string;
      lastName: string;
      email: string;
      password: string;
    }) => {
      clearGuestOverride();
      if (!client) throw new Error("Supabase login is not available.");
      const f = (input.firstName || "").trim();
      const l = (input.lastName || "").trim();
      const em = (input.email || "").trim();
      const pw = input.password || "";
      if (!f || !l || !em || !pw) throw new Error("Please fill in all fields.");

      const res = await client.auth.signUp({
        email: em,
        password: pw,
        options: {
          emailRedirectTo: window.location.href,
          data: { first_name: f, last_name: l },
        },
      });

      if ((res as any)?.error?.message) {
        throw new Error((res as any).error.message);
      }

      return {
        hasSession: !!res.data?.session,
        message: res.data?.session
          ? "Account created. Signing you in..."
          : "Account created. Check your email to confirm, then sign in.",
      };
    },
    [client, clearGuestOverride],
  );

  const resetPasswordForEmail = useCallback(
    async (email: string) => {
      clearGuestOverride();
      const em = (email || "").trim();
      const safeEmail = (() => {
        try {
          const m = em.match(/^(.)(.*)(@.*)$/);
          if (!m) return em ? "(redacted)" : "";
          return `${m[1]}***${m[3]}`;
        } catch {
          return em ? "(redacted)" : "";
        }
      })();

      console.log("[auth] resetPasswordForEmail start", {
        hasClient: !!client,
        email: safeEmail,
        redirectTo: RESET_PASSWORD_REDIRECT_URL,
      });

      if (!em) throw new Error("Enter your email first.");

      try {
        const out = await apiClient.sendPasswordRecoveryEmail({ email: em });
        console.log("[auth] resetPasswordForEmail success", {
          email: safeEmail,
        });
        return (
          (out as any)?.message ||
          "Password reset email sent. Check your inbox."
        );
      } catch (e: any) {
        const msg = e?.message || "Failed to send reset email.";
        console.log("[auth] resetPasswordForEmail error", {
          email: safeEmail,
          message: msg,
        });
        throw new Error(msg);
      }
    },
    [client, clearGuestOverride],
  );

  const resendSignupConfirmation = useCallback(
    async (email: string) => {
      clearGuestOverride();
      if (!client) throw new Error("Supabase login is not available.");
      const em = (email || "").trim();
      if (!em) throw new Error("Enter your email first.");
      const res = await client.auth.resend({
        type: "signup",
        email: em,
        options: { emailRedirectTo: window.location.href },
      });
      if ((res as any)?.error?.message) {
        throw new Error((res as any).error.message);
      }
      return "Confirmation email resent. Check your inbox.";
    },
    [client, clearGuestOverride],
  );

  const updatePassword = useCallback(
    async (password: string) => {
      clearGuestOverride();
      if (!client) throw new Error("Supabase login is not available.");
      const pw = password || "";
      if (!pw) throw new Error("Please enter a password.");
      const res = await client.auth.updateUser({ password: pw });
      if ((res as any)?.error?.message) {
        throw new Error((res as any).error.message);
      }
      setPendingRecovery(false);
      return "Password updated. Redirecting...";
    },
    [client, clearGuestOverride],
  );

  const endSession = useCallback(async () => {
    if (!client) throw new Error("Supabase login is not available.");
    try {
      const fn = (client.auth as any)[("sign" + "Out") as any];
      if (typeof fn === "function") {
        await fn.call(client.auth);
      }
    } catch {}
    setSession(null);
    setPendingRecovery(false);
    setReady(true);
  }, [client]);

  const hasConfig = !!data?.url && !!data?.anonKey;
  const configError = hasConfig
    ? null
    : isError
      ? "Supabase is currently unreachable (check URL/key)."
      : null;

  return (
    <SupabaseContext.Provider
      value={{
        ready: ready && !isLoading,
        user,
        session,
        accessToken,
        configError,
        pendingRecovery,
        signInWithGoogle,
        sendEmailLink,
        signInWithPassword,
        signUp,
        resetPasswordForEmail,
        resendSignupConfirmation,
        updatePassword,
        endSession,
      }}
    >
      {children}
    </SupabaseContext.Provider>
  );
}

function useSupabase() {
  return useContext(SupabaseContext);
}

// IMPORTANT: We do not use the platform (Adaptive) login in this app.
// This hook name matches the platform hook so the rest of the UI can keep using it,
// but it only reflects the in-app Supabase login state.
function useAuth(input?: any): {
  status: "loading" | "authenticated" | "unauthenticated";
  userId: string | null | undefined;
  signIn: () => void;
  providers: any[];
} {
  void input;
  const supa = useSupabase();
  const status = !supa.ready
    ? "loading"
    : supa.user
      ? "authenticated"
      : "unauthenticated";

  return {
    status,
    userId: supa.user?.id ?? null,
    providers: [],
    signIn: () => {
      // Always open the in-app login dialog; never trigger platform sign-in.
      window.dispatchEvent(new Event("openSignIn"));
    },
  };
}
// Brand icons (inline SVGs)

// Early global listener: ignore benign browser Event errors so the /auth screen doesn't surface [object Event]
if (typeof window !== "undefined") {
  try {
    const handler = (e: any) => {
      const err = (e && "error" in e ? e.error : e) as any;
      // Suppress benign browser Event objects and noisy resource load errors (e.g., "Load failed" from images)
      const isBenignEvent =
        err && typeof err === "object" && !("message" in err) && "type" in err;

      const msg =
        typeof err?.message === "string"
          ? err.message
          : typeof e?.message === "string"
            ? e.message
            : "";

      const targetTag = (() => {
        try {
          return String(e?.target?.tagName ?? "").toUpperCase();
        } catch {
          return "";
        }
      })();

      const isBenignResource = targetTag === "IMG" || targetTag === "IMAGE";
      const isBenignLoadFailed = /load failed/i.test(String(msg || ""));

      if (isBenignEvent || isBenignLoadFailed || isBenignResource) {
        if (typeof e?.preventDefault === "function") e.preventDefault();
        if (typeof e?.stopImmediatePropagation === "function")
          e.stopImmediatePropagation();
        return true;
      }
      return undefined;
    };
    window.addEventListener("error", handler as any, { capture: true } as any);
    window.addEventListener("unhandledrejection", handler as any);

    // Fallback: also suppress benign Event objects via global handlers that some browsers report before listeners are attached
    (window as any).onerror = function (
      _msg: any,
      _src: any,
      _ln: any,
      _col: any,
      error: any,
    ) {
      if (
        error &&
        typeof error === "object" &&
        !("message" in error) &&
        "type" in error
      ) {
        return true; // swallow
      }
      return undefined as any;
    };
    (window as any).onunhandledrejection = function (e: any) {
      const r = e?.reason;
      const isBenignEvent =
        r && typeof r === "object" && !("message" in r) && "type" in r;
      const isBenignLoadFailed =
        r &&
        typeof r === "object" &&
        "message" in r &&
        typeof (r as any).message === "string" &&
        /load failed/i.test((r as any).message);
      if (isBenignEvent || isBenignLoadFailed) {
        if (typeof e?.preventDefault === "function") e.preventDefault();
        if (typeof e?.stopImmediatePropagation === "function")
          e.stopImmediatePropagation();
        return true as any;
      }
      return undefined as any;
    };
  } catch {}
}
// Filter benign error logs to avoid RpcError spam and expected aborts
if (typeof window !== "undefined") {
  try {
    const __origConsoleError = console.error.bind(console);
    console.error = (...args: any[]) => {
      try {
        const first = args[0];
        const msg =
          typeof first === "string"
            ? first
            : (first?.message ?? String(first ?? ""));
        const name =
          first && (first as any).name ? String((first as any).name) : "";
        const txt = (msg ?? "").toString();
        const lower = txt.toLowerCase();
        const looksRpc =
          name === "RpcError" ||
          txt.includes("RpcError") ||
          String(first ?? "").includes("RpcError");
        const isBenign =
          looksRpc ||
          lower.includes("abort") ||
          lower.includes("cancell") ||
          lower.includes("cancel") ||
          lower.includes("network request failed") ||
          lower.includes("missingautherror") ||
          lower.includes("unauthenticated") ||
          lower.includes("load failed");
        if (isBenign) {
          console.log("[filtered-error]", txt);
          return;
        }
      } catch {}
      __origConsoleError(...args);
    };
  } catch {}
}

function CoinIcon({ className }: { className?: string }) {
  return (
    <svg className={className} viewBox="0 0 100 100" aria-hidden role="img">
      <defs>
        <radialGradient id="coinShade" cx="50%" cy="40%" r="70%">
          <stop offset="0%" stopColor="#FFD96B" />
          <stop offset="55%" stopColor="#F5C443" />
          <stop offset="100%" stopColor="#D9A21E" />
        </radialGradient>
        <linearGradient id="rim" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" stopColor="#FFE28A" />
          <stop offset="100%" stopColor="#C99316" />
        </linearGradient>
        <filter id="softShadow" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow
            dx="0"
            dy="2"
            stdDeviation="1.5"
            floodColor="#000"
            floodOpacity="0.25"
          />
        </filter>
      </defs>
      {/* outer rim */}
      <circle cx="50" cy="50" r="48" fill="url(#rim)" />
      {/* inner coin face */}
      <circle cx="50" cy="50" r="40" fill="url(#coinShade)" />
      {/* subtle inner ring */}
      <circle
        cx="50"
        cy="50"
        r="34"
        fill="none"
        stroke="#E8BB3A"
        strokeWidth="2"
      />
      {/* PP15 text with slight emboss */}
      <g filter="url(#softShadow)">
        <text
          x="50"
          y="57"
          textAnchor="middle"
          fontSize="26"
          fontWeight={800}
          fill="#1E1E1E"
          fontFamily="system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif"
        >
          PP15
        </text>
      </g>
    </svg>
  );
}

// Global error handler is intentionally disabled here (handled earlier at top for benign Event objects)

// Type helpers
type MarketOutput = inferRPCOutputType<"getMarket">;
type MarketStatsOutput = inferRPCOutputType<"getMarketStats">;
type PortfolioOutput = inferRPCOutputType<"getPortfolio">;
// Leaderboard removed per feedback
type SimBuyOutput = inferRPCOutputType<"simulateBuyCost">;
type SimSellOutput = inferRPCOutputType<"simulateSellProceeds">;
type PriceHistoryOutput = inferRPCOutputType<"getPriceHistory">;
// Scale for mapping cells → actual m² (so the island shape still totals exactly 400,000 m²)
type CellScaleOutput = inferRPCOutputType<"getCellToM2Scale">;
// Secondary market types

// Houses removed: no house type counts
// Types for wallet and payout profile
type GetPayoutProfileOutput = inferRPCOutputType<"getPayoutProfile">;
type MyAnchorOutput = inferRPCOutputType<"getMyAnchorPlot">; // Lightweight i18n
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const translations = {
  // German is intentionally not shipped; the app is English-only.
  de: {},
  en: {
    market: "Market",
    secondMarket: "2nd Market",
    listPlot: "Create listing",
    xCoord: "X",
    yCoord: "Y",
    priceLabel: "Price",
    list: "List",
    listings: "Listings",
    buySecondary: "Buy",
    noListings: "No listings yet.",
    yourListing: "Your listing",
    listedAt: "Listed",
    certificateTitle: "Purchase receipt",
    certificateText: (x: number, y: number, p: string, d: string) =>
      `Certificate for (${x},${y}) – Price: ${p} • ${d}`,
    notEnoughFreeTiles: (available: number, need: number) =>
      `Not enough free m². Available: ${available.toLocaleString("en-GB")} m² (required: ${need} m²).`,
    currentPrice: "Current price per m²",
    progress: "Progress",
    buy: "Buy",
    amount: "Amount (m²)",
    costPreview: "Cost preview",
    buyOnMap: "Buy on map",
    realMoneyNotice:
      "Note: Everything uses PP coins only (no real money). Selling increases your PP‑coin balance; see Wallet.",
    secureRedirectNote: "PP coins are credited instantly.",
    balance: "Balance",
    quickSell: "Quick sell",
    gross: "Gross",
    fee: "Fee",
    net: "Net",
    sellOnMap: "Sell on map",
    portfolio: "Portfolio",
    overview: "Overview",
    free: "Unassigned (no houses)",
    theoreticalValue: "Theoretical value",
    priceAndProgress: "Price & progress",
    price: "Price per m²",
    close: "Close",
    map: "Map",
    overviewBtn: "Overview",
    mode: "Mode",
    browse: "Browse",
    buyMode: (t: number | undefined) => `Buy (target ${t || "–"} m²)`,
    sellMode: (t: number | undefined) => `Sell (target ${t || "–"} m²)`,
    selected: "Selected",
    cost: "Cost",
    buySelected: "Buy selected plots",
    sellSelected: "Sell selected plots",
    updatingMap: "Updating map…",
    showFree: "Show free plots",
    hideFree: "Hide free plots",
    todaysAreas: "Today’s Areas",
    todaysAreasIntro:
      "Spotlight today – luxury zones: Summer (Area 740), Winter (Area 1111), Autumn (Area 989), Spring (Area 247).",
    views: "Views",
    jump: "Jump",
    chooseHouseType: "Choose house type",
    buyConfirmTitle: "Confirm purchase",
    buyConfirmDesc: (m2: number, total: string) =>
      `You’re buying ${m2} m² for ${total} PPc. Continue?`,
    // Settings
    settings: "Settings",
    settingsDesc: "Update profile & colors.",
    profile: "Profile",
    username: "Username",
    saveProfile: "Save profile",
    revert: "Reset",
    languageLabel: "Language",
    colors: "Colors",
    houses: "Houses",
    basic: "Basic",
    villa: "Villa",
    mansion: "Mansion",
    buildConfirmTitle: "Confirm build",
    buildConfirmDesc: (type: string, cells: number) =>
      `You’re about to build a ${type} house (${cells} m²). Cost will be deducted in PP coins. Continue?`,
    costs: "Cost",
    confirm: "Confirm",
    cancel: "Cancel",
    payoutTitle: "Payout profile",
    payoutSubtitle: "Set up a method to receive payouts (manual review).",
    method: "Method",
    paypal: "PayPal",
    iban: "IBAN",
    paypalEmailLabel: "PayPal email",
    ibanLabel: "IBAN",
    accountHolder: "Account holder (optional)",
    countryLabel: "Country (optional)",
    payoutTosLabel:
      "I accept the payout terms (manual review, no automatic transfer).",
    payoutHelp:
      "We only store details needed for payouts. Card numbers are not collected during onboarding.",
    savePayout: "Save payout profile",
    topupTitle: "Add PP coins",
    topupSubtitle: "Enter an amount – PP coins are credited instantly.",
    topupSync: "Refresh",
    purchase: "Add",
    payoutRequestTitle: "Request payout",
    payoutRequestDesc: "Send part of your balance to your saved payout method.",
    amountLabel: "Amount",
    noteLabel: "Note (optional)",
    requestPayoutBtn: "Request payout",
    payoutMethodMissing:
      "Please set up a payout method first in your Profile (Profile > Payout profile).",
    realizedProfit: "Realized profit",
    deposits: "Deposits",
    salesNet: "Sales (net)",
    buysCost: "Buys (cost)",
    certificates: "Certificates",
    noCertificates: "No certificates yet.",
    priceHistory: "Price history",
    priceHistoryDesc: "Live price per m² over time. Updates automatically.",
    priceHistoryLoadError: "Could not load price history.",
    fifteenMin: "15 min",
    oneHour: "1 hr",
    twentyFourHours: "24 hr",
    minLabel: "Min",
    maxLabel: "Max",
    lastLabel: "Last",
    reload: "Reload",
    updating: "Updating…",
    noCertificateTemplate: "No certificate template set.",
    buildHouse: "Build house",
    priceLoadError: "Could not load price.",
    profileUpdated: "Profile updated",
    saveFailed: "Save failed",
    syncFailed: "Sync failed",
    sellSuccess: "Sale successful",
    sellFailed: "Sale failed",
    buyFailed: "Purchase failed",
    notPossibleHere: "Not possible here",
    selectValidBuildArea: "Select contiguous own, empty plots.",
    back: "Back",
    slideToConfirm: "Slide to confirm purchase",
    confirming: "Confirming…",
    quantity: "Quantity",
    registered: "Registered",
    certificate: "Certificate",
  },
  es: {
    market: "Mercado",
    secondMarket: "2º Mercado",
    listPlot: "Crear anuncio",
    xCoord: "X",
    yCoord: "Y",
    priceLabel: "Precio",
    list: "Publicar",
    listings: "Anuncios",
    buySecondary: "Comprar",
    noListings: "No hay anuncios.",
    yourListing: "Tu anuncio",
    listedAt: "Publicado",
    certificateTitle: "Comprobante de compra",
    certificateText: (x: number, y: number, p: string, d: string) =>
      `Certificado para (${x},${y}) – Precio: ${p} • ${d}`,
    notEnoughFreeTiles: (available: number, need: number) =>
      `No hay suficientes m² libres. Disponible: ${available.toLocaleString("es-ES")} m² (requeridos: ${need} m²).`,
    currentPrice: "Precio actual por m²",
    progress: "Progreso",
    buy: "Comprar",
    amount: "Cantidad (m²)",
    costPreview: "Previsualización del costo",
    buyOnMap: "Comprar en el mapa",
    realMoneyNotice:
      "Nota: Todo funciona solo con PP coins (sin dinero real). Vender aumenta tu saldo; lo ves en Wallet.",
    secureRedirectNote: "Los PP coins se acreditan al instante.",
    balance: "Saldo",
    quickSell: "Venta rápida",
    gross: "Bruto",
    fee: "Tarifa",
    net: "Neto",
    sellOnMap: "Vender en el mapa",
    portfolio: "Wallet",
    overview: "Resumen",
    free: "Libre (sin casas)",
    theoreticalValue: "Valor teórico",
    priceAndProgress: "Precio y progreso",
    price: "Precio por m²",
    close: "Cerrar",
    map: "Mapa",
    overviewBtn: "Vista general",
    mode: "Modo",
    browse: "Explorar",
    buyMode: (t: number | undefined) => `Comprar (objetivo ${t || "–"} m²)`,
    sellMode: (t: number | undefined) => `Vender (objetivo ${t || "–"} m²)`,
    selected: "Seleccionado",
    cost: "Costo",
    buySelected: "Comprar celdas seleccionadas",
    sellSelected: "Vender celdas seleccionadas",
    updatingMap: "Actualizando mapa…",
    showFree: "Mostrar parcelas libres",
    hideFree: "Ocultar parcelas libres",
    todaysAreas: "Today’s Areas",
    todaysAreasIntro:
      "Destacadas hoy – zonas de lujo: Verano (Area 740), Invierno (Area 1111), Otoño (Area 989), Primavera (Area 247).",
    views: "Vistas",
    jump: "Saltar",
    chooseHouseType: "Elegir tipo de casa",
    buyConfirmTitle: "Confirmar compra",
    buyConfirmDesc: (m2: number, total: string) =>
      `Vas a comprar ${m2} m² por ${total} PPc. ¿Continuar?`,
    // Settings
    settings: "Configuración",
    settingsDesc: "Actualiza perfil y colores.",
    profile: "Perfil",
    username: "Nombre de usuario",
    saveProfile: "Guardar perfil",
    revert: "Restablecer",
    languageLabel: "Idioma",
    colors: "Colores",
    houses: "Casas",
    basic: "Básica",
    villa: "Villa",
    mansion: "Mansión",
    buildConfirmTitle: "Confirmar construcción",
    buildConfirmDesc: (type: string, cells: number) =>
      `Vas a construir una casa ${type} (${cells} m²). El costo se descuenta en PP coins. ¿Continuar?`,
    costs: "Costo",
    confirm: "Confirmar",
    cancel: "Cancelar",
    payoutTitle: "Perfil de pagos",
    payoutSubtitle: "Configura un método para recibir pagos (revisión manual).",
    method: "Método",
    paypal: "PayPal",
    iban: "IBAN",
    paypalEmailLabel: "Correo de PayPal",
    ibanLabel: "IBAN",
    accountHolder: "Titular (opcional)",
    countryLabel: "País (opcional)",
    payoutTosLabel:
      "Acepto los términos de pago (revisión manual, sin transferencia automática).",
    payoutHelp:
      "Solo guardamos lo necesario para pagar. No recogemos tarjetas en la configuración inicial.",
    savePayout: "Guardar perfil de pago",
    topupTitle: "Recargar saldo",
    topupSubtitle:
      "Compra saldo con enlaces seguros. La recarga se paga con dinero real.",
    topupSync: "Sincronizar compras",
    purchase: "Comprar",
    payoutRequestTitle: "Solicitar retiro",
    payoutRequestDesc: "Envía parte de tu saldo a tu método de pago guardado.",
    amountLabel: "Importe",
    noteLabel: "Nota (opcional)",
    requestPayoutBtn: "Solicitar retiro",
    payoutMethodMissing:
      "Primero configura un método de pago en tu perfil (Perfil > Perfil de pagos).",
    realizedProfit: "Ganancia realizada",
    deposits: "Depósitos",
    salesNet: "Ventas (neto)",
    buysCost: "Compras (costo)",
    certificates: "Certificados",
    noCertificates: "Aún no hay certificados.",
    priceHistory: "Historial de precios",
    priceHistoryDesc:
      "Precio por m² en vivo a lo largo del tiempo. Se actualiza automáticamente.",
    priceHistoryLoadError: "No se pudo cargar el historial de precios.",
    fifteenMin: "15 min",
    oneHour: "1 h",
    twentyFourHours: "24 h",
    minLabel: "Mín",
    maxLabel: "Máx",
    lastLabel: "Último",
    reload: "Recargar",
    updating: "Actualizando…",
    noCertificateTemplate: "No hay plantilla de certificado.",
    buildHouse: "Construir casa",
    priceLoadError: "No se pudo cargar el precio.",
    profileUpdated: "Perfil actualizado",
    saveFailed: "Error al guardar",
    syncFailed: "Error de sincronización",
    sellSuccess: "Venta exitosa",
    sellFailed: "Venta fallida",
    buyFailed: "Compra fallida",
    notPossibleHere: "No es posible aquí",
    selectValidBuildArea: "Selecciona parcelas propias, libres y contiguas.",
    back: "Atrás",
    slideToConfirm: "Desliza para confirmar la compra",
    confirming: "Confirmando…",
    quantity: "Cantidad",
    registered: "Registrado",
    certificate: "Certificado",
  },
} as const;

type Lang = keyof typeof translations;

// Currency display is fixed to USD across the app

const LanguageContext = createContext<{
  lang: Lang;
  setLang: (l: Lang) => void;
  t: (key: keyof (typeof translations)["en"] | any, ...args: any[]) => any;
}>({
  lang: "en",
  setLang: () => undefined,
  t: (k) => (translations.en as any)[k],
});

function applyThemePreset(): void {
  // Brand-locked colors (Rich Blue)
  const root = document.documentElement;
  root.style.setProperty("--primary", "245 70% 23%");
  root.style.setProperty("--ring", "245 70% 23%");
}

function LanguageProvider({ children }: { children: React.ReactNode }) {
  const { data: profile } = useQuery<GetProfileOutput>(["profile"], () =>
    apiClient.getProfile(),
  );
  // Persist and restore language immediately so the whole app switches at once
  const [lang, _setLang] = useState<Lang>(() => "en" as Lang);
  const setLang = (_l: Lang) => {
    void _l;
    _setLang("en" as Lang);
    try {
      localStorage.setItem("lang", "en");
    } catch {}
  };
  useEffect(() => {
    // Force English across the app regardless of profile
    setLang("en" as Lang);
  }, [profile?.language]);
  // Apply saved theme preset whenever it changes
  useEffect(() => {
    applyThemePreset();
  }, [profile && (profile as any).themePreset]);
  // Expose language globally for currency locale selection
  useEffect(() => {
    try {
      (window as any).__appLang = lang;
    } catch {}
  }, [lang]);
  const t = (key: any, ...args: any[]) => {
    const pack: any = (translations as any)[lang] ?? (translations as any).en;
    const val = pack[key];
    return typeof val === "function" ? val(...args) : val;
  };
  return (
    <LanguageContext.Provider value={{ lang, setLang, t }}>
      {children}
    </LanguageContext.Provider>
  );
}

function useLang() {
  return useContext(LanguageContext);
}

function currencyUSD(n: number | undefined) {
  const v = typeof n === "number" ? n : 0;
  const lang =
    (typeof window !== "undefined" && (window as any).__appLang) || "de";
  const locale = lang === "en" ? "en-US" : lang === "es" ? "es-ES" : "de-DE";
  return new Intl.NumberFormat(locale, {
    style: "currency",
    currency: "USD",
  }).format(v);
}

function AppSpinner({
  label,
  fullScreen = true,
}: {
  label?: string;
  fullScreen?: boolean;
}) {
  const [pct, setPct] = useState(0);

  useEffect(() => {
    setPct(0);
    const startedAt = Date.now();
    // Update less frequently to reduce main-thread work on slower devices.
    const id = window.setInterval(() => {
      const elapsed = Date.now() - startedAt;
      const p = Math.min(90, Math.max(0, Math.floor((elapsed / 4500) * 90)));
      setPct((prev) => (p > prev ? p : prev));
    }, 250);
    return () => window.clearInterval(id);
  }, []);

  return (
    <div
      className={
        fullScreen
          ? "min-h-screen flex items-center justify-center bg-background/90 text-foreground backdrop-blur"
          : "w-full h-full flex items-center justify-center bg-background/90 text-foreground backdrop-blur"
      }
      aria-label={label || "Loading"}
    >
      <div className="flex flex-col items-center gap-3">
        <CoinIcon className="h-20 w-20 animate-spin" />
        <div className="text-sm font-semibold text-foreground">{pct}%</div>
      </div>
    </div>
  );
}

function useIsGuest() {
  const supa = useSupabase();
  // Login ist verpflichtend: "Guest" bedeutet einfach "nicht eingeloggt".
  const isSignedIn = !!(supa as any)?.user;
  return !isSignedIn;
}

function HeaderUserMenu() {
  const supa = useSupabase();
  const queryClient = useQueryClient();
  const [open, setOpen] = useState(false);
  const [view, setView] = useState<
    "main" | "emailModal" | "signupModal" | "forgotModal" | "resendModal"
  >("main");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [sent, setSent] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [signupEmail, setSignupEmail] = useState("");
  const [signupPassword, setSignupPassword] = useState("");
  const [signupPassword2, setSignupPassword2] = useState("");
  const [signupStatus, setSignupStatus] = useState<string | null>(null);

  const [forgotEmail, setForgotEmail] = useState("");
  const [forgotStatus, setForgotStatus] = useState<string | null>(null);
  const [forgotSending, setForgotSending] = useState<boolean>(false);

  const [resendEmail, setResendEmail] = useState("");
  const [resendStatus, setResendStatus] = useState<string | null>(null);

  useEffect(() => {
    const handler = () => {
      setView("main");
      setEmail("");
      setPassword("");
      setSent(false);
      setError(null);
      setFirstName("");
      setLastName("");
      setSignupEmail("");
      setSignupPassword("");
      setSignupPassword2("");
      setSignupStatus(null);
      setForgotEmail("");
      setForgotStatus(null);
      setForgotSending(false);
      setResendEmail("");
      setResendStatus(null);
      setOpen(true);
    };
    window.addEventListener("openSignIn", handler as any);
    return () => window.removeEventListener("openSignIn", handler as any);
  }, []);

  const accessToken = supa.accessToken ?? undefined;
  const { data: profile } = useQuery<GetProfileOutput>(
    ["profile_header", accessToken ?? null],
    () => apiClient.getProfile({ accessToken } as any),
    {
      enabled: !!supa.user && !!accessToken,
      staleTime: 60_000,
      refetchOnWindowFocus: false,
      retry: 0,
    },
  );

  const shortId = (supa.user?.id || "").slice(0, 8);
  const label =
    profile?.displayName ||
    supa.user?.email ||
    (shortId ? `User ${shortId}` : "Account");
  const avatarUrl = profile?.profileImageUrl ?? undefined;

  if (!supa.ready) {
    return (
      <Badge data-tour="user-menu" variant="secondary" className="rounded-full">
        ...
      </Badge>
    );
  }

  // Not signed in (public browsing)
  if (!supa.user) {
    return (
      <>
        <Button
          data-tour="user-menu"
          size="sm"
          variant="secondary"
          className="rounded-full"
          onClick={() => {
            setView("main");
            setEmail("");
            setPassword("");
            setSent(false);
            setError(null);
            setOpen(true);
          }}
        >
          <LogIn className="h-4 w-4 mr-2" />
          Sign in
        </Button>

        <Dialog
          open={open}
          onOpenChange={(next) => {
            setOpen(next);
            if (!next) {
              setView("main");
              setEmail("");
              setPassword("");
              setSent(false);
              setError(null);
              setFirstName("");
              setLastName("");
              setSignupEmail("");
              setSignupPassword("");
              setSignupPassword2("");
              setSignupStatus(null);
              setForgotEmail("");
              setForgotStatus(null);
              setForgotSending(false);
              setResendEmail("");
              setResendStatus(null);
            }
          }}
        >
          <DialogContent className="p-0 border-0 bg-transparent shadow-none max-w-none w-[100vw] h-[100vh]">
            <div
              className="fixed inset-0"
              style={{
                backgroundImage:
                  "radial-gradient(1200px 600px at 50% 0%, hsla(var(--primary), 0.22), transparent 60%), linear-gradient(to bottom, hsla(var(--background), 1), hsla(var(--secondary), 1))",
              }}
            />
            <div className="fixed inset-0 grid place-items-center p-4 sm:p-[18px]">
              <div className="absolute inset-0 bg-background/20 backdrop-blur-[2px]" />

              <div className="relative w-full max-w-[460px] rounded-[22px] bg-card/95 shadow-2xl p-4">
                {supa.configError ? (
                  <Alert className="mb-3">
                    <AlertDescription>
                      Sign-in is currently unavailable: {supa.configError}
                    </AlertDescription>
                  </Alert>
                ) : null}
                {error ? (
                  <Alert className="mb-3">
                    <AlertDescription>{error}</AlertDescription>
                  </Alert>
                ) : null}
                <div className="flex flex-col gap-3">
                  <button
                    className="w-full h-16 rounded-full border bg-background text-foreground font-extrabold text-[22px] flex items-center justify-center gap-3 shadow-md disabled:opacity-60"
                    id="googleBtn"
                    type="button"
                    disabled={!!supa.configError}
                    onClick={async () => {
                      setError(null);
                      try {
                        await supa.signInWithGoogle();
                      } catch (e: any) {
                        setError(e?.message || "Sign-in failed.");
                      }
                    }}
                  >
                    <svg
                      className="h-6 w-6"
                      viewBox="0 0 48 48"
                      aria-hidden="true"
                    >
                      <path
                        fill="#FFC107"
                        d="M43.611 20.083H42V20H24v8h11.303C33.646 32.91 29.19 36 24 36c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.963 3.037l5.657-5.657C34.045 6.053 29.268 4 24 4 12.955 4 4 12.955 4 24s8.955 20 20 20 20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"
                      />
                      <path
                        fill="#FF3D00"
                        d="M6.306 14.691l6.571 4.819C14.655 16.108 19.01 12 24 12c3.059 0 5.842 1.154 7.963 3.037l5.657-5.657C34.045 6.053 29.268 4 24 4 16.318 4 9.656 8.337 6.306 14.691z"
                      />
                      <path
                        fill="#4CAF50"
                        d="M24 44c5.09 0 9.776-1.946 13.287-5.117l-6.131-5.189C29.109 35.091 26.676 36 24 36c-5.168 0-9.612-3.064-11.275-7.45l-6.54 5.037C9.5 39.556 16.227 44 24 44z"
                      />
                      <path
                        fill="#1976D2"
                        d="M43.611 20.083H42V20H24v8h11.303c-.792 2.236-2.231 4.144-4.147 5.44l.004-.003 6.131 5.189C36.857 39.02 44 34 44 24c0-1.341-.138-2.65-.389-3.917z"
                      />
                    </svg>
                    Continue with Google
                  </button>

                  <div className="flex items-center gap-3 text-muted-foreground font-bold text-base justify-center my-1">
                    <div className="h-px flex-1 bg-border" />
                    OR
                    <div className="h-px flex-1 bg-border" />
                  </div>

                  <button
                    className="w-full h-16 rounded-full bg-primary text-primary-foreground font-extrabold text-[22px] shadow-lg disabled:opacity-60"
                    id="emailLoginBtn"
                    type="button"
                    disabled={!!supa.configError}
                    onClick={() => {
                      setError(null);
                      setSent(false);
                      setPassword("");
                      setView("emailModal");
                    }}
                  >
                    Continue with Email
                  </button>

                  <button
                    className="w-full h-16 rounded-full border bg-background text-foreground font-extrabold text-[22px] shadow-md disabled:opacity-60"
                    id="emailSignupBtn"
                    type="button"
                    disabled={!!supa.configError}
                    onClick={() => {
                      setError(null);
                      setSignupStatus(null);
                      setForgotStatus(null);
                      setResendStatus(null);
                      setView("signupModal");
                    }}
                  >
                    Create an Account
                  </button>

                  <button
                    type="button"
                    className="w-full h-12 rounded-full border bg-transparent text-foreground font-semibold"
                    onClick={() => setOpen(false)}
                  >
                    Close
                  </button>
                </div>
                {view === "emailModal" ? (
                  <div
                    className="fixed inset-0 z-[9999] bg-foreground/45 flex items-center justify-center p-4"
                    onClick={() => {
                      setView("main");
                      setPassword("");
                      setSent(false);
                      setError(null);
                    }}
                  >
                    <div
                      className="w-full max-w-[460px] bg-background rounded-[20px] p-4 shadow-2xl"
                      onClick={(e) => e.stopPropagation()}
                      role="dialog"
                      aria-modal="true"
                      aria-label="Email sign in"
                    >
                      <div className="text-lg font-semibold mb-3">
                        Email Sign In
                      </div>

                      <div className="flex flex-col gap-2">
                        <Label>Email</Label>
                        <Input
                          value={email}
                          onChange={(e) => setEmail(e.target.value)}
                          placeholder="name@example.com"
                          disabled={!!supa.configError}
                          className="h-12 rounded-2xl"
                        />
                      </div>

                      <div className="flex flex-col gap-2 mt-3">
                        <Label>Password</Label>
                        <Input
                          value={password}
                          onChange={(e) => setPassword(e.target.value)}
                          placeholder="••••••••"
                          type="password"
                          disabled={!!supa.configError}
                          className="h-12 rounded-2xl"
                        />
                      </div>

                      {sent ? (
                        <div className="text-xs text-muted-foreground mt-3">
                          Link sent. Please check your inbox.
                        </div>
                      ) : null}

                      <div className="flex gap-2 mt-4">
                        <button
                          type="button"
                          className="flex-1 h-[54px] rounded-full border bg-transparent text-foreground font-extrabold text-[18px]"
                          id="closeLogin"
                          onClick={() => {
                            setView("main");
                            setPassword("");
                            setSent(false);
                            setError(null);
                          }}
                        >
                          Close
                        </button>
                        <button
                          type="button"
                          disabled={!!supa.configError}
                          className="flex-1 h-[54px] rounded-full bg-primary text-primary-foreground font-extrabold text-[18px] shadow-lg disabled:opacity-60"
                          id="doLogin"
                          onClick={async () => {
                            setError(null);
                            try {
                              const hasPw = (password || "").trim().length > 0;
                              if (hasPw) {
                                await supa.signInWithPassword(email, password);
                                setOpen(false);
                              } else {
                                await supa.sendEmailLink(email);
                                setSent(true);
                              }
                            } catch (e: any) {
                              setError(e?.message || "Sign-in failed.");
                            }
                          }}
                        >
                          Sign In
                        </button>
                      </div>

                      <div className="mt-3">
                        <div className="mt-1 flex flex-col gap-2 items-start">
                          <button
                            type="button"
                            className="underline text-primary font-extrabold text-xs"
                            id="forgotPasswordBtn"
                            onClick={() => {
                              setForgotStatus(null);
                              setForgotSending(false);
                              setView("forgotModal");
                              setForgotEmail(email);
                            }}
                          >
                            Forgot password?
                          </button>
                          <button
                            type="button"
                            className="underline text-primary font-extrabold text-xs"
                            id="resendConfirmBtn"
                            onClick={() => {
                              setResendStatus(null);
                              setView("resendModal");
                              setResendEmail(email);
                            }}
                          >
                            Resend confirmation email
                          </button>
                        </div>
                      </div>

                      <div className="mt-3 text-xs text-muted-foreground font-semibold">
                        If email confirmation is enabled, you must confirm your
                        email before you can sign in.
                      </div>
                    </div>
                  </div>
                ) : null}
                {view === "signupModal" ? (
                  <div
                    className="fixed inset-0 z-[9999] bg-foreground/45 flex items-center justify-center p-4"
                    onClick={() => {
                      setView("main");
                      setError(null);
                      setSignupStatus(null);
                    }}
                  >
                    <div
                      className="w-[min(980px,94vw)] bg-background rounded-[20px] shadow-2xl p-6 sm:p-10"
                      onClick={(e) => e.stopPropagation()}
                      role="dialog"
                      aria-modal="true"
                      aria-label="Create account"
                    >
                      <div className="text-center text-[34px] sm:text-[44px] font-medium mb-6">
                        Create account
                      </div>
                      <div className="w-full max-w-[820px] mx-auto flex flex-col gap-4">
                        <Input
                          className="h-[64px] sm:h-[74px] rounded-none text-[20px] sm:text-[24px] px-5 sm:px-7 border-2"
                          placeholder="First name"
                          value={firstName}
                          onChange={(e) => setFirstName(e.target.value)}
                          disabled={!!supa.configError}
                        />
                        <Input
                          className="h-[64px] sm:h-[74px] rounded-none text-[20px] sm:text-[24px] px-5 sm:px-7 border-2"
                          placeholder="Last name"
                          value={lastName}
                          onChange={(e) => setLastName(e.target.value)}
                          disabled={!!supa.configError}
                        />
                        <Input
                          className="h-[64px] sm:h-[74px] rounded-none text-[20px] sm:text-[24px] px-5 sm:px-7 border-2"
                          placeholder="Email"
                          value={signupEmail}
                          onChange={(e) => setSignupEmail(e.target.value)}
                          disabled={!!supa.configError}
                        />
                        <Input
                          className="h-[64px] sm:h-[74px] rounded-none text-[20px] sm:text-[24px] px-5 sm:px-7 border-2"
                          placeholder="Password"
                          type="password"
                          value={signupPassword}
                          onChange={(e) => setSignupPassword(e.target.value)}
                          disabled={!!supa.configError}
                        />
                        <Input
                          className="h-[64px] sm:h-[74px] rounded-none text-[20px] sm:text-[24px] px-5 sm:px-7 border-2"
                          placeholder="Confirm password"
                          type="password"
                          value={signupPassword2}
                          onChange={(e) => setSignupPassword2(e.target.value)}
                          disabled={!!supa.configError}
                        />

                        <div className="mt-2 flex flex-wrap items-center justify-center gap-3">
                          <button
                            type="button"
                            className="w-full sm:w-[220px] h-[64px] sm:h-[74px] rounded-[12px] sm:rounded-none border-2 font-extrabold text-[22px]"
                            id="cancelSignup"
                            onClick={() => {
                              setView("main");
                              setError(null);
                              setSignupStatus(null);
                            }}
                          >
                            Cancel
                          </button>
                          <button
                            type="button"
                            className="w-full sm:w-[220px] h-[64px] sm:h-[74px] rounded-[12px] sm:rounded-none bg-foreground text-background font-extrabold text-[22px] disabled:opacity-60"
                            id="doSignup"
                            disabled={!!supa.configError}
                            onClick={async () => {
                              setError(null);
                              setSignupStatus(null);
                              const f = (firstName || "").trim();
                              const l = (lastName || "").trim();
                              const em = (signupEmail || "").trim();
                              const p1 = signupPassword || "";
                              const p2 = signupPassword2 || "";
                              if (!f || !l || !em || !p1 || !p2) {
                                setSignupStatus("Please fill in all fields.");
                                return;
                              }
                              if (p1 !== p2) {
                                setSignupStatus("Passwords do not match.");
                                return;
                              }
                              if (p1.length < 8) {
                                setSignupStatus(
                                  "Password must be at least 8 characters.",
                                );
                                return;
                              }
                              try {
                                const res = await supa.signUp({
                                  firstName: f,
                                  lastName: l,
                                  email: em,
                                  password: p1,
                                });
                                setSignupStatus(res.message);
                                if (res.hasSession) {
                                  setView("main");
                                  setOpen(false);
                                }
                              } catch (e: any) {
                                setSignupStatus(e?.message || "Signup failed.");
                              }
                            }}
                          >
                            Create
                          </button>
                        </div>

                        <div className="text-center text-sm text-muted-foreground font-semibold min-h-[20px]">
                          {signupStatus ?? ""}
                        </div>
                      </div>
                    </div>
                  </div>
                ) : null}
                {view === "forgotModal" ? (
                  <div
                    className="fixed inset-0 z-[9999] bg-foreground/45 flex items-center justify-center p-4"
                    onClick={() => {
                      setView("main");
                      setForgotStatus(null);
                      setForgotSending(false);
                    }}
                  >
                    <div
                      className="w-full max-w-[460px] bg-background rounded-[20px] p-4 shadow-2xl"
                      onClick={(e) => e.stopPropagation()}
                      onMouseDown={(e) => e.stopPropagation()}
                      onPointerDown={(e) => e.stopPropagation()}
                      onTouchStart={(e) => e.stopPropagation()}
                      role="dialog"
                      aria-modal="true"
                      aria-label="Reset password"
                    >
                      <div className="text-lg font-semibold mb-3">
                        Reset password
                      </div>
                      <div className="flex flex-col gap-2">
                        <Label>Email</Label>
                        <Input
                          value={forgotEmail}
                          onChange={(e) => setForgotEmail(e.target.value)}
                          placeholder="name@example.com"
                          disabled={forgotSending}
                          className="h-12 rounded-2xl"
                        />
                      </div>
                      <div className="flex gap-2 mt-4">
                        <button
                          type="button"
                          className="flex-1 h-[54px] rounded-full border bg-transparent text-foreground font-extrabold text-[18px]"
                          onClick={() => {
                            setView("main");
                            setForgotStatus(null);
                          }}
                        >
                          Close
                        </button>
                        <button
                          type="button"
                          className="flex-1 h-[54px] rounded-full bg-primary text-primary-foreground font-extrabold text-[18px] shadow-lg disabled:opacity-60"
                          disabled={forgotSending}
                          onMouseDown={(e) => e.stopPropagation()}
                          onPointerDown={(e) => e.stopPropagation()}
                          onTouchStart={(e) => e.stopPropagation()}
                          onClick={async () => {
                            setForgotStatus(null);
                            const em = (forgotEmail || "").trim();

                            console.log("[forgot] send clicked", {
                              hasSupa: !!supa,
                              hasResetFn:
                                typeof (supa as any)?.resetPasswordForEmail ===
                                "function",
                              emailLength: em.length,
                              isSending: forgotSending,
                            });

                            if (!em) {
                              setForgotStatus("Enter your email first.");
                              return;
                            }
                            setForgotSending(true);
                            try {
                              const msg = await supa.resetPasswordForEmail(em);
                              setForgotStatus(msg);
                            } catch (e: any) {
                              setForgotStatus(
                                e?.message || "Failed to send reset email.",
                              );
                            } finally {
                              setForgotSending(false);
                            }
                          }}
                        >
                          Send
                        </button>
                      </div>
                      <div className="mt-3 text-sm text-muted-foreground font-semibold min-h-[20px] text-center">
                        {forgotStatus ?? ""}
                      </div>
                    </div>
                  </div>
                ) : null}
                {view === "resendModal" ? (
                  <div
                    className="fixed inset-0 z-[9999] bg-foreground/45 flex items-center justify-center p-4"
                    onClick={() => {
                      setView("main");
                      setResendStatus(null);
                    }}
                  >
                    <div
                      className="w-full max-w-[460px] bg-background rounded-[20px] p-4 shadow-2xl"
                      onClick={(e) => e.stopPropagation()}
                      role="dialog"
                      aria-modal="true"
                      aria-label="Resend confirmation email"
                    >
                      <div className="text-lg font-semibold mb-3">
                        Resend confirmation
                      </div>
                      <div className="flex flex-col gap-2">
                        <Label>Email</Label>
                        <Input
                          value={resendEmail}
                          onChange={(e) => setResendEmail(e.target.value)}
                          placeholder="name@example.com"
                          disabled={!!supa.configError}
                          className="h-12 rounded-2xl"
                        />
                      </div>
                      <div className="flex gap-2 mt-4">
                        <button
                          type="button"
                          className="flex-1 h-[54px] rounded-full border bg-transparent text-foreground font-extrabold text-[18px]"
                          onClick={() => {
                            setView("main");
                            setResendStatus(null);
                          }}
                        >
                          Close
                        </button>
                        <button
                          type="button"
                          className="flex-1 h-[54px] rounded-full bg-primary text-primary-foreground font-extrabold text-[18px] shadow-lg disabled:opacity-60"
                          disabled={!!supa.configError}
                          onClick={async () => {
                            setResendStatus(null);
                            const em = (resendEmail || "").trim();
                            if (!em) {
                              setResendStatus("Enter your email first.");
                              return;
                            }
                            try {
                              const msg =
                                await supa.resendSignupConfirmation(em);
                              setResendStatus(msg);
                            } catch (e: any) {
                              setResendStatus(
                                e?.message || "Failed to resend confirmation.",
                              );
                            }
                          }}
                        >
                          Send
                        </button>
                      </div>
                      <div className="mt-3 text-sm text-muted-foreground font-semibold min-h-[20px] text-center">
                        {resendStatus ?? ""}
                      </div>
                    </div>
                  </div>
                ) : null}{" "}
              </div>
            </div>
          </DialogContent>
        </Dialog>
      </>
    );
  }

  // Signed in
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <button
          data-tour="user-menu"
          className="flex items-center gap-2 rounded-full px-2 py-1 hover:bg-secondary"
          aria-label="User menu"
        >
          <Avatar className="h-7 w-7">
            <AvatarImage src={avatarUrl} />
            <AvatarFallback
              className="text-transparent"
              style={_avatarGradientStyle(
                ((supa.user?.id as any) ||
                  profile?.displayName ||
                  label ||
                  "user") as string,
              )}
            >
              <span className="sr-only">{label}</span>
            </AvatarFallback>
          </Avatar>
          <span className="hidden sm:inline text-sm max-w-[10rem] truncate">
            {label}
          </span>
        </button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuItem
          onSelect={(e) => {
            e.preventDefault();
            try {
              (window as any).__openSettings?.();
            } catch {}
            try {
              window.dispatchEvent(new Event("openSettings"));
            } catch {}
          }}
        >
          Settings
        </DropdownMenuItem>
        <DropdownMenuItem
          onSelect={(e) => {
            e.preventDefault();
            try {
              (window as any).__closeSettings?.();
            } catch {}
            const evt = new CustomEvent("navigateTo", {
              detail: "/profile",
            });
            window.dispatchEvent(evt);
          }}
        >
          Profile
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          onSelect={(e) => {
            e.preventDefault();
            setError(null);
            (async () => {
              try {
                await supa.endSession();
              } catch {}
              try {
                queryClient.clear();
              } catch {}
              try {
                window.location.href = "/";
              } catch {}
            })();
          }}
        >
          Log out
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function PP15Footer() {
  return (
    <footer className="w-full border-t bg-background/60">
      <div className="mx-auto max-w-[1280px] px-4 py-4 md:py-5">
        <div className="text-xs text-muted-foreground leading-relaxed text-center">
          PPC are in-app credits usable only within PP15. They are not
          transferable between users, not redeemable for cash, and not tradeable
          outside the app. Participation is optional: creating an account is
          free, browsing is free, and users are never required to add funds.
          PP15 does not promise or guarantee profits, returns, or value
          increases, and nothing in PP15 should be understood as investment
          advice. The 2nd Market is a user-to-user (C2C) marketplace for virtual
          m² collectibles. All trades use PP coins only (no real money), and
          ownership transfers instantly within PP15. PP15 does not provide
          escrow services or hold customer funds.
        </div>
        <div className="mt-2 text-xs text-foreground text-center">
          © 2026 PP15 Digital Platform. All rights reserved.
        </div>
      </div>
    </footer>
  );
}

function ScreenContainer({
  children,
  title,
  right,
}: {
  children: React.ReactNode;
  title: string;
  right?: React.ReactNode;
}) {
  const { t } = useLang();
  const isGuest = useIsGuest();
  const [menuOpen, setMenuOpen] = React.useState<boolean>(true);
  const location = useLocation();
  const navigate = useNavigate();

  const SUPPORT_SCRIPT_SRC = "https://elfsightcdn.com/platform.js";
  const SUPPORT_WIDGET_CLASS =
    "elfsight-app-0134bc12-2ca1-40c3-8320-c7ce4ee02dec";

  const [supportOpen, setSupportOpen] = React.useState(false);
  const [supportInstanceKey, setSupportInstanceKey] = React.useState(0);

  const [isMobile, setIsMobile] = React.useState<boolean>(() => {
    try {
      return window.matchMedia("(max-width: 767px)").matches;
    } catch {
      return false;
    }
  });

  React.useEffect(() => {
    try {
      const mql = window.matchMedia("(max-width: 767px)");
      const onChange = () => setIsMobile(!!mql.matches);
      onChange();
      if (typeof mql.addEventListener === "function") {
        mql.addEventListener("change", onChange);
        return () => mql.removeEventListener("change", onChange);
      }
      // Safari fallback
      // @ts-ignore
      mql.addListener(onChange);
      // @ts-ignore
      return () => mql.removeListener(onChange);
    } catch {
      return;
    }
  }, []);

  const supportAllowed =
    !isMobile || (location.pathname ?? "").startsWith("/portfolio");

  // Expose global open/close helpers so buttons anywhere can open Support.
  React.useEffect(() => {
    try {
      (window as any).__openSupport = () => {
        if (!supportAllowed) return;
        setSupportOpen(true);
      };
      (window as any).__closeSupport = () => setSupportOpen(false);
    } catch {}
    return () => {
      try {
        delete (window as any).__openSupport;
        delete (window as any).__closeSupport;
      } catch {}
    };
  }, [supportAllowed]);

  // Safety: if support becomes disallowed (e.g., switch to iPhone width), close it.
  React.useEffect(() => {
    if (!supportAllowed && supportOpen) setSupportOpen(false);
  }, [supportAllowed, supportOpen]);

  // Load Elfsight platform script once (more reliable for popups / SPA navigation).
  React.useEffect(() => {
    try {
      const existing = document.querySelector(
        `script[src="${SUPPORT_SCRIPT_SRC}"]`,
      ) as HTMLScriptElement | null;

      if (!existing) {
        const s = document.createElement("script");
        s.src = SUPPORT_SCRIPT_SRC;
        s.async = true;
        s.setAttribute("data-use-service-core", "true");
        s.setAttribute("defer", "true");
        document.head.appendChild(s);
      }
    } catch {}
  }, []);

  React.useEffect(() => {
    if (supportOpen) {
      // Force a fresh mount of the widget container each time.
      setSupportInstanceKey((k) => k + 1);

      const tryInit = () => {
        try {
          const w = window as any;
          if (typeof w?.eappsPlatform?.init === "function") {
            w.eappsPlatform.init();
          }
          if (typeof w?.elfsight?.init === "function") {
            w.elfsight.init();
          }
        } catch {}
      };

      // Multiple tries: Elfsight can be slow on first load in popups.
      const t1 = window.setTimeout(tryInit, 50);
      const t2 = window.setTimeout(tryInit, 250);
      const t3 = window.setTimeout(tryInit, 1000);

      return () => {
        window.clearTimeout(t1);
        window.clearTimeout(t2);
        window.clearTimeout(t3);
      };
    }

    // Cleanup: remove any lingering Elfsight overlays so the app looks like before.
    try {
      const candidates = Array.from(
        document.querySelectorAll(
          '[class*="eapps-"], [class^="eapps-"], [class*="elfsight"], [class^="elfsight"]',
        ),
      ) as HTMLElement[];

      for (const el of candidates) {
        // Keep our own widget container if it exists.
        if (el.classList.contains(SUPPORT_WIDGET_CLASS)) continue;
        const cls = el.className || "";
        if (
          typeof cls === "string" &&
          (cls.includes("eapps-") || cls.includes("elfsight"))
        ) {
          el.remove();
        }
      }
    } catch {}
  }, [supportOpen]);

  const navItems = [
    { to: "/", label: t("market"), icon: <Home className="h-5 w-5" /> },
    { to: "/map", label: t("map"), icon: <Building2 className="h-5 w-5" /> },
    { to: "/islands", label: "Islands", icon: <Search className="h-5 w-5" /> },
    {
      to: "/secondary",
      label: t("secondMarket"),
      icon: <ArrowLeftRight className="h-5 w-5" />,
    },
    {
      to: "/portfolio",
      label: "Wallet",
      icon: <Wallet2 className="h-5 w-5" />,
    },
  ];
  const maxW = menuOpen ? "max-w-[1280px]" : "max-w-[1440px]";
  const rootPaths = ["/", "/map", "/islands", "/secondary", "/portfolio"];
  const showHistoryArrows = !rootPaths.includes(location.pathname);
  const relaxedScrollChrome = (location.pathname ?? "").startsWith("/news");

  const showMobileGeneralButton = isMobile && location.pathname !== "/general";

  const lockPageScroll = !isMobile && location.pathname === "/general";

  React.useEffect(() => {
    if (!lockPageScroll) return;
    try {
      const body = document.body;
      const html = document.documentElement;

      const prevBodyOverflow = body.style.overflow;
      const prevBodyOverscroll = (body.style as any).overscrollBehavior;
      const prevHtmlOverflow = html.style.overflow;
      const prevHtmlOverscroll = (html.style as any).overscrollBehavior;

      body.style.overflow = "hidden";
      html.style.overflow = "hidden";
      (body.style as any).overscrollBehavior = "none";
      (html.style as any).overscrollBehavior = "none";

      return () => {
        body.style.overflow = prevBodyOverflow;
        html.style.overflow = prevHtmlOverflow;
        (body.style as any).overscrollBehavior = prevBodyOverscroll;
        (html.style as any).overscrollBehavior = prevHtmlOverscroll;
      };
    } catch {
      return;
    }
  }, [lockPageScroll]);

  return (
    <div
      className={`${lockPageScroll ? "fixed inset-0 overflow-hidden" : "min-h-screen"} bg-background text-foreground overflow-x-hidden`}
    >
      <div className={`flex ${lockPageScroll ? "h-full" : ""}`}>
        {/* Left sidebar */}
        <aside
          className={`${menuOpen ? "w-64" : "w-16"} hidden md:flex shrink-0 bg-card/40 flex-col`}
        >
          <div
            className={`${relaxedScrollChrome ? "" : "sticky top-0 h-screen"} flex flex-col`}
          >
            <div className="px-3 pt-4 pb-2">
              <button
                data-tour="pp-info"
                onClick={() => navigate("/pp-landing")}
                className="inline-flex items-center justify-center rounded-full p-1 hover:bg-accent"
                aria-label="PP coins info"
              >
                {" "}
                <div
                  className="relative inline-block"
                  style={{ transform: "rotate(-18deg)" }}
                >
                  <CoinIcon className="h-7 w-7" />
                </div>{" "}
              </button>
            </div>
            <TooltipProvider>
              <nav className="px-2 py-2 space-y-1">
                {navItems.map((it) => {
                  const infoText =
                    it.to === "/"
                      ? "Live price chart and trading actions."
                      : it.to === "/map"
                        ? "Explore the grid, buy plots, build and manage land."
                        : it.to === "/islands"
                          ? "Browse islands, see holders, buy/sell island shares."
                          : it.to === "/secondary"
                            ? "Player-to-player land listings: buy, sell, cancel."
                            : it.to === "/portfolio"
                              ? "Your wallet: balances, value overview and history."
                              : "";

                  return (
                    <div key={it.to} className="flex items-center gap-1">
                      <NavLink
                        to={it.to}
                        data-tour={
                          it.to === "/"
                            ? "nav-market"
                            : it.to === "/map"
                              ? "nav-map"
                              : it.to === "/islands"
                                ? "nav-islands"
                                : it.to === "/secondary"
                                  ? "nav-secondary"
                                  : it.to === "/portfolio"
                                    ? "nav-wallet"
                                    : undefined
                        }
                        className={({ isActive }) =>
                          `flex flex-1 items-center gap-3 rounded-md px-3 py-2.5 hover:bg-accent ${
                            isActive
                              ? "pp15-burger-active bg-accent"
                              : "text-foreground"
                          }`
                        }
                      >
                        {it.icon}
                        <span className={`${menuOpen ? "block" : "hidden"}`}>
                          {it.label}
                        </span>
                      </NavLink>

                      <Popover>
                        <PopoverTrigger asChild>
                          <button
                            type="button"
                            className="shrink-0 rounded-md text-foreground/80 hover:bg-accent hover:text-foreground w-7 h-7 grid place-items-center"
                            aria-label={`Info: ${it.label}`}
                            onClick={(e) => e.stopPropagation()}
                          >
                            <Info className="h-3.5 w-3.5" />
                          </button>
                        </PopoverTrigger>
                        <PopoverContent side="right" className="max-w-[240px]">
                          <div className="text-xs leading-snug">{infoText}</div>
                        </PopoverContent>
                      </Popover>
                    </div>
                  );
                })}

                {/* Support (under Wallet) */}
                <div className="flex items-center gap-1">
                  <button
                    data-tour="support"
                    type="button"
                    className="flex flex-1 items-center gap-3 rounded-md px-3 py-2.5 hover:bg-accent text-foreground"
                    onClick={() => {
                      if (!supportAllowed) return;
                      setSupportOpen(true);
                    }}
                  >
                    <Headset className="h-5 w-5" />
                    <span className={`${menuOpen ? "block" : "hidden"}`}>
                      Support
                    </span>
                  </button>
                  <Popover>
                    <PopoverTrigger asChild>
                      <button
                        type="button"
                        className="shrink-0 rounded-md text-foreground/80 hover:bg-accent hover:text-foreground w-7 h-7 grid place-items-center"
                        aria-label="Info: Support"
                        onClick={(e) => e.stopPropagation()}
                      >
                        <Info className="h-3.5 w-3.5" />
                      </button>
                    </PopoverTrigger>
                    <PopoverContent side="right" className="max-w-[240px]">
                      <div className="text-xs leading-snug">
                        Live support chat for help and questions.
                      </div>
                    </PopoverContent>
                  </Popover>{" "}
                </div>

                <div className="flex items-center gap-1">
                  <NavLink
                    to="/general"
                    className={({ isActive }) =>
                      `flex flex-1 items-center gap-3 rounded-md px-3 py-2.5 hover:bg-accent ${
                        isActive
                          ? "pp15-burger-active bg-accent"
                          : "text-foreground"
                      }`
                    }
                  >
                    <Info className="h-5 w-5" />
                    <span className={`${menuOpen ? "block" : "hidden"}`}>
                      General
                    </span>
                  </NavLink>
                  <Popover>
                    <PopoverTrigger asChild>
                      <button
                        type="button"
                        className="shrink-0 rounded-md text-foreground/80 hover:bg-accent hover:text-foreground w-7 h-7 grid place-items-center"
                        aria-label="Info: General"
                        onClick={(e) => e.stopPropagation()}
                      >
                        <Info className="h-3.5 w-3.5" />
                      </button>
                    </PopoverTrigger>
                    <PopoverContent side="right" className="max-w-[240px]">
                      <div className="text-xs leading-snug">
                        App basics, tips, rules and how things work.
                      </div>
                    </PopoverContent>
                  </Popover>{" "}
                </div>
              </nav>{" "}
            </TooltipProvider>
          </div>
        </aside>

        {/* Divider (desktop) */}
        <div
          className="hidden md:block w-px bg-border self-stretch"
          aria-hidden="true"
        />

        {/* Main content */}
        <div
          className={`flex-1 min-w-0 flex flex-col ${lockPageScroll ? "h-full" : "min-h-screen"}`}
        >
          <header
            className={`${relaxedScrollChrome ? "" : "sticky top-0"} z-20 bg-background/80 backdrop-blur border-b safe-top safe-x`}
          >
            <div
              className={`w-full ${maxW} mx-auto px-4 py-3 flex items-center justify-between gap-2 flex-nowrap md:flex-wrap`}
            >
              {" "}
              <div className="flex items-center gap-3">
                <div className="flex flex-col items-start leading-tight md:hidden">
                  <button
                    data-tour="pp-info"
                    onClick={() => navigate("/pp-landing")}
                    className="inline-flex items-center justify-center rounded-full p-1 hover:bg-accent"
                    aria-label="PP coins info"
                  >
                    <div
                      className="relative inline-block"
                      style={{ transform: "rotate(-18deg)" }}
                    >
                      <CoinIcon className="h-7 w-7" />
                    </div>
                  </button>{" "}
                  <h1 className="mt-1 text-base sm:text-lg font-semibold">
                    {title}
                  </h1>
                </div>
                <h1 className="hidden md:block text-base sm:text-lg font-semibold">
                  {title}
                </h1>
                {/* Mobile toggle */}
                <button
                  onClick={() => setMenuOpen((v) => !v)}
                  className="hidden md:inline-flex rounded-md p-2 hover:bg-accent"
                  aria-label="Toggle menu"
                >
                  <Menu className="h-5 w-5" />
                </button>
              </div>
              <div className="flex items-center gap-2">
                {right}

                {showMobileGeneralButton && (
                  <Button
                    variant="secondary"
                    size="icon"
                    className="h-11 w-11 rounded-full sm:hidden"
                    onClick={() => navigate("/general")}
                    aria-label="General"
                    title="General"
                  >
                    <Info className="h-5 w-5" />
                  </Button>
                )}

                {/* Report button */}
                <Button
                  data-tour="report"
                  variant="secondary"
                  size="icon"
                  className="h-11 w-11 md:h-8 md:w-8 rounded-full sm:hidden"
                  onClick={() => {
                    try {
                      (window as any).__openReport?.();
                    } catch {}
                  }}
                  aria-label="Report Issue"
                >
                  <Flag className="h-5 w-5 md:h-4 md:w-4" />
                </Button>
                <Button
                  data-tour="report"
                  variant="secondary"
                  size="sm"
                  className="hidden sm:inline-flex"
                  onClick={() => {
                    try {
                      (window as any).__openReport?.();
                    } catch {}
                  }}
                >
                  <Flag className="h-4 w-4 mr-2" />
                  Report Issue
                </Button>
                {showHistoryArrows && (
                  <div className="flex items-center gap-1">
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-11 w-11 md:h-8 md:w-8 rounded-full border border-border bg-accent/60 hover:bg-accent"
                      onClick={() => navigate(-1)}
                      aria-label="Back"
                    >
                      <ArrowLeft className="h-5 w-5 md:h-4 md:w-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-11 w-11 md:h-8 md:w-8 rounded-full border border-border bg-accent/60 hover:bg-accent"
                      onClick={() => navigate(1)}
                      aria-label="Forward"
                    >
                      <ArrowRight className="h-5 w-5 md:h-4 md:w-4" />
                    </Button>
                  </div>
                )}
                <Button
                  variant="secondary"
                  size="icon"
                  className="h-11 w-11 md:h-8 md:w-8 rounded-full"
                  onClick={() => {
                    if (isGuest) {
                      try {
                        window.dispatchEvent(new Event("openSignIn"));
                      } catch {}
                    }
                    navigate("/profile");
                  }}
                  aria-label="Profile"
                  title="Profile"
                >
                  <User className="h-5 w-5 md:h-4 md:w-4" />
                </Button>
                <SettingsButton />
                <HeaderUserMenu />
              </div>
            </div>
          </header>
          {false && (
            <div className="sm:hidden border-b bg-background">
              <nav className="px-3 py-2 space-y-1">
                {navItems.map((it) => (
                  <NavLink
                    key={it.to}
                    to={it.to}
                    className={({ isActive }) =>
                      `flex items-center gap-3 rounded-md px-3 py-3 ${
                        isActive ? "text-primary bg-accent" : "text-foreground"
                      }`
                    }
                    onClick={() => setMenuOpen(false)}
                  >
                    {it.icon}
                    <span>{it.label}</span>
                  </NavLink>
                ))}
              </nav>
            </div>
          )}
          <main
            className={`flex-1 min-h-0 pb-[calc(6rem+var(--safe-bottom))] md:pb-10 safe-x overflow-x-hidden ${
              lockPageScroll ? "overflow-hidden" : ""
            }`}
          >
            <div
              className={`w-full ${maxW} mx-auto px-4 ${lockPageScroll ? "h-full" : ""}`}
            >
              {children}
            </div>
          </main>

          <div className="pb-[calc(5.25rem+var(--safe-bottom))] md:pb-0 mt-auto">
            <PP15Footer />
          </div>

          {supportOpen && supportAllowed ? (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-background/80 backdrop-blur p-3 sm:p-6">
              <div className="relative w-full max-w-[920px] bg-background shadow-lg rounded-2xl">
                <div className="sr-only" aria-hidden="false">
                  <div>Support</div>
                  <div>Live support chat</div>
                </div>

                <div
                  key={supportInstanceKey}
                  className={SUPPORT_WIDGET_CLASS}
                  data-elfsight-app-lazy
                />

                <button
                  aria-label="Close"
                  className="absolute left-1/4 -top-4 -translate-x-1/2 z-50 rounded-full bg-background border border-border shadow-md p-2.5 text-foreground hover:bg-accent"
                  onClick={() => setSupportOpen(false)}
                >
                  <X className="h-6 w-6" />
                </button>
              </div>
            </div>
          ) : null}

          {/* Mobile bottom nav */}
          <div className="fixed bottom-0 left-0 right-0 md:hidden border-t bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/80 z-30 safe-bottom">
            <nav className="mx-auto max-w-[640px] px-1 py-1 grid grid-cols-5 gap-1">
              {navItems.map((it) => (
                <NavLink
                  key={it.to}
                  to={it.to}
                  data-tour={
                    it.to === "/"
                      ? "nav-market"
                      : it.to === "/map"
                        ? "nav-map"
                        : it.to === "/islands"
                          ? "nav-islands"
                          : it.to === "/secondary"
                            ? "nav-secondary"
                            : it.to === "/portfolio"
                              ? "nav-wallet"
                              : undefined
                  }
                  className={({ isActive }) =>
                    `flex flex-col items-center justify-center rounded-md py-2 text-xs ${
                      isActive
                        ? "pp15-burger-active bg-accent"
                        : "text-foreground/80"
                    }`
                  }
                >
                  {it.icon}
                  <span className="mt-1">{it.label}</span>
                </NavLink>
              ))}
            </nav>
          </div>
        </div>
      </div>
    </div>
  );
}

type ReportArea =
  | "BUG"
  | "MARKET"
  | "MAP"
  | "ISLANDS"
  | "SECOND_MARKET"
  | "WALLET";

function _inferReportAreaFromPath(pathname: string): ReportArea {
  const p = (pathname ?? "").toLowerCase();
  if (p === "/" || p.startsWith("/market")) return "MARKET";
  if (p.startsWith("/map")) return "MAP";
  if (p.startsWith("/islands")) return "ISLANDS";
  if (p.startsWith("/secondary")) return "SECOND_MARKET";
  if (p.startsWith("/portfolio") || p.startsWith("/wallet")) return "WALLET";
  return "BUG";
}

function ReportDialog({
  open,
  onOpenChange,
}: {
  open: boolean;
  onOpenChange: (v: boolean) => void;
}) {
  const isGuest = useIsGuest();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const { data: profile } = useQuery<GetProfileOutput>(["profile"], () =>
    apiClient.getProfile(),
  );

  const isAdmin = !!profile?.isAdmin;

  const [area, setArea] = useState<ReportArea>("BUG");
  const [commonIssues, setCommonIssues] = useState<string[]>([]);
  const [title, setTitle] = useState<string>("");
  const [details, setDetails] = useState<string>("");
  const [anonymous, setAnonymous] = useState<boolean>(true);
  const [inboxEmailDraft, setInboxEmailDraft] = useState<string>("");

  useEffect(() => {
    if (!open) return;
    try {
      setArea(_inferReportAreaFromPath(window.location.pathname));
    } catch {
      setArea("BUG");
    }
    setCommonIssues([]);
    setTitle("");
    setDetails("");
    setAnonymous(true);
    setInboxEmailDraft(profile?.reportInboxEmail ?? "");
  }, [open]);

  useEffect(() => {
    if (!open) return;
    setInboxEmailDraft(profile?.reportInboxEmail ?? "");
  }, [open, profile?.reportInboxEmail]);

  const setInboxMutation = useMutation(apiClient.setReportInboxEmail, {
    onSuccess: async () => {
      await queryClient.invalidateQueries(["profile"]);
      toast({
        title: "Inbox updated",
        description: "Reports will be sent to the new address.",
      });
    },
    onError: (error: unknown) => {
      toast({
        title: "Couldn't update inbox",
        description:
          error instanceof Error ? error.message : "Please try again.",
      });
    },
  });

  const canSubmit = title.trim().length >= 3 && details.trim().length >= 5;

  const areaLabel: Record<ReportArea, string> = {
    BUG: "Bug",
    MARKET: "Market",
    MAP: "Map",
    ISLANDS: "Islands",
    SECOND_MARKET: "2nd Market",
    WALLET: "Wallet",
  };

  const areaIcon: Record<ReportArea, React.ReactNode> = {
    BUG: <Flag className="h-3.5 w-3.5 text-muted-foreground" />,
    MARKET: <TrendingUp className="h-3.5 w-3.5 text-muted-foreground" />,
    MAP: <MapIcon className="h-3.5 w-3.5 text-muted-foreground" />,
    ISLANDS: <Building2 className="h-3.5 w-3.5 text-muted-foreground" />,
    SECOND_MARKET: (
      <ArrowLeftRight className="h-3.5 w-3.5 text-muted-foreground" />
    ),
    WALLET: <Wallet2 className="h-3.5 w-3.5 text-muted-foreground" />,
  };

  const commonIssueGroups: Array<{
    title: string;
    overview: string;
    icon: React.ReactNode;
    options: Array<{ key: string; label: string }>;
  }> = [
    {
      title: "Performance",
      overview: "Slow app, freezing, crashes, or lag.",
      icon: <Zap className="h-3 w-3 text-muted-foreground" />,
      options: [
        { key: "SLOW", label: "App is slow / freezing" },
        { key: "CRASH", label: "App crashes / closes" },
        { key: "TAPS", label: "Buttons / taps don't respond" },
      ],
    },
    {
      title: "Login & Session",
      overview: "Sign-in, session, or account access issues.",
      icon: <LogIn className="h-3 w-3 text-muted-foreground" />,
      options: [
        { key: "LOGIN", label: "Sign-in / session issues" },
        { key: "OTP", label: "Can't receive login code" },
        { key: "SESSION_DROP", label: "Session ends unexpectedly" },
      ],
    },
    {
      title: "Trading & Wallet",
      overview: "Buying/selling problems and balance confusion.",
      icon: <Wallet2 className="h-3 w-3 text-muted-foreground" />,
      options: [
        { key: "BUY_SELL", label: "Can't buy or sell" },
        { key: "BALANCE", label: "Wallet balance looks wrong" },
        { key: "ORDER", label: "Order stuck / pending" },
        { key: "FEES", label: "Fees or totals look wrong" },
      ],
    },
    {
      title: "Map & Islands",
      overview: "Map loading and island view issues.",
      icon: <MapIcon className="h-3 w-3 text-muted-foreground" />,
      options: [
        { key: "MAP", label: "Map not loading" },
        { key: "ISLAND_VIEW", label: "Island view not loading" },
        { key: "PLOTS", label: "My plots look missing" },
      ],
    },
    {
      title: "Images",
      overview: "Images missing or failing to load.",
      icon: <ImageIcon className="h-3 w-3 text-muted-foreground" />,
      options: [
        { key: "IMAGES", label: "Images not loading" },
        { key: "BROKEN_IMG", label: "Broken / wrong image" },
      ],
    },
  ];

  const reportInboxEmail = profile?.reportInboxEmail ?? "";
  const inboxIsDirty = inboxEmailDraft.trim() !== reportInboxEmail;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="w-[calc(100vw-16px)] max-w-[520px] p-2 sm:p-5 max-h-[85vh] overflow-y-auto">
        {" "}
        <DialogHeader>
          <DialogTitle>Report an issue</DialogTitle>
          <DialogDescription>
            Tell us what went wrong. You can submit anonymously.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-3">
          {" "}
          <div className="grid gap-2">
            <div className="flex items-center justify-between gap-2">
              <Label>Common issue suggestions (optional)</Label>
              {commonIssues.length > 0 && (
                <div className="text-xs text-muted-foreground">
                  Tap an “X” to remove
                </div>
              )}
            </div>

            <div className="grid gap-1.5">
              {commonIssueGroups.map((group) => (
                <div
                  key={group.title}
                  className="rounded-md border bg-card p-1.5"
                >
                  <div className="flex items-center gap-1">
                    <div className="shrink-0">{group.icon}</div>
                    <div className="text-[12px] font-medium leading-tight">
                      {group.title}
                    </div>
                  </div>
                  <div className="hidden sm:block text-[11px] leading-tight text-muted-foreground">
                    {group.overview}
                  </div>

                  <div className="mt-1 grid grid-cols-2 gap-1">
                    {group.options.map((opt) => {
                      const checked = commonIssues.includes(opt.key);
                      return (
                        <Button
                          key={opt.key}
                          type="button"
                          size="sm"
                          variant={checked ? "secondary" : "outline"}
                          className="h-7 justify-between rounded-none px-1.5 text-[10px] pp-press-blue"
                          onClick={() => {
                            setCommonIssues((prev) =>
                              prev.includes(opt.key)
                                ? prev.filter((x) => x !== opt.key)
                                : [...prev, opt.key],
                            );
                          }}
                          aria-pressed={checked}
                        >
                          <span className="min-w-0 truncate">{opt.label}</span>
                          {checked && <X className="ml-1.5 h-2.5 w-2.5" />}
                        </Button>
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>
          </div>
          <div className="grid gap-2">
            <Label>Title</Label>
            <Input
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Short summary"
            />
          </div>
          <div className="grid gap-2">
            <Label>Page</Label>
            <div className="grid grid-cols-1 gap-1.5">
              {(
                [
                  "MARKET",
                  "MAP",
                  "ISLANDS",
                  "SECOND_MARKET",
                  "WALLET",
                  "BUG",
                ] as ReportArea[]
              ).map((k) => (
                <Button
                  key={k}
                  type="button"
                  size="sm"
                  variant={area === k ? "secondary" : "outline"}
                  className="h-9 justify-between rounded-none px-2.5 pp-press-blue"
                  onClick={() => setArea(k)}
                  aria-pressed={area === k}
                >
                  <span className="min-w-0 truncate flex items-center gap-2">
                    {areaIcon[k]}
                    <span className="text-sm">{areaLabel[k]}</span>
                  </span>
                  {area === k && <X className="ml-2 h-3.5 w-3.5" />}
                </Button>
              ))}
            </div>
          </div>
          <div className="grid gap-2">
            <Label>Details</Label>
            <Textarea
              value={details}
              onChange={(e) => setDetails(e.target.value)}
              placeholder="What happened? Steps to reproduce?"
              className="min-h-[88px] sm:min-h-[120px]"
            />
          </div>
          <div className="flex items-start justify-between gap-3 rounded-md border p-3">
            <div className="min-w-0">
              <div className="text-sm font-medium">Submit anonymously</div>
              <div className="text-xs text-muted-foreground">
                If enabled, we won’t include your profile name. (Guest users are
                always anonymous.)
              </div>
            </div>
            <Button
              type="button"
              size="sm"
              variant={
                isGuest ? "secondary" : anonymous ? "secondary" : "outline"
              }
              className="h-9 w-16 justify-center rounded-none px-2 pp-press-blue"
              onClick={() => {
                if (isGuest) {
                  try {
                    window.dispatchEvent(new Event("openSignIn"));
                  } catch {}
                  return;
                }
                setAnonymous((prev) => !prev);
              }}
              aria-pressed={isGuest ? true : anonymous}
              aria-label="Toggle anonymous"
            >
              {(isGuest ? true : anonymous) && <X className="h-3.5 w-3.5" />}
            </Button>
          </div>
          <div className="grid gap-2">
            <Label>Reports go to</Label>
            <div className="rounded-md border bg-card p-2.5">
              {" "}
              {!isAdmin ? (
                <div className="grid gap-1">
                  <div className="text-sm">
                    {reportInboxEmail.trim().length > 0
                      ? reportInboxEmail
                      : "Not set yet"}
                  </div>
                  <div className="text-xs text-muted-foreground">
                    This is where the team receives reports.
                  </div>
                </div>
              ) : (
                <div className="grid gap-2">
                  <Input
                    value={inboxEmailDraft}
                    onChange={(e) => setInboxEmailDraft(e.target.value)}
                    placeholder="support@yourdomain.com"
                  />
                  <div className="flex items-center justify-between gap-2">
                    <Button
                      type="button"
                      size="sm"
                      variant="outline"
                      className="pp-press-blue"
                      disabled={setInboxMutation.isLoading || !inboxIsDirty}
                      onClick={() => {
                        setInboxMutation.mutate({
                          email: inboxEmailDraft.trim(),
                        });
                      }}
                    >
                      {setInboxMutation.isLoading
                        ? "Saving…"
                        : "Save inbox email"}
                    </Button>
                    <div className="text-xs text-muted-foreground">
                      Admin only
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
          <div className="flex items-center justify-end gap-2">
            <Button
              variant="secondary"
              className="pp-press-blue"
              onClick={() => onOpenChange(false)}
              type="button"
            >
              Cancel
            </Button>
            <Button
              className="pp-press-blue"
              disabled={!canSubmit}
              onClick={() => {
                try {
                  const payload = {
                    title: title.trim(),
                    details: details.trim(),
                    page: areaLabel[area],
                    commonIssues,
                    anonymous: isGuest ? true : anonymous,
                    reportInboxEmail,
                    createdAt: new Date().toISOString(),
                  };
                  const key = "pp_reports_local_v1";
                  const prev = (() => {
                    try {
                      return JSON.parse(
                        localStorage.getItem(key) || "[]",
                      ) as any[];
                    } catch {
                      return [] as any[];
                    }
                  })();
                  prev.unshift(payload);
                  localStorage.setItem(key, JSON.stringify(prev.slice(0, 50)));
                } catch {}

                apiClient
                  .submitReport({
                    area: areaLabel[area],
                    title: title.trim(),
                    details: details.trim(),
                    commonIssues,
                    anonymous: isGuest ? true : anonymous,
                    pagePath: window.location.pathname,
                    pageUrl: window.location.href,
                    createdAt: new Date().toISOString(),
                  })
                  .then(() => {
                    toast({
                      title: "Report sent",
                      description: "Thanks — we’ll take a look.",
                    });
                    onOpenChange(false);
                  })
                  .catch((error: unknown) => {
                    toast({
                      title: "Couldn't send report",
                      description:
                        error instanceof Error
                          ? error.message
                          : "Please try again.",
                    });
                  });
              }}
              type="button"
            >
              Send report
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

type OnboardingOutput = inferRPCOutputType<"getOnboarding">;
type GetProfileOutput = inferRPCOutputType<"getProfile">;

export function OnboardingGate({ children }: { children: React.ReactNode }) {
  const sb = useSupabase();
  const accessToken = sb.accessToken ?? null;
  const isGuest = useIsGuest();

  const { data, isFetched } = useQuery<OnboardingOutput>(
    ["onboarding", accessToken ?? ""],
    () => apiClient.getOnboarding({ accessToken }),
    {
      retry: 1,
      enabled: sb.ready && !isGuest,
      refetchOnWindowFocus: false,
    },
  );

  const [displayName, setDisplayName] = useState("");
  const [profilePreview, setProfilePreview] = useState<string | null>(null);
  const [profileBase64, setProfileBase64] = useState<string | undefined>(
    undefined,
  );
  const [acceptTos, setAcceptTos] = useState(false);
  const [acceptPrivacy, setAcceptPrivacy] = useState(false);
  const [confirmAge18, setConfirmAge18] = useState(false);

  const { toast } = useToast();
  const queryClient = useQueryClient();

  const t = {
    title: "First-time setup",
    subtitle: "Please confirm Terms, Privacy and that you are 18+.",
    language: "Language",
    username: "Username",
    tosTitle: "Terms & Conditions (Summary)",
    tosText:
      "By using this game you agree to play fair, not circumvent security, and comply with applicable law. Digital values are virtual and may fluctuate. No refunds unless required by law.",
    tosLinkLabel: "Open full Terms of Use",
    tosUrl:
      "https://app.termly.io/policy-viewer/policy.html?policyUUID=6c3626db-00ce-4818-ace9-6f0ef0d06a1b",
    accept: "I accept the Terms & Conditions.",
    privacyTitle: "Privacy Policy (Summary)",
    privacyText:
      "We store your account identifier, username, and any profile image you upload. We also store wallet and transaction history to operate the app. We don't sell your personal data.",
    privacyLinkLabel: "Open full Privacy Policy",
    privacyUrl:
      "https://app.termly.io/policy-viewer/policy.html?policyUUID=1de0de06-4aec-4dd6-9570-b667cbaed718",
    privacyAccept: "I accept the Privacy Policy.",
    ageTitle: "Age confirmation",
    ageText: "I confirm that I am at least 18 years old.",
    start: "Start",
    payoutTitle: "Payout profile",
    payoutSubtitle: "Set up a method to receive payouts (manual review).",
    method: "Method",
    paypal: "PayPal",
    iban: "IBAN",
    paypalEmailLabel: "PayPal email",
    ibanLabel: "IBAN",
    accountHolder: "Account holder (optional)",
    countryLabel: "Country (optional)",
    payoutTosLabel:
      "I accept the payout terms (manual review, no automatic transfer).",
    savePayout: "Save payout profile",
    payoutHelp:
      "We only store details needed for payouts. Card numbers are not collected during onboarding.",
    sectionDone: "Done",
  };

  useEffect(() => {
    if (typeof data?.displayName === "string") setDisplayName(data.displayName);
    if (data?.profileImageUrl) setProfilePreview(data.profileImageUrl);
    // Prefill from first sign-up step if available
    if (data?.needsOnboarding && !data?.displayName) {
      try {
        const pending = localStorage.getItem("pendingDisplayName");
        if (pending && !displayName) setDisplayName(pending);
      } catch {}
    }
  }, [data?.displayName, data?.profileImageUrl, data?.needsOnboarding]);

  const complete = useMutation(apiClient.completeOnboarding, {
    onSuccess: async () => {
      await queryClient.invalidateQueries(["onboarding"]);
      toast({
        title: "Welcome!",
      });
    },
    onError: (e: any) =>
      toast({
        title: "Onboarding failed",
        description: e?.message ?? "Unknown error",
      }),
  });

  // Payout setup removed from first-time onboarding per new flow

  // Guest users should not be blocked by onboarding checks.
  if (isGuest) return <>{children}</>;

  // Optimistic: do not block first paint for returning users.
  // Only show the onboarding gate once the server has told us it's required.
  if (!isFetched) return <>{children}</>;

  if (data?.needsOnboarding) {
    return (
      <div className="min-h-screen bg-background text-foreground flex flex-col">
        <div className="p-6">
          <div className="mx-auto w-full max-w-md">
            <h2 className="text-xl font-semibold mb-2">{t.title}</h2>
            <p className="text-sm text-muted-foreground mb-4">{t.subtitle}</p>

            <Card className="mb-4">
              <CardHeader className="pb-2">
                <CardTitle className="text-base">{t.language}</CardTitle>
              </CardHeader>
              <CardContent className="grid gap-3">
                <div className="text-sm font-medium">{t.language}</div>
                <div className="text-xs text-muted-foreground">
                  English only
                </div>
                <div className="grid gap-2">
                  <Label>Username</Label>{" "}
                  <Input
                    value={displayName}
                    onChange={(e) => setDisplayName(e.target.value)}
                    placeholder="e.g. Alex (must be unique)"
                  />
                  <div className="text-xs text-muted-foreground">
                    Please choose a name that is not already taken.
                  </div>
                </div>

                <div className="mt-2 p-3 border rounded">
                  <div className="text-sm font-medium mb-1">{t.tosTitle}</div>
                  <div className="text-xs text-muted-foreground mb-2">
                    {t.tosText}
                  </div>
                  <div className="flex items-center gap-2">
                    <input
                      id="acceptTos"
                      type="checkbox"
                      className="h-4 w-4"
                      checked={acceptTos}
                      onChange={(e) => setAcceptTos(e.target.checked)}
                    />
                    <Label htmlFor="acceptTos" className="text-sm">
                      {t.accept}
                    </Label>
                  </div>
                  <a
                    href={t.tosUrl}
                    target="_blank"
                    rel="noreferrer"
                    className="mt-2 inline-block text-xs underline text-muted-foreground"
                  >
                    {t.tosLinkLabel}
                  </a>
                  <div className="mt-4 text-sm font-medium mb-1">
                    {t.privacyTitle}
                  </div>{" "}
                  <div className="text-xs text-muted-foreground mb-2">
                    {t.privacyText}
                  </div>
                  <div className="flex items-center gap-2">
                    <input
                      id="acceptPrivacy"
                      type="checkbox"
                      className="h-4 w-4"
                      checked={acceptPrivacy}
                      onChange={(e) => setAcceptPrivacy(e.target.checked)}
                    />
                    <Label htmlFor="acceptPrivacy" className="text-sm">
                      {t.privacyAccept}
                    </Label>
                  </div>
                  <a
                    href={t.privacyUrl}
                    target="_blank"
                    rel="noreferrer"
                    className="mt-2 inline-block text-xs underline text-muted-foreground"
                  >
                    {t.privacyLinkLabel}
                  </a>
                  <div className="mt-4 text-sm font-medium mb-1">
                    {t.ageTitle}
                  </div>{" "}
                  <div className="text-xs text-muted-foreground mb-2">
                    {t.ageText}
                  </div>
                  <div className="flex items-center gap-2">
                    <input
                      id="confirmAge18"
                      type="checkbox"
                      className="h-4 w-4"
                      checked={confirmAge18}
                      onChange={(e) => setConfirmAge18(e.target.checked)}
                    />
                    <Label htmlFor="confirmAge18" className="text-sm">
                      {t.ageText}
                    </Label>
                  </div>
                  <div className="mt-3 text-xs text-muted-foreground">
                    Password note: use a strong password. We recommend at least
                    12 characters, including symbols.
                  </div>
                </div>
                <div className="grid gap-2">
                  <Label>Profile picture</Label>
                  <div className="flex items-center gap-3">
                    <Avatar>
                      <AvatarImage src={profilePreview ?? undefined} />
                      <AvatarFallback
                        className="text-transparent"
                        style={_avatarGradientStyle(displayName || "user")}
                      >
                        <span className="sr-only">Profile</span>
                      </AvatarFallback>
                    </Avatar>
                    <Input
                      type="file"
                      accept="image/*"
                      onChange={async (e) => {
                        const f = e.target.files?.[0];
                        if (!f) return;
                        const base64 = await encodeFileAsBase64DataURL(f);
                        if (base64) {
                          setProfileBase64(base64);
                          setProfilePreview(URL.createObjectURL(f));
                        }
                      }}
                    />
                  </div>
                </div>

                <Button
                  className="w-full mt-4"
                  disabled={
                    !displayName ||
                    !acceptTos ||
                    !acceptPrivacy ||
                    !confirmAge18 ||
                    complete.isLoading
                  }
                  onClick={async () => {
                    try {
                      await (complete as any).mutateAsync({
                        accessToken,
                        displayName,
                        profileImageBase64: profileBase64,
                        acceptTos,
                        acceptPrivacy,
                        confirmAge18,
                      });
                    } catch {
                      // Feedback via toast handled in mutation
                    }
                  }}
                >
                  {complete.isLoading ? "Saving..." : t.start}
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>

        <div className="mt-auto w-full">
          <PP15Footer />
        </div>
      </div>
    );
  }

  return <>{children}</>;
}

function AuthGate({ children }: { children: React.ReactNode }) {
  // Lightweight health check in the background.
  // IMPORTANT: We never block the app UI with a full-screen “server unreachable” state.
  useQuery<ServerStatusOutput>(
    ["server-status"],
    () => apiClient.getServerStatus(),
    {
      staleTime: 10_000,
      cacheTime: 60_000,
      retry: 2,
      retryDelay: 1500,
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
    },
  );

  // Gastmodus: ohne Login darf man alles ansehen.
  // Aktionen (kaufen/verkaufen/top-up/bauen) sind an den Stellen gesperrt, wo sie ausgelöst werden.
  return <>{children}</>;
}

function MarketStylePPCChart({
  currentPrice,
  range,
  onRangeChange,
  onTimePickerOpenChange,
  queryKeyBase,
  fetchHistory,
}: {
  currentPrice: number;
  range: "1H" | "5H" | "1W" | "1MO" | "MAX";
  onRangeChange: (r: "1H" | "5H" | "1W" | "1MO" | "MAX") => void;
  onTimePickerOpenChange?: (open: boolean) => void;
  queryKeyBase: any[];
  fetchHistory: (input: {
    minutes: number;
  }) => Promise<Array<{ t: any; price: number }>>;
}) {
  type RangeKey = "1H" | "5H" | "1W" | "1MO" | "MAX";

  const navigate = useNavigate();

  const ranges: { key: RangeKey; label: string; minutes: number }[] = [
    { key: "1H", label: "24hr", minutes: 60 * 24 },
    { key: "5H", label: "Weekly", minutes: 60 * 24 * 7 },
    { key: "1W", label: "Monthly", minutes: 60 * 24 * 30 },
    { key: "1MO", label: "Yearly", minutes: 60 * 24 * 365 },
    // "Max" means: as far back as we have data
    { key: "MAX", label: "Max", minutes: 60 * 24 * 365 * 20 },
  ];

  const minutesForRange = (r: RangeKey) =>
    ranges.find((x) => x.key === r)?.minutes ?? 60 * 24 * 7;

  const refetchMsForRange = (r: RangeKey) => {
    // The chart doesn't need to refetch very aggressively; lower frequency improves stability.
    switch (r) {
      case "1H":
        return 15000;
      case "5H":
        return 15000;
      case "1W":
        return 30000;
      case "1MO":
        return 60000;
      case "MAX":
        return 90000;
      default:
        return 30000;
    }
  };
  // Keep a larger internal drawing coordinate system so the line stays crisp and detailed
  const width = 800;
  const height = 260;

  const [liveMode, setLiveMode] = useState(false);
  const [rangePickerOpen, setRangePickerOpen] = useState(false);

  type LivePattern = {
    name: string;
    segs: Array<{ dur: number; from: number; to: number }>;
    total: number;
    linearWeight: number;
    microPeriod: number;
    microAmp: number;
    windowScale: number;
  };

  const livePatterns: LivePattern[] = useMemo(() => {
    const mk = (
      name: string,
      segs: Array<{ dur: number; from: number; to: number }>,
      opt: {
        linearWeight: number;
        microPeriod: number;
        microAmp: number;
        windowScale: number;
      },
    ): LivePattern => ({
      name,
      segs,
      total: segs.reduce((a, s) => a + s.dur, 0),
      linearWeight: opt.linearWeight,
      microPeriod: opt.microPeriod,
      microAmp: opt.microAmp,
      windowScale: opt.windowScale,
    });

    const mulberry32 = (seed: number) => {
      let a = seed >>> 0;
      return () => {
        a |= 0;
        a = (a + 0x6d2b79f5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    };

    const clamp = (v: number, a: number, b: number) =>
      Math.max(a, Math.min(b, v));

    const templates: Array<{
      name: string;
      segs: Array<{ dur: number; from: number; to: number }>;
    }> = [
      {
        name: "Surge",
        segs: [
          { dur: 1100, from: 0.0, to: 1.0 },
          { dur: 240, from: 1.0, to: 1.0 },
          { dur: 900, from: 1.0, to: -1.0 },
          { dur: 240, from: -1.0, to: -1.0 },
          { dur: 1100, from: -1.0, to: 0.45 },
          { dur: 240, from: 0.45, to: 0.45 },
          { dur: 900, from: 0.45, to: 0.0 },
          { dur: 240, from: 0.0, to: 0.0 },
        ],
      },
      {
        name: "Chop",
        segs: [
          { dur: 760, from: 0.0, to: 1.0 },
          { dur: 210, from: 1.0, to: 1.0 },
          { dur: 760, from: 1.0, to: -1.0 },
          { dur: 210, from: -1.0, to: -1.0 },
          { dur: 520, from: -1.0, to: 0.15 },
          { dur: 220, from: 0.15, to: 0.15 },
          { dur: 600, from: 0.15, to: 0.0 },
          { dur: 220, from: 0.0, to: 0.0 },
        ],
      },
      {
        name: "Pulse",
        segs: [
          { dur: 900, from: 0.0, to: 0.9 },
          { dur: 260, from: 0.9, to: 0.9 },
          { dur: 900, from: 0.9, to: -0.7 },
          { dur: 260, from: -0.7, to: -0.7 },
          { dur: 720, from: -0.7, to: 0.7 },
          { dur: 260, from: 0.7, to: 0.7 },
          { dur: 720, from: 0.7, to: 0.0 },
          { dur: 260, from: 0.0, to: 0.0 },
        ],
      },
      {
        name: "Wave",
        segs: [
          { dur: 1400, from: 0.0, to: 1.0 },
          { dur: 220, from: 1.0, to: 1.0 },
          { dur: 1400, from: 1.0, to: -1.0 },
          { dur: 220, from: -1.0, to: -1.0 },
          { dur: 1400, from: -1.0, to: 0.0 },
          { dur: 260, from: 0.0, to: 0.0 },
        ],
      },
      {
        name: "Stair",
        segs: [
          { dur: 520, from: 0.0, to: 0.55 },
          { dur: 220, from: 0.55, to: 0.55 },
          { dur: 520, from: 0.55, to: 1.0 },
          { dur: 240, from: 1.0, to: 1.0 },
          { dur: 680, from: 1.0, to: -0.9 },
          { dur: 240, from: -0.9, to: -0.9 },
          { dur: 780, from: -0.9, to: 0.0 },
          { dur: 240, from: 0.0, to: 0.0 },
        ],
      },
      {
        name: "Kick",
        segs: [
          { dur: 680, from: 0.0, to: 1.0 },
          { dur: 260, from: 1.0, to: 0.25 },
          { dur: 260, from: 0.25, to: 0.25 },
          { dur: 760, from: 0.25, to: -1.0 },
          { dur: 240, from: -1.0, to: -1.0 },
          { dur: 900, from: -1.0, to: 0.15 },
          { dur: 240, from: 0.15, to: 0.15 },
          { dur: 900, from: 0.15, to: 0.0 },
        ],
      },
      {
        name: "Wobble",
        segs: [
          { dur: 820, from: 0.0, to: 0.85 },
          { dur: 240, from: 0.85, to: 0.85 },
          { dur: 780, from: 0.85, to: -0.55 },
          { dur: 220, from: -0.55, to: -0.55 },
          { dur: 760, from: -0.55, to: 0.35 },
          { dur: 240, from: 0.35, to: 0.35 },
          { dur: 820, from: 0.35, to: 0.0 },
          { dur: 260, from: 0.0, to: 0.0 },
        ],
      },
      {
        name: "Deep",
        segs: [
          { dur: 980, from: 0.0, to: 1.0 },
          { dur: 280, from: 1.0, to: 1.0 },
          { dur: 1180, from: 1.0, to: -1.25 },
          { dur: 260, from: -1.25, to: -1.25 },
          { dur: 980, from: -1.25, to: 0.55 },
          { dur: 260, from: 0.55, to: 0.55 },
          { dur: 820, from: 0.55, to: 0.0 },
          { dur: 280, from: 0.0, to: 0.0 },
        ],
      },
    ];

    const PATTERN_COUNT = 80;
    const out: LivePattern[] = [];

    for (let i = 0; i < PATTERN_COUNT; i++) {
      const rnd = mulberry32(1337 + i * 101);
      const template = templates[i % templates.length]!;

      const amp = 0.75 + rnd() * 0.85; // 0.75..1.60
      const durJitter = 0.78 + rnd() * 0.52; // 0.78..1.30
      const skew = (rnd() - 0.5) * 0.1; // -0.05..0.05

      const segs = template.segs.map((s, idx) => {
        const local = mulberry32(9001 + i * 31 + idx * 97);
        const d = Math.round(s.dur * durJitter * (0.92 + local() * 0.22));
        const from = clamp((s.from + skew) * amp, -1.35, 1.35);
        const to = clamp((s.to + skew) * amp, -1.35, 1.35);
        return { dur: Math.max(120, d), from, to };
      });

      const linearWeight = clamp(0.58 + rnd() * 0.38, 0.55, 0.96);
      const microPeriod = Math.round(520 + rnd() * 900); // 520..1420
      const microAmp = clamp(0.06 + rnd() * 0.18, 0.05, 0.22);
      const windowScale = clamp(0.85 + rnd() * 0.55, 0.8, 1.35);

      out.push(
        mk(`${template.name} ${i + 1}`, segs, {
          linearWeight,
          microPeriod,
          microAmp,
          windowScale,
        }),
      );
    }

    return out;
  }, []);

  const [livePatternIndex, setLivePatternIndex] = useState(0);
  const livePatternIndexRef = useRef(0);
  const livePatternPhaseStartPerfRef = useRef<number>(performance.now());

  const pickNextPattern = (current: number) => {
    const n = Math.max(1, livePatterns.length);
    if (n <= 1) return 0;
    const jump = 1 + Math.floor(Math.random() * (n - 1));
    return (current + jump) % n;
  };

  useEffect(() => {
    livePatternIndexRef.current = livePatternIndex;
  }, [livePatternIndex]);

  const LIVE_SCROLL_MS = 6000;

  const liveTargetPriceRef = useRef(0);
  const [liveFollowPrice, setLiveFollowPrice] = useState<number>(0);
  const liveSamplesRef = useRef<Array<{ t: number; price: number }>>([]);

  const [liveRafNow, setLiveRafNow] = useState<number>(0);

  useEffect(() => {
    if (!liveMode) return;

    const seedNow = Date.now();
    const seedBase = liveTargetPriceRef.current;
    const seedCount = 140;
    liveSamplesRef.current = new Array(seedCount).fill(0).map((_, i) => {
      const age =
        ((seedCount - 1 - i) / Math.max(1, seedCount - 1)) * LIVE_SCROLL_MS;
      return { t: seedNow - age, price: seedBase };
    });

    setLiveFollowPrice(seedBase);
    setLiveRafNow(seedNow);

    livePatternPhaseStartPerfRef.current = performance.now();

    let rafId = 0;
    let lastNow = seedNow;

    const smoothstep = (x: number) => {
      const tt = Math.max(0, Math.min(1, x));
      return tt * tt * (3 - 2 * tt);
    };

    let lastUiTick = seedNow;
    const loop = () => {
      const perfNow = performance.now();
      const tMs = perfNow - livePatternPhaseStartPerfRef.current;
      const now = Date.now();
      const dt = Math.max(1, now - lastNow);
      lastNow = now;

      const target = liveTargetPriceRef.current;
      setLiveFollowPrice((prev) => {
        if (!Number.isFinite(target)) return prev;
        if (!Number.isFinite(prev) || prev === 0) return target;
        const alpha = 1 - Math.exp(-dt / 260);
        return prev + (target - prev) * alpha;
      });

      const pat = livePatterns[livePatternIndexRef.current] ?? livePatterns[0];
      const total = pat?.total || 1;
      const segs = pat?.segs ?? [];
      const linearW = Math.max(0, Math.min(1, pat?.linearWeight ?? 0.8));
      const easeW = 1 - linearW;

      const tLoop = ((tMs % total) + total) % total;
      let acc = 0;
      let norm = 0;
      for (const seg of segs) {
        if (tLoop <= acc + seg.dur) {
          if (seg.from === seg.to) {
            norm = seg.from;
          } else {
            const p = (tLoop - acc) / Math.max(1, seg.dur);
            const ramp = p * linearW + smoothstep(p) * easeW;
            norm = seg.from + (seg.to - seg.from) * ramp;
          }
          break;
        }
        acc += seg.dur;
      }

      const microPeriod = pat?.microPeriod ?? 850;
      const microAmp = pat?.microAmp ?? 0.12;
      const micro =
        Math.sin((2 * Math.PI * (tMs % microPeriod)) / microPeriod) * microAmp;
      const combined = norm + micro;

      const baseForWindow = Number.isFinite(target) ? target : seedBase;
      const fallback = Math.max(0.08, Math.abs(baseForWindow) * 0.00012);
      const maxCap = Math.max(0.25, Math.abs(baseForWindow) * 0.00025);
      const desired = fallback * (pat?.windowScale ?? 1.0) * 1.5;
      const liveWindow = Math.min(maxCap, Math.max(fallback, desired));
      const osc = combined * liveWindow * 0.5;

      const nextPrice =
        (Number.isFinite(liveTargetPriceRef.current)
          ? liveTargetPriceRef.current
          : seedBase) + osc;

      const arr = liveSamplesRef.current;
      arr.push({ t: now, price: nextPrice });
      const cutoff = now - LIVE_SCROLL_MS * 2;
      while (arr.length && arr[0]!.t < cutoff) arr.shift();

      if (now - lastUiTick >= 50) {
        lastUiTick = now;
        setLiveRafNow(now);
      }

      rafId = requestAnimationFrame(loop);
    };

    rafId = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(rafId);
  }, [liveMode, LIVE_SCROLL_MS, livePatterns]);

  const minutesForQuery = liveMode ? 30 : minutesForRange(range);
  // Keep LIVE lightweight; realtime events already reflect trades.
  const refetchMs = liveMode ? 6000 : refetchMsForRange(range);

  const { data: history } = useQuery<Array<{ t: any; price: number }>>(
    [...queryKeyBase, liveMode ? "LIVE" : range],
    () => fetchHistory({ minutes: minutesForQuery }),
    {
      refetchInterval: rangePickerOpen ? false : refetchMs,
      staleTime: rangePickerOpen ? 60000 : refetchMs,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      retry: 0,
      refetchIntervalInBackground: false,
    },
  );

  const [historyCache, setHistoryCache] = useState<Array<{
    t: any;
    price: number;
  }> | null>(null);
  useEffect(() => {
    const arr = (history ?? []) as any[];
    if (Array.isArray(arr) && arr.length) setHistoryCache(history ?? null);
  }, [history]);

  const effectiveHistory = useMemo(() => {
    return liveMode
      ? (history ?? [])
      : (((((history ?? []) as any[]).length ? history : historyCache) ??
          history ??
          []) as any);
  }, [liveMode, history, historyCache]);

  const rawSeries = useMemo(() => {
    const arr = (effectiveHistory ?? []) as any[];
    return arr.filter((d) => typeof d?.price === "number" && d?.t) as Array<{
      t: any;
      price: number;
    }>;
  }, [effectiveHistory]);

  const targetPoints =
    range === "1H"
      ? 420
      : range === "5H"
        ? 620
        : range === "1W"
          ? 520
          : range === "1MO"
            ? 680
            : 760;

  const resampledSeries = useMemo(() => {
    if (rawSeries.length <= 1) return rawSeries;
    const firstT = +new Date(rawSeries[0]!.t);
    const lastT = +new Date(rawSeries[rawSeries.length - 1]!.t);
    if (
      !Number.isFinite(firstT) ||
      !Number.isFinite(lastT) ||
      lastT <= firstT
    ) {
      return rawSeries;
    }

    const out: Array<{ t: number; price: number }> = [];
    let j = 0;
    for (let i = 0; i < targetPoints; i++) {
      const tt = firstT + ((lastT - firstT) * i) / (targetPoints - 1);
      while (j < rawSeries.length - 2 && +new Date(rawSeries[j + 1]!.t) < tt) {
        j++;
      }
      const a = rawSeries[j]!;
      const b = rawSeries[j + 1] ?? a;
      const ta = +new Date(a.t);
      const tb = +new Date(b.t);
      const denom = Math.max(1, tb - ta);
      const w0 = Math.min(1, Math.max(0, (tt - ta) / denom));
      const eased = (() => {
        const smootherstep = (x: number) => x * x * x * (x * (x * 6 - 15) + 10);
        const smoothstep = (x: number) => x * x * (3 - 2 * x);

        if (range === "5H" || range === "1W") return smootherstep(w0);
        if (range === "1H") return smoothstep(w0) * 0.65 + w0 * 0.35;
        return smoothstep(w0);
      })();
      const price = a.price + (b.price - a.price) * eased;
      out.push({ t: tt, price });
    }
    return out;
  }, [rawSeries, targetPoints, range]);

  const prices = useMemo(
    () => resampledSeries.map((d) => d.price),
    [resampledSeries],
  );

  const gaussianSmooth = (arr: number[], radius: number, sigma: number) => {
    if (arr.length < 3) return arr;
    const r = Math.max(1, Math.min(24, Math.floor(radius)));
    const s = Math.max(0.2, sigma);
    const kernel: number[] = [];
    let sum = 0;
    for (let i = -r; i <= r; i++) {
      const w = Math.exp(-(i * i) / (2 * s * s));
      kernel.push(w);
      sum += w;
    }
    const norm = sum || 1;

    const out: number[] = new Array(arr.length);
    for (let i = 0; i < arr.length; i++) {
      let acc = 0;
      for (let k = -r; k <= r; k++) {
        const idx = Math.max(0, Math.min(arr.length - 1, i + k));
        acc += arr[idx]! * (kernel[k + r]! / norm);
      }
      out[i] = acc;
    }
    return out;
  };

  const smoothing = (() => {
    if (range === "5H") return { radius: 7, sigma: 3.2 };
    if (range === "1W") return { radius: 8, sigma: 3.6 };
    if (range === "1H") return { radius: 4, sigma: 2.0 };
    if (range === "1MO") return { radius: 3, sigma: 1.6 };
    return { radius: 2, sigma: 1.2 };
  })();

  const smoothedPrices = useMemo(
    () => gaussianSmooth(prices, smoothing.radius, smoothing.sigma),
    [prices, smoothing.radius, smoothing.sigma],
  );

  const n = Math.max(2, prices.length || 2);

  const minMaxOf = (arr: number[]) => {
    let mn = Number.POSITIVE_INFINITY;
    let mx = Number.NEGATIVE_INFINITY;
    for (const v of arr) {
      if (!Number.isFinite(v)) continue;
      if (v < mn) mn = v;
      if (v > mx) mx = v;
    }
    if (!Number.isFinite(mn) || !Number.isFinite(mx)) return { mn: 0, mx: 1 };
    return { mn, mx };
  };

  const { mn: pminA, mx: pmaxA } = prices.length
    ? minMaxOf(prices)
    : {
        mn: currentPrice ?? 0,
        mx: (currentPrice ?? 0) + 1,
      };

  const { mn: pminB, mx: pmaxB } = prices.length
    ? minMaxOf(smoothedPrices)
    : { mn: pminA, mx: pmaxA };

  const pminRaw = prices.length ? Math.min(pminA, pminB) : pminA;
  const pmaxRaw = prices.length ? Math.max(pmaxA, pmaxB) : pmaxA;

  let span = pmaxRaw - pminRaw;
  if (!Number.isFinite(span) || span <= 0) {
    span = Math.max(1, Math.abs(pmaxRaw) * 0.02);
  }

  const pCenterBase = prices.length
    ? prices[prices.length - 1]!
    : (currentPrice ?? 0);

  liveTargetPriceRef.current = pCenterBase;

  const liveWindow = (() => {
    if (!liveMode) return null;

    const center =
      Number.isFinite(liveFollowPrice) && liveFollowPrice !== 0
        ? liveFollowPrice
        : pCenterBase;

    const fallback = Math.max(0.08, Math.abs(center) * 0.00012);
    const maxCap = Math.max(0.25, Math.abs(center) * 0.00025);

    const desired = fallback * 1.35;
    return Math.min(maxCap, Math.max(fallback, desired));
  })();

  const pCenter = liveMode
    ? Number.isFinite(liveFollowPrice) && liveFollowPrice !== 0
      ? liveFollowPrice
      : pCenterBase
    : pCenterBase;

  const pad = liveMode ? 0 : span * 0.45;
  const pmin = liveMode
    ? pCenter - (liveWindow ?? Math.max(1, span))
    : pminRaw - pad;
  const pmax = liveMode
    ? pCenter + (liveWindow ?? Math.max(1, span))
    : pmaxRaw + pad;

  const leftMargin = 34;
  const rightMargin = 34;
  const drawWidth = width - leftMargin - rightMargin;
  const padTop = 14;
  const padBottom = 48;
  const usable = Math.max(1, height - padTop - padBottom);

  const normalize = (p: number) => (p - pmin) / Math.max(1e-9, pmax - pmin);
  const toY = (p: number) => padTop + usable * (1 - normalize(p));

  const seriesT0 = resampledSeries[0]?.t
    ? +new Date(resampledSeries[0]!.t as any)
    : 0;
  const seriesT1 = resampledSeries[resampledSeries.length - 1]?.t
    ? +new Date(resampledSeries[resampledSeries.length - 1]!.t as any)
    : 1;
  const toX = (tt: any, i: number) => {
    const t = +new Date(tt);
    if (
      !Number.isFinite(t) ||
      !Number.isFinite(seriesT0) ||
      !Number.isFinite(seriesT1)
    ) {
      return leftMargin + (drawWidth * i) / Math.max(1, n - 1);
    }
    const denom = Math.max(1, seriesT1 - seriesT0);
    return leftMargin + (drawWidth * (t - seriesT0)) / denom;
  };

  const isFlat =
    prices.length >= 2
      ? Math.abs(pmaxRaw - pminRaw) < 1e-6
      : prices.length === 1;
  const baseY = Math.round(padTop + usable * 0.62);

  const points: Array<[number, number]> = (() => {
    const clampY = (yy: number) =>
      Math.max(padTop, Math.min(height - padBottom, yy));

    const seriesOk = (resampledSeries ?? []).length >= 2;

    if (liveMode) {
      const now = liveRafNow || Date.now();
      const samplesAll = (liveSamplesRef.current ?? []).filter(
        (s) => now - s.t <= LIVE_SCROLL_MS,
      );

      if (samplesAll.length >= 2) {
        const count = 220;
        const pts: Array<[number, number]> = [];

        const samples = samplesAll;
        let j = 0;

        for (let i = 0; i < count; i++) {
          const u = i / Math.max(1, count - 1);
          const tt = now - LIVE_SCROLL_MS * (1 - u);

          while (j < samples.length - 2 && samples[j + 1]!.t < tt) j++;
          const a = samples[j]!;
          const b = samples[j + 1] ?? a;
          const denom = Math.max(1, b.t - a.t);
          const w = Math.max(0, Math.min(1, (tt - a.t) / denom));
          const price = a.price + (b.price - a.price) * w;

          const x = leftMargin + drawWidth * u;
          const yy = toY(price);
          pts.push([x, clampY(yy)]);
        }

        return pts;
      }

      const base =
        Number.isFinite(liveFollowPrice) && liveFollowPrice !== 0
          ? liveFollowPrice
          : pCenterBase;
      const y0 = toY(base);
      return [
        [leftMargin, clampY(y0)],
        [leftMargin + drawWidth, clampY(y0)],
      ] as Array<[number, number]>;
    }

    if (prices.length >= 2 && !isFlat && seriesOk) {
      return (resampledSeries ?? []).map(
        (d, i) =>
          [
            toX((d as any).t, i),
            toY((smoothedPrices[i] ?? (d as any).price) as number),
          ] as [number, number],
      );
    }

    return [
      [leftMargin, baseY],
      [leftMargin + drawWidth, baseY],
    ] as Array<[number, number]>;
  })();

  const { curveAlpha, curveK } = (() => {
    if (range === "5H" || range === "1W")
      return { curveAlpha: 0.45, curveK: 0.58 };
    if (range === "1H") return { curveAlpha: 0.5, curveK: 0.4 };
    return { curveAlpha: 0.45, curveK: 0.46 };
  })();

  const toSmoothPath = (pts: Array<[number, number]>) => {
    if (!pts.length) return `M 0,${baseY} L ${width},${baseY}`;
    if (pts.length === 1)
      return `M ${pts[0]![0]},${pts[0]![1]} L ${width},${pts[0]![1]}`;

    const alpha = curveAlpha;
    const segs: string[] = [`M ${pts[0]![0]},${pts[0]![1]}`];

    const dist = (a: [number, number], b: [number, number]) => {
      const dx = a[0] - b[0];
      const dy = a[1] - b[1];
      return Math.sqrt(dx * dx + dy * dy);
    };

    for (let i = 0; i < pts.length - 1; i++) {
      const p1 = pts[i]!;
      const p2 = pts[i + 1]!;
      const p0 =
        pts[i - 1] ??
        ([p1[0] + (p1[0] - p2[0]), p1[1] + (p1[1] - p2[1])] as [
          number,
          number,
        ]);
      const p3 =
        pts[i + 2] ??
        ([p2[0] + (p2[0] - p1[0]), p2[1] + (p2[1] - p1[1])] as [
          number,
          number,
        ]);

      const d01 = Math.max(1e-6, dist(p0, p1));
      const d12 = Math.max(1e-6, dist(p1, p2));
      const d23 = Math.max(1e-6, dist(p2, p3));

      const sa = Math.pow(d01, alpha);
      const sb = Math.pow(d12, alpha);
      const sc = Math.pow(d23, alpha);

      const k = curveK;

      const c1x =
        p2[0] === p1[0] && p2[1] === p1[1]
          ? p1[0]
          : p1[0] + (((p2[0] - p0[0]) * sb) / (sa + sb)) * k;
      const c1y =
        p2[0] === p1[0] && p2[1] === p1[1]
          ? p1[1]
          : p1[1] + (((p2[1] - p0[1]) * sb) / (sa + sb)) * k;

      const c2x =
        p2[0] === p1[0] && p2[1] === p1[1]
          ? p2[0]
          : p2[0] - (((p3[0] - p1[0]) * sb) / (sb + sc)) * k;
      const c2y =
        p2[0] === p1[0] && p2[1] === p1[1]
          ? p2[1]
          : p2[1] - (((p3[1] - p1[1]) * sb) / (sb + sc)) * k;

      segs.push(`C ${c1x},${c1y} ${c2x},${c2y} ${p2[0]},${p2[1]}`);
    }

    return segs.join(" ");
  };

  const path = toSmoothPath(points);

  const endPoint = points[points.length - 1]!;
  const endPointClamped: [number, number] = [
    Math.max(leftMargin, Math.min(leftMargin + drawWidth, endPoint[0])),
    Math.max(0, Math.min(height, endPoint[1])),
  ];

  const openP = prices[0] ?? currentPrice ?? 0;
  const last = prices.length ? prices[prices.length - 1]! : (currentPrice ?? 0);

  const [hoverIndex, setHoverIndex] = useState<number | null>(null);
  const [isScrubbing, setIsScrubbing] = useState(false);
  const pressTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const chartWrapRef = useRef<HTMLDivElement | null>(null);

  const lastIdx = Math.max(0, points.length - 1);
  const activeIdx = hoverIndex ?? lastIdx;

  const activePoint = points[Math.min(lastIdx, Math.max(0, activeIdx))]!;
  const activePointClamped: [number, number] = [
    Math.max(leftMargin, Math.min(leftMargin + drawWidth, activePoint[0])),
    Math.max(0, Math.min(height, activePoint[1])),
  ];

  const findNearestIndex = (clientX: number) => {
    const rect = chartWrapRef.current?.getBoundingClientRect();
    if (!rect || rect.width <= 0) return lastIdx;

    const xFull = ((clientX - rect.left) / rect.width) * width;
    const x = Math.max(leftMargin, Math.min(leftMargin + drawWidth, xFull));
    const idx = Math.round(
      ((x - leftMargin) / Math.max(1, drawWidth)) * (points.length - 1),
    );
    return Math.min(lastIdx, Math.max(0, idx));
  };

  const fmtTooltipDate = (tt: any) => {
    try {
      const d = new Date(tt);
      if (range === "1H" || range === "5H") {
        return new Intl.DateTimeFormat("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        }).format(d);
      }
      if (range === "MAX") {
        return new Intl.DateTimeFormat("en-US", {
          month: "short",
          year: "2-digit",
        }).format(d);
      }
      return new Intl.DateTimeFormat("en-US", {
        month: "short",
        day: "2-digit",
      }).format(d);
    } catch {
      return "";
    }
  };

  const activePrice = prices[activeIdx] ?? last;

  const rangeStartPrice = prices[0] ?? last;
  const rangeEndPrice = last;
  const rangeChangePct =
    rangeStartPrice > 0 && Number.isFinite(rangeStartPrice)
      ? ((rangeEndPrice - rangeStartPrice) / rangeStartPrice) * 100
      : 0;

  const averagePrice = prices.length
    ? prices.reduce((a, b) => a + b, 0) / Math.max(1, prices.length)
    : last;

  const comparedLabel = (() => {
    if (range === "1H") return "Compared to 24h ago";
    if (range === "5H") return "Compared to last week";
    if (range === "1W") return "Compared to last month";
    if (range === "1MO") return "Compared to last year";

    const m = minutesForQuery;
    if (m <= 60 * 24) return "Compared to 24h ago";
    if (m <= 60 * 24 * 7) return "Compared to last week";
    if (m <= 60 * 24 * 30) return "Compared to last month";
    if (m <= 60 * 24 * 90) return "Compared to last 3 months";
    if (m <= 60 * 24 * 180) return "Compared to last 6 months";
    if (m <= 60 * 24 * 365) return "Compared to last year";
    return "Compared to beginning";
  })();

  const pct =
    openP > 0 && Number.isFinite(openP)
      ? ((activePrice - openP) / openP) * 100
      : 0;

  const tooltipX = Math.max(110, Math.min(width - 110, activePointClamped[0]));
  const tooltipY = Math.max(
    10,
    Math.min(height - 92, activePointClamped[1] + 12),
  );
  const tooltipSide = activePointClamped[0] > width * 0.68 ? "left" : "right";

  const requestRange = (next: RangeKey) => {
    if (next === range) return;
    onRangeChange(next);
  };

  const MarketRangeSegmentedControl = useMemo(
    () =>
      function MarketRangeSegmentedControl({
        activeKey,
        onSelect,
        onPickerOpenChange,
      }: {
        activeKey: RangeKey;
        onSelect: (k: RangeKey) => void;
        onPickerOpenChange?: (open: boolean) => void;
      }) {
        const segItems: Array<{
          key: RangeKey;
          labelShort: string;
          labelLong: string;
        }> = [
          { key: "1H", labelShort: "24h", labelLong: "24h" },
          { key: "5H", labelShort: "Week", labelLong: "Weekly" },
          { key: "1W", labelShort: "Month", labelLong: "Monthly" },
          { key: "1MO", labelShort: "Year", labelLong: "Yearly" },
          { key: "MAX", labelShort: "Max", labelLong: "Max" },
        ];

        const isValidRangeKey = (v: string): v is RangeKey =>
          segItems.some((it) => it.key === (v as any));

        const [draftKey, setDraftKey] = useState<RangeKey>(activeKey);
        const [pickerOpen, setPickerOpen] = useState(false);

        useEffect(() => {
          if (!pickerOpen) setDraftKey(activeKey);
        }, [activeKey, pickerOpen]);

        const commitDraft = () => {
          const next = draftKey;
          if (next === activeKey) return;
          if (!isValidRangeKey(next)) return;
          onSelect(next);
        };

        const activeStyle = {
          background: "rgba(255,255,255,0.12)",
          border: "1px solid rgba(255,255,255,0.14)",
          boxShadow:
            "0 14px 38px rgba(0,0,0,0.40), inset 0 1px 0 rgba(255,255,255,0.10)",
        } as const;

        return (
          <div className="w-full">
            <div className="sm:hidden">
              <div
                className="relative w-full h-11 rounded-full overflow-hidden"
                style={{
                  ...activeStyle,
                  boxShadow:
                    "inset 0 1px 0 rgba(255,255,255,0.10), 0 12px 30px rgba(0,0,0,0.35)",
                }}
              >
                <select
                  value={draftKey}
                  onFocus={() => {
                    setPickerOpen(true);
                    onPickerOpenChange?.(true);
                    setDraftKey(activeKey);
                  }}
                  onBlur={() => {
                    setPickerOpen(false);
                    onPickerOpenChange?.(false);
                    commitDraft();
                  }}
                  onChange={(e) => {
                    const v = e.target.value;
                    if (isValidRangeKey(v)) setDraftKey(v);
                  }}
                  aria-label="Select time range"
                  className="absolute inset-0 w-full h-full rounded-full bg-transparent px-4 pr-10 text-left text-[13px] font-semibold tracking-tight text-white appearance-none focus:outline-none cursor-pointer"
                >
                  {segItems.map((it) => (
                    <option key={it.key} value={it.key} className="text-black">
                      {it.labelLong}
                    </option>
                  ))}
                </select>
                <div className="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2">
                  <ChevronDown className="h-4 w-4 text-white/80" />
                </div>
              </div>
            </div>

            <div
              className="hidden sm:block relative w-full overflow-hidden rounded-full border border-white/14"
              style={{
                background: "rgba(255,255,255,0.08)",
                boxShadow:
                  "inset 0 1px 0 rgba(255,255,255,0.10), 0 18px 50px rgba(0,0,0,0.35)",
                backdropFilter: "blur(14px)",
              }}
            >
              <div className="relative p-1">
                <div
                  className="pointer-events-none absolute left-2 right-2 bottom-0 h-px"
                  style={{ background: "rgba(255,255,255,0.08)" }}
                />

                <div className="relative z-10 grid grid-cols-5 gap-0">
                  {segItems.map((it) => {
                    const active = activeKey === it.key;
                    return (
                      <button
                        key={it.key}
                        type="button"
                        className={
                          "h-10 w-full rounded-full text-[14px] font-semibold tracking-tight focus:outline-none flex items-center justify-center " +
                          (active
                            ? "text-white"
                            : "text-white/55 hover:text-white/80")
                        }
                        style={active ? activeStyle : undefined}
                        onClick={() => onSelect(it.key)}
                        aria-pressed={active}
                      >
                        {it.labelLong}
                      </button>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>
        );
      },
    [],
  );

  const strokeOuter = 18;
  const strokeMid = 11.5;
  const strokeCore = 7.8;

  return (
    <Card
      className="market-force-white relative mx-auto w-full max-w-[760px] overflow-hidden rounded-[34px] border border-white/10 bg-transparent text-white shadow-[0_28px_90px_rgba(0,0,0,0.72)]"
      style={{
        backgroundColor: "rgb(8, 48, 170)",
      }}
    >
      <style>{`
        @keyframes livePulse {            0% { transform: scale(1); opacity: 0.11; }
          50% { transform: scale(1.18); opacity: 0.06; }
          100% { transform: scale(1); opacity: 0.11; }
        }
        @keyframes liveDotPulse {
          0% { transform: scale(1); opacity: 0.9; }
          55% { transform: scale(1.75); opacity: 0.18; }
          100% { transform: scale(1); opacity: 0.9; }
        }
      `}</style>

      <div
        className="absolute inset-0 pointer-events-none z-0"
        style={{
          backgroundColor: "rgb(8, 48, 170)",
        }}
      />

      <CardHeader className="relative z-10 pb-3 pt-4 sm:pb-4 sm:pt-6">
        <div className="flex items-start justify-between gap-4">
          <div className="flex items-end gap-2">
            <div
              className="text-[28px] sm:text-[38px] leading-none font-extrabold tracking-tight text-white tabular-nums"
              style={{ textShadow: "0 10px 28px rgba(0,0,0,0.55)" }}
            >
              {Number(rangeEndPrice ?? 0).toLocaleString("en-US", {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
              })}
            </div>
            <div className="mb-[2px] text-[12px] sm:text-[13px] font-bold tracking-wide text-white">
              PPC
            </div>
          </div>
          <div className="text-right">
            <div className="hidden sm:block text-[12px] text-white">
              {comparedLabel}
            </div>
            <div
              className="text-[16px] sm:text-[18px] font-bold tabular-nums text-white"
              style={{ textShadow: "0 10px 24px rgba(0,0,0,0.55)" }}
            >
              {rangeChangePct < 0 ? "" : "+"}
              {rangeChangePct.toFixed(2)}{" "}
              <span className="text-white font-semibold">%</span>
            </div>
            <div className="mt-2 flex justify-end">
              <button
                type="button"
                onClick={() => {
                  setHistoryCache(null);
                  setLiveMode((v) => {
                    const next = !v;
                    if (next) {
                      setLivePatternIndex((p) => {
                        const nxt = pickNextPattern(p);
                        livePatternIndexRef.current = nxt;
                        livePatternPhaseStartPerfRef.current =
                          performance.now();
                        return nxt;
                      });
                    }
                    return next;
                  });
                  setHoverIndex(null);
                  setIsScrubbing(false);
                }}
                className="rounded-full px-2 py-[2px] text-[11px] font-extrabold tracking-[0.14em]"
                style={
                  liveMode
                    ? {
                        color: "rgba(255,255,255,0.98)",
                        background:
                          "linear-gradient(180deg, rgba(34,197,94,0.34) 0%, rgba(34,197,94,0.18) 100%)",
                        border: "1px solid rgba(34,197,94,0.45)",
                        boxShadow:
                          "0 14px 36px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.10)",
                        backdropFilter: "blur(14px)",
                      }
                    : {
                        color: "rgba(255,255,255,0.88)",
                        background:
                          "linear-gradient(180deg, rgba(34,197,94,0.18) 0%, rgba(34,197,94,0.10) 100%)",
                        border: "1px solid rgba(34,197,94,0.28)",
                        boxShadow:
                          "0 12px 30px rgba(0,0,0,0.36), inset 0 1px 0 rgba(255,255,255,0.08)",
                        backdropFilter: "blur(14px)",
                      }
                }
                aria-pressed={liveMode}
              >
                <span className="inline-flex items-center gap-1.5">
                  <span
                    className="relative inline-flex h-2 w-2"
                    aria-hidden="true"
                  >
                    <span
                      className="absolute inset-0 rounded-full"
                      style={{
                        background: "rgba(34,197,94,0.95)",
                        animation: liveMode
                          ? "liveDotPulse 1.2s ease-in-out infinite"
                          : undefined,
                        transformOrigin: "center",
                      }}
                    />
                    <span
                      className="absolute inset-0 rounded-full"
                      style={{ background: "rgba(34,197,94,0.95)" }}
                    />
                  </span>
                  LIVE
                </span>
              </button>
            </div>
          </div>
        </div>
      </CardHeader>

      <CardContent className="relative z-10">
        <div className="mb-3 sm:mb-5 flex justify-center">
          <div className="w-full max-w-[760px]">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
              <div className="flex-1">
                <MarketRangeSegmentedControl
                  activeKey={range}
                  onSelect={requestRange}
                  onPickerOpenChange={(open) => {
                    setRangePickerOpen(open);
                    onTimePickerOpenChange?.(open);
                  }}
                />

                {liveMode && (
                  <div className="mt-2 flex justify-end sm:grid sm:grid-cols-5">
                    <div className="hidden sm:block sm:col-span-4" />
                    <div className="sm:col-span-1 flex justify-end sm:justify-center">
                      <button
                        type="button"
                        className="rounded-full px-3 py-[6px] text-[11px] font-extrabold tracking-[0.12em]"
                        style={{
                          color: "rgba(255,255,255,0.98)",
                          background:
                            "linear-gradient(180deg, rgba(34,197,94,0.30) 0%, rgba(34,197,94,0.16) 100%)",
                          border: "1px solid rgba(34,197,94,0.42)",
                          boxShadow:
                            "0 14px 32px rgba(0,0,0,0.42), inset 0 1px 0 rgba(255,255,255,0.10)",
                          backdropFilter: "blur(14px)",
                        }}
                        aria-label="Now Live (2 sec)"
                        onClick={() => {
                          setLivePatternIndex((p) => {
                            const nxt = pickNextPattern(p);
                            livePatternIndexRef.current = nxt;
                            livePatternPhaseStartPerfRef.current =
                              performance.now();
                            return nxt;
                          });
                        }}
                      >
                        <span className="flex flex-col items-center leading-[1.05]">
                          <span className="inline-flex items-center gap-1.5">
                            <span
                              className="relative inline-flex h-2 w-2"
                              aria-hidden
                            >
                              <span
                                className="absolute inset-0 rounded-full"
                                style={{
                                  background: "rgba(34,197,94,0.95)",
                                  animation:
                                    "liveDotPulse 1.2s ease-in-out infinite",
                                  transformOrigin: "center",
                                }}
                              />
                              <span
                                className="absolute inset-0 rounded-full"
                                style={{ background: "rgba(34,197,94,0.95)" }}
                              />
                            </span>
                            NOW LIVE
                          </span>
                          <span className="mt-[2px] text-[10px] font-semibold tracking-normal text-white/80">
                            2 sec
                          </span>
                        </span>
                      </button>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        <div className="mb-2">
          <div className="text-[11px] leading-tight font-semibold text-white">
            <span className="sm:hidden">PP ≈ $1 · reference only</span>
            <span className="hidden sm:inline">
              PP coins ≈ 1 USD (reference only, not redeemable)
            </span>
          </div>
        </div>

        <div className="w-full">
          <div
            ref={chartWrapRef}
            className="relative w-full h-[165px] sm:h-[210px]"
          >
            <svg
              viewBox={`0 0 ${width} ${height}`}
              className="absolute inset-0 w-full h-full touch-none select-none"
              preserveAspectRatio="xMidYMid meet"
              onPointerDown={(e) => {
                if (liveMode) return;
                if (pressTimerRef.current) clearTimeout(pressTimerRef.current);
                const clientX = e.clientX;
                const pointerId = e.pointerId;
                pressTimerRef.current = setTimeout(() => {
                  setIsScrubbing(true);
                  setHoverIndex(findNearestIndex(clientX));
                }, 220);
                try {
                  (e.currentTarget as any).setPointerCapture?.(pointerId);
                } catch {}
              }}
              onPointerMove={(e) => {
                if (!isScrubbing) return;
                setHoverIndex(findNearestIndex(e.clientX));
              }}
              onPointerUp={(e) => {
                if (pressTimerRef.current) {
                  clearTimeout(pressTimerRef.current);
                  pressTimerRef.current = null;
                }
                setIsScrubbing(false);
                setHoverIndex(null);
                try {
                  (e.currentTarget as any).releasePointerCapture?.(e.pointerId);
                } catch {}
              }}
              onPointerCancel={() => {
                if (pressTimerRef.current) {
                  clearTimeout(pressTimerRef.current);
                  pressTimerRef.current = null;
                }
                setIsScrubbing(false);
                setHoverIndex(null);
              }}
              onPointerLeave={() => {
                if (!isScrubbing) return;
                setIsScrubbing(false);
                setHoverIndex(null);
              }}
            >
              <rect
                x={0}
                y={0}
                width={width}
                height={height}
                fill="rgb(8, 48, 170)"
                pointerEvents="none"
              />

              <defs>
                <filter
                  id="lineGlowStrong"
                  x="-150%"
                  y="-150%"
                  width="400%"
                  height="400%"
                >
                  <feGaussianBlur stdDeviation="7" result="blur" />
                  <feColorMatrix
                    in="blur"
                    type="matrix"
                    values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.40 0"
                    result="glow"
                  />
                  <feMerge>
                    <feMergeNode in="glow" />
                    <feMergeNode in="SourceGraphic" />
                  </feMerge>
                </filter>

                <filter
                  id="lineGlowSoft"
                  x="-130%"
                  y="-130%"
                  width="360%"
                  height="360%"
                >
                  <feGaussianBlur stdDeviation="3.5" result="blur" />
                  <feColorMatrix
                    in="blur"
                    type="matrix"
                    values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.55 0"
                    result="glow"
                  />
                  <feMerge>
                    <feMergeNode in="glow" />
                    <feMergeNode in="SourceGraphic" />
                  </feMerge>
                </filter>

                <filter
                  id="markerShadow"
                  x="-100%"
                  y="-100%"
                  width="300%"
                  height="300%"
                >
                  <feDropShadow
                    dx="0"
                    dy="2"
                    stdDeviation="4"
                    floodColor="#000000"
                    floodOpacity="0.45"
                  />
                </filter>
              </defs>

              <path
                d={path}
                fill="none"
                stroke="#3b82f6"
                strokeWidth={strokeOuter}
                strokeLinejoin="round"
                strokeLinecap="round"
                opacity={0.085}
                filter="url(#lineGlowStrong)"
              />
              <path
                d={path}
                fill="none"
                stroke="#60a5fa"
                strokeWidth={strokeMid}
                strokeLinejoin="round"
                strokeLinecap="round"
                opacity={0.16}
                filter="url(#lineGlowSoft)"
              />
              <path
                d={path}
                fill="none"
                stroke="#60a5fa"
                strokeWidth={strokeCore}
                strokeLinejoin="round"
                strokeLinecap="round"
              />

              {!isScrubbing && (
                <g>
                  <circle
                    cx={endPointClamped[0]}
                    cy={endPointClamped[1]}
                    r={12.2}
                    fill="#3b82f6"
                    opacity={0.11}
                    filter="url(#markerShadow)"
                    style={
                      liveMode
                        ? {
                            transformOrigin: "center",
                            transformBox: "fill-box",
                            animation: "livePulse 1.4s ease-in-out infinite",
                          }
                        : undefined
                    }
                  />
                  <circle
                    cx={endPointClamped[0]}
                    cy={endPointClamped[1]}
                    r={7.2}
                    fill="rgba(255,255,255,0.90)"
                    opacity={0.96}
                  />
                  <circle
                    cx={endPointClamped[0]}
                    cy={endPointClamped[1]}
                    r={9.8}
                    fill="none"
                    stroke="#60a5fa"
                    strokeWidth={3.0}
                    opacity={0.8}
                  />
                </g>
              )}

              {isScrubbing && (
                <g>
                  <line
                    x1={activePointClamped[0]}
                    y1={padTop}
                    x2={activePointClamped[0]}
                    y2={height - padBottom}
                    stroke="rgba(255,255,255,0.12)"
                    strokeWidth={1}
                  />
                  <line
                    x1={leftMargin}
                    y1={activePointClamped[1]}
                    x2={leftMargin + drawWidth}
                    y2={activePointClamped[1]}
                    stroke="rgba(255,255,255,0.10)"
                    strokeWidth={1}
                  />

                  <circle
                    cx={activePointClamped[0]}
                    cy={activePointClamped[1]}
                    r={14.6}
                    fill="#3b82f6"
                    opacity={0.13}
                    filter="url(#markerShadow)"
                  />
                  <circle
                    cx={activePointClamped[0]}
                    cy={activePointClamped[1]}
                    r={8.2}
                    fill="rgba(255,255,255,0.90)"
                    opacity={0.97}
                  />
                  <circle
                    cx={activePointClamped[0]}
                    cy={activePointClamped[1]}
                    r={11.4}
                    fill="none"
                    stroke="#60a5fa"
                    strokeWidth={3.3}
                    opacity={0.92}
                  />
                </g>
              )}
            </svg>

            {isScrubbing && (
              <div
                className="absolute"
                style={{
                  left: `${(tooltipX / width) * 100}%`,
                  top: `${(tooltipY / height) * 100}%`,
                  transform:
                    tooltipSide === "right"
                      ? "translateX(14px)"
                      : "translateX(calc(-100% - 14px))",
                }}
              >
                <div
                  className="rounded-[20px] px-4 py-3 min-w-[160px]"
                  style={{
                    background: "rgba(0,0,0,0.28)",
                    border: "1px solid rgba(255,255,255,0.12)",
                    boxShadow:
                      "0 18px 50px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.08)",
                    backdropFilter: "blur(14px)",
                  }}
                >
                  <div className="text-[12px] font-semibold text-white">
                    {fmtTooltipDate(resampledSeries[activeIdx]?.t)}
                  </div>
                  <div className="mt-0.5 flex items-baseline gap-2">
                    <div className="text-[20px] font-extrabold tracking-tight text-white">
                      {Number(activePrice ?? 0).toLocaleString("en-US", {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2,
                      })}
                    </div>
                    <div className="text-[12px] font-bold tracking-wide text-white">
                      PPC
                    </div>
                  </div>
                  <div className="text-[12px] font-semibold text-white mt-0.5">
                    {pct >= 0 ? "+" : "-"}
                    {Math.abs(pct).toFixed(2)}%
                  </div>
                </div>
              </div>
            )}

            {!liveMode &&
              (() => {
                const s = (resampledSeries ?? []) as any[];
                if (s.length < 2) return null;
                const ticks = [0, 0.25, 0.5, 0.75, 1].map(
                  (p) => s[Math.round(p * (s.length - 1))]?.t,
                );

                const fmtTick = (d: any) => {
                  try {
                    const dd = new Date(d);
                    if (range === "1H" || range === "5H") {
                      return new Intl.DateTimeFormat("en-US", {
                        hour: "numeric",
                        minute: "2-digit",
                        hour12: false,
                      }).format(dd);
                    }
                    if (range === "MAX") {
                      return new Intl.DateTimeFormat("en-US", {
                        month: "short",
                        year: "2-digit",
                      }).format(dd);
                    }
                    return new Intl.DateTimeFormat("en-US", {
                      month: "short",
                      day: "numeric",
                    }).format(dd);
                  } catch {
                    return "";
                  }
                };

                return (
                  <div className="absolute left-0 right-0 bottom-1 sm:bottom-2 px-4 sm:px-5">
                    <div className="flex items-center justify-between text-[12px] sm:text-[14px] text-white">
                      {ticks.map((t, idx) => (
                        <span key={idx} className="tabular-nums">
                          {fmtTick(t)}
                        </span>
                      ))}
                    </div>
                  </div>
                );
              })()}
          </div>
        </div>

        <div className="mt-3 sm:mt-5 flex items-end justify-between gap-3 sm:gap-4 px-1">
          <div>
            <div className="text-[12px] sm:text-[14px] text-white">
              {range === "1H"
                ? "24h avg"
                : range === "5H"
                  ? "Weekly avg"
                  : range === "1W"
                    ? "Monthly avg"
                    : range === "1MO"
                      ? "Yearly avg"
                      : "All‑time avg"}
            </div>
            <div className="mt-1 flex items-end gap-2">
              <div
                className="text-[28px] sm:text-[34px] leading-none font-extrabold tracking-tight text-white tabular-nums"
                style={{ textShadow: "0 10px 28px rgba(0,0,0,0.55)" }}
              >
                {Number(averagePrice ?? 0).toLocaleString("en-US", {
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
                })}
              </div>
              <div className="mb-[3px] text-[13px] font-bold tracking-wide text-white">
                PPC
              </div>
              <div className="mb-[2px] text-white text-[16px] sm:text-[18px] font-bold">
                ↗
              </div>
            </div>
          </div>

          <button
            type="button"
            className="hidden sm:flex items-center gap-2 text-[16px] font-semibold text-white hover:text-white"
            onClick={() => navigate("/general#pp15-how-it-works")}
          >
            <span className="inline-flex h-7 w-7 items-center justify-center rounded-full border border-white/15 bg-white/8 text-white">
              ?
            </span>
            How it works?
          </button>
        </div>
      </CardContent>
    </Card>
  );
}

function MarketScreen() {
  type RangeKey = "1H" | "5H" | "1W" | "1MO" | "MAX";

  const [chartRange, setChartRange] = useState<RangeKey>("1W");
  const [suspendMarketPolling, setSuspendMarketPolling] = useState(false);
  const [topupOpen, setTopupOpen] = useState(false);
  const [mobileMarketInfosOpen, setMobileMarketInfosOpen] = useState(false);

  // Chart should be available immediately; data fills in progressively.
  const chartReady = true;

  // Inline chart component for Market screen
  const InlineMarketChart = useMemo(
    () =>
      function InlineMarketChart({
        marketNow,
        range,
        onRangeChange,
        onTimePickerOpenChange,
        enabled = true,
        mergeTop = false,
      }: {
        marketNow?: MarketOutput;
        range: RangeKey;
        onRangeChange: (r: RangeKey) => void;
        onTimePickerOpenChange?: (open: boolean) => void;
        enabled?: boolean;
        mergeTop?: boolean;
      }) {
        const ranges: { key: RangeKey; label: string; minutes: number }[] = [
          { key: "1H", label: "24hr", minutes: 60 * 24 },
          { key: "5H", label: "Weekly", minutes: 60 * 24 * 7 },
          { key: "1W", label: "Monthly", minutes: 60 * 24 * 30 },
          { key: "1MO", label: "Yearly", minutes: 60 * 24 * 365 },
          // "Max" means: as far back as we have data
          { key: "MAX", label: "Max", minutes: 60 * 24 * 365 * 20 },
        ];

        const minutesForRange = (r: RangeKey) =>
          ranges.find((x) => x.key === r)?.minutes ?? 60 * 24 * 7;

        const refetchMsForRange = (r: RangeKey) => {
          // Keep the app responsive: the chart does not need aggressive polling.
          // Realtime events already reflect trades; this is just for background refresh.
          switch (r) {
            case "1H":
              return 15000;
            case "5H":
              return 15000;
            case "1W":
              return 15000;
            case "1MO":
              return 30000;
            case "MAX":
              return 60000;
            default:
              return 30000;
          }
        };

        // Keep a larger internal drawing coordinate system so the line stays crisp and detailed
        const width = 800;
        const height = 260;

        const [liveMode, setLiveMode] = useState(false);
        const [rangePickerOpen, setRangePickerOpen] = useState(false);

        // Different LIVE motion patterns (each click picks a new one)
        type LivePattern = {
          name: string;
          segs: Array<{ dur: number; from: number; to: number }>;
          total: number;
          linearWeight: number;
          microPeriod: number;
          microAmp: number;
          windowScale: number;
        };

        const livePatterns: LivePattern[] = useMemo(() => {
          const mk = (
            name: string,
            segs: Array<{ dur: number; from: number; to: number }>,
            opt: {
              linearWeight: number;
              microPeriod: number;
              microAmp: number;
              windowScale: number;
            },
          ): LivePattern => ({
            name,
            segs,
            total: segs.reduce((a, s) => a + s.dur, 0),
            linearWeight: opt.linearWeight,
            microPeriod: opt.microPeriod,
            microAmp: opt.microAmp,
            windowScale: opt.windowScale,
          });

          // Deterministic PRNG so the same "pattern number" always stays consistent.
          const mulberry32 = (seed: number) => {
            let a = seed >>> 0;
            return () => {
              a |= 0;
              a = (a + 0x6d2b79f5) | 0;
              let t = Math.imul(a ^ (a >>> 15), 1 | a);
              t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
              return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
          };

          const clamp = (v: number, a: number, b: number) =>
            Math.max(a, Math.min(b, v));

          const templates: Array<{
            name: string;
            segs: Array<{ dur: number; from: number; to: number }>;
          }> = [
            {
              name: "Surge",
              segs: [
                { dur: 1100, from: 0.0, to: 1.0 },
                { dur: 240, from: 1.0, to: 1.0 },
                { dur: 900, from: 1.0, to: -1.0 },
                { dur: 240, from: -1.0, to: -1.0 },
                { dur: 1100, from: -1.0, to: 0.45 },
                { dur: 240, from: 0.45, to: 0.45 },
                { dur: 900, from: 0.45, to: 0.0 },
                { dur: 240, from: 0.0, to: 0.0 },
              ],
            },
            {
              name: "Chop",
              segs: [
                { dur: 760, from: 0.0, to: 1.0 },
                { dur: 210, from: 1.0, to: 1.0 },
                { dur: 760, from: 1.0, to: -1.0 },
                { dur: 210, from: -1.0, to: -1.0 },
                { dur: 520, from: -1.0, to: 0.15 },
                { dur: 220, from: 0.15, to: 0.15 },
                { dur: 600, from: 0.15, to: 0.0 },
                { dur: 220, from: 0.0, to: 0.0 },
              ],
            },
            {
              name: "Pulse",
              segs: [
                { dur: 900, from: 0.0, to: 0.9 },
                { dur: 260, from: 0.9, to: 0.9 },
                { dur: 900, from: 0.9, to: -0.7 },
                { dur: 260, from: -0.7, to: -0.7 },
                { dur: 720, from: -0.7, to: 0.7 },
                { dur: 260, from: 0.7, to: 0.7 },
                { dur: 720, from: 0.7, to: 0.0 },
                { dur: 260, from: 0.0, to: 0.0 },
              ],
            },
            {
              name: "Wave",
              segs: [
                { dur: 1400, from: 0.0, to: 1.0 },
                { dur: 220, from: 1.0, to: 1.0 },
                { dur: 1400, from: 1.0, to: -1.0 },
                { dur: 220, from: -1.0, to: -1.0 },
                { dur: 1400, from: -1.0, to: 0.0 },
                { dur: 260, from: 0.0, to: 0.0 },
              ],
            },
            {
              name: "Stair",
              segs: [
                { dur: 520, from: 0.0, to: 0.55 },
                { dur: 220, from: 0.55, to: 0.55 },
                { dur: 520, from: 0.55, to: 1.0 },
                { dur: 240, from: 1.0, to: 1.0 },
                { dur: 680, from: 1.0, to: -0.9 },
                { dur: 240, from: -0.9, to: -0.9 },
                { dur: 780, from: -0.9, to: 0.0 },
                { dur: 240, from: 0.0, to: 0.0 },
              ],
            },
            {
              name: "Kick",
              segs: [
                { dur: 680, from: 0.0, to: 1.0 },
                { dur: 260, from: 1.0, to: 0.25 },
                { dur: 260, from: 0.25, to: 0.25 },
                { dur: 760, from: 0.25, to: -1.0 },
                { dur: 240, from: -1.0, to: -1.0 },
                { dur: 900, from: -1.0, to: 0.15 },
                { dur: 240, from: 0.15, to: 0.15 },
                { dur: 900, from: 0.15, to: 0.0 },
              ],
            },
            {
              name: "Wobble",
              segs: [
                { dur: 820, from: 0.0, to: 0.85 },
                { dur: 240, from: 0.85, to: 0.85 },
                { dur: 780, from: 0.85, to: -0.55 },
                { dur: 220, from: -0.55, to: -0.55 },
                { dur: 760, from: -0.55, to: 0.35 },
                { dur: 240, from: 0.35, to: 0.35 },
                { dur: 820, from: 0.35, to: 0.0 },
                { dur: 260, from: 0.0, to: 0.0 },
              ],
            },
            {
              name: "Deep",
              segs: [
                { dur: 980, from: 0.0, to: 1.0 },
                { dur: 280, from: 1.0, to: 1.0 },
                { dur: 1180, from: 1.0, to: -1.25 },
                { dur: 260, from: -1.25, to: -1.25 },
                { dur: 980, from: -1.25, to: 0.55 },
                { dur: 260, from: 0.55, to: 0.55 },
                { dur: 820, from: 0.55, to: 0.0 },
                { dur: 280, from: 0.0, to: 0.0 },
              ],
            },
          ];

          const PATTERN_COUNT = 80;
          const out: LivePattern[] = [];

          for (let i = 0; i < PATTERN_COUNT; i++) {
            const rnd = mulberry32(1337 + i * 101);
            const template = templates[i % templates.length]!;

            const amp = 0.75 + rnd() * 0.85; // 0.75..1.60
            const durJitter = 0.78 + rnd() * 0.52; // 0.78..1.30
            const skew = (rnd() - 0.5) * 0.1; // -0.05..0.05

            const segs = template.segs.map((s, idx) => {
              const local = mulberry32(9001 + i * 31 + idx * 97);
              const d = Math.round(s.dur * durJitter * (0.92 + local() * 0.22));
              const from = clamp((s.from + skew) * amp, -1.35, 1.35);
              const to = clamp((s.to + skew) * amp, -1.35, 1.35);
              // Avoid 0 duration.
              return { dur: Math.max(120, d), from, to };
            });

            // Slightly different "feel" per pattern
            const linearWeight = clamp(0.58 + rnd() * 0.38, 0.55, 0.96);
            const microPeriod = Math.round(520 + rnd() * 900); // 520..1420
            const microAmp = clamp(0.06 + rnd() * 0.18, 0.05, 0.22);
            const windowScale = clamp(0.85 + rnd() * 0.55, 0.8, 1.35);

            out.push(
              mk(`${template.name} ${i + 1}`, segs, {
                linearWeight,
                microPeriod,
                microAmp,
                windowScale,
              }),
            );
          }

          return out;
        }, []);

        const [livePatternIndex, setLivePatternIndex] = useState(0);
        const livePatternIndexRef = useRef(0);
        const livePatternPhaseStartPerfRef = useRef<number>(performance.now());

        const pickNextPattern = (current: number) => {
          const n = Math.max(1, livePatterns.length);
          if (n <= 1) return 0;
          const jump = 1 + Math.floor(Math.random() * (n - 1));
          return (current + jump) % n;
        };

        useEffect(() => {
          livePatternIndexRef.current = livePatternIndex;
        }, [livePatternIndex]);

        // LIVE: we show a ~6s scrolling window. Only the newest point changes;
        // older points keep their y-value and slide left until they disappear.
        const LIVE_SCROLL_MS = 6000;

        // Drives the LIVE sampling/scrolling.
        const liveTargetPriceRef = useRef(0);
        const [liveFollowPrice, setLiveFollowPrice] = useState<number>(0);
        const liveSamplesRef = useRef<Array<{ t: number; price: number }>>([]);

        const [liveRafNow, setLiveRafNow] = useState<number>(0);

        useEffect(() => {
          if (!liveMode) return;

          // Seed the window so it looks full immediately (flat line that will start moving).
          const seedNow = Date.now();
          const seedBase = liveTargetPriceRef.current;
          const seedCount = 140;
          liveSamplesRef.current = new Array(seedCount).fill(0).map((_, i) => {
            const age =
              ((seedCount - 1 - i) / Math.max(1, seedCount - 1)) *
              LIVE_SCROLL_MS;
            return { t: seedNow - age, price: seedBase };
          });

          // Snap to the latest known price when turning LIVE on
          setLiveFollowPrice(seedBase);
          setLiveRafNow(seedNow);

          // Start the selected motion pattern from the beginning.
          livePatternPhaseStartPerfRef.current = performance.now();

          let rafId = 0;
          let lastNow = seedNow;

          const smoothstep = (x: number) => {
            const tt = Math.max(0, Math.min(1, x));
            return tt * tt * (3 - 2 * tt);
          };

          let lastUiTick = seedNow;
          const loop = () => {
            const perfNow = performance.now();
            const tMs = perfNow - livePatternPhaseStartPerfRef.current;
            const now = Date.now();
            const dt = Math.max(1, now - lastNow);
            lastNow = now;

            // Smooth-follow the real price so sudden jumps become fluid.
            const target = liveTargetPriceRef.current;
            setLiveFollowPrice((prev) => {
              if (!Number.isFinite(target)) return prev;
              if (!Number.isFinite(prev) || prev === 0) return target;
              // Make smoothing stable across frame-rate variations.
              const alpha = 1 - Math.exp(-dt / 260);
              return prev + (target - prev) * alpha;
            });

            // Visible LIVE motion pattern (stored into the samples, so "Vergangenheit" stays).
            const pat =
              livePatterns[livePatternIndexRef.current] ?? livePatterns[0];
            const total = pat?.total || 1;
            const segs = pat?.segs ?? [];
            const linearW = Math.max(0, Math.min(1, pat?.linearWeight ?? 0.8));
            const easeW = 1 - linearW;

            const tLoop = ((tMs % total) + total) % total;
            let acc = 0;
            let norm = 0;
            for (const seg of segs) {
              if (tLoop <= acc + seg.dur) {
                if (seg.from === seg.to) {
                  norm = seg.from;
                } else {
                  const p = (tLoop - acc) / Math.max(1, seg.dur);
                  const ramp = p * linearW + smoothstep(p) * easeW;
                  norm = seg.from + (seg.to - seg.from) * ramp;
                }
                break;
              }
              acc += seg.dur;
            }

            const microPeriod = pat?.microPeriod ?? 850;
            const microAmp = pat?.microAmp ?? 0.12;
            const micro =
              Math.sin((2 * Math.PI * (tMs % microPeriod)) / microPeriod) *
              microAmp;
            const combined = norm + micro;

            const baseForWindow = Number.isFinite(target) ? target : seedBase;
            const fallback = Math.max(0.08, Math.abs(baseForWindow) * 0.00012);
            const maxCap = Math.max(0.25, Math.abs(baseForWindow) * 0.00025);
            const desired = fallback * (pat?.windowScale ?? 1.0) * 1.5;
            const liveWindow = Math.min(maxCap, Math.max(fallback, desired));
            const osc = combined * liveWindow * 0.5;

            const nextPrice =
              (Number.isFinite(liveTargetPriceRef.current)
                ? liveTargetPriceRef.current
                : seedBase) + osc;

            const arr = liveSamplesRef.current;
            arr.push({ t: now, price: nextPrice });
            // Keep buffer bounded (a bit larger than the window for safety).
            const cutoff = now - LIVE_SCROLL_MS * 2;
            while (arr.length && arr[0]!.t < cutoff) arr.shift();

            // Throttle UI updates to reduce CPU/GPU load on mobile.
            if (now - lastUiTick >= 50) {
              lastUiTick = now;
              setLiveRafNow(now);
            }

            rafId = requestAnimationFrame(loop);
          };

          rafId = requestAnimationFrame(loop);
          return () => cancelAnimationFrame(rafId);
        }, [liveMode, LIVE_SCROLL_MS]);

        // LIVE mode: very close-up + fast refresh so it reacts almost immediately to buys/sells.
        const minutesForQuery = liveMode ? 30 : minutesForRange(range);

        const refetchMs = liveMode ? 6000 : refetchMsForRange(range);

        const historyCacheKey = `pp15_price_history_cache_v1_${liveMode ? "LIVE" : range}`;
        const historyPlaceholder = useMemo(() => {
          try {
            if (typeof window === "undefined") return undefined;
            const raw = window.localStorage.getItem(historyCacheKey);
            if (!raw) return undefined;
            const parsed = JSON.parse(raw) as {
              ts?: number;
              data?: PriceHistoryOutput;
            };
            const ts = Number(parsed?.ts ?? 0);
            // Keep for up to 60 minutes (good enough for instant first paint)
            if (!ts || Date.now() - ts > 60 * 60_000) return undefined;
            return parsed?.data;
          } catch {
            return undefined;
          }
        }, [historyCacheKey]);

        const { data: history } = useQuery<PriceHistoryOutput>(
          ["priceHistory_inline", liveMode ? "LIVE" : range],
          () => apiClient.getPriceHistory({ minutes: minutesForQuery }),
          {
            enabled: !!enabled,
            placeholderData: historyPlaceholder as any,
            refetchInterval: rangePickerOpen ? false : refetchMs,
            staleTime: rangePickerOpen ? 60000 : refetchMs,
            refetchOnWindowFocus: false,
            refetchOnReconnect: false,
            retry: 0,
            refetchIntervalInBackground: false,
            onSuccess: (data) => {
              try {
                if (typeof window === "undefined") return;
                if (!Array.isArray(data) || data.length < 2) return;
                window.localStorage.setItem(
                  historyCacheKey,
                  JSON.stringify({ ts: Date.now(), data }),
                );
              } catch {}
            },
          },
        );

        // Keep the last loaded series so we can cross-fade smoothly while the new range loads.
        const [historyCache, setHistoryCache] =
          useState<PriceHistoryOutput | null>(null);
        useEffect(() => {
          const arr = (history ?? []) as any[];
          if (Array.isArray(arr) && arr.length)
            setHistoryCache(history ?? null);
        }, [history]);

        const effectiveHistory = useMemo(() => {
          return liveMode
            ? (history ?? [])
            : ((((history ?? []) as any[]).length ? history : historyCache) ??
                history ??
                []);
        }, [liveMode, history, historyCache]);

        const rawSeries = useMemo(() => {
          const arr = (effectiveHistory ?? []) as any[];
          return arr.filter(
            (d) => typeof d?.price === "number" && d?.t,
          ) as Array<{
            t: any;
            price: number;
          }>;
        }, [effectiveHistory]);

        // Make the chart feel "live": always keep the latest point aligned to the
        // current market price (from realtime), even between history refreshes.
        const rawSeriesLiveAdjusted = useMemo(() => {
          const liveP = marketNow?.pricePerM2CHF;
          if (!Number.isFinite(liveP as any)) return rawSeries;
          const livePrice = Number(liveP);

          if (!rawSeries.length) {
            const now = Date.now();
            const since = now - minutesForQuery * 60 * 1000;
            return [
              { t: new Date(since), price: livePrice },
              { t: new Date(now), price: livePrice },
            ];
          }

          const out = rawSeries.slice();
          const last = out[out.length - 1];
          if (!last) return out;
          out[out.length - 1] = { ...last, price: livePrice };
          return out;
        }, [rawSeries, marketNow?.pricePerM2CHF, minutesForQuery]);

        // Resample to a fixed, high-resolution series so the chart looks detailed
        // even when we have only a few raw samples.
        const targetPoints =
          range === "1H"
            ? 420
            : range === "5H"
              ? 620
              : range === "1W"
                ? 520
                : range === "1MO"
                  ? 680
                  : 760;

        const resampledSeries = useMemo(() => {
          const s = rawSeriesLiveAdjusted;
          if (s.length <= 1) return s;
          const firstT = +new Date(s[0]!.t);
          const lastT = +new Date(s[s.length - 1]!.t);
          if (
            !Number.isFinite(firstT) ||
            !Number.isFinite(lastT) ||
            lastT <= firstT
          ) {
            return s;
          }

          const out: Array<{ t: number; price: number }> = [];
          let j = 0;
          for (let i = 0; i < targetPoints; i++) {
            const tt = firstT + ((lastT - firstT) * i) / (targetPoints - 1);
            while (j < s.length - 2 && +new Date(s[j + 1]!.t) < tt) {
              j++;
            }
            const a = s[j]!;
            const b = s[j + 1] ?? a;
            const ta = +new Date(a.t);
            const tb = +new Date(b.t);
            const denom = Math.max(1, tb - ta);
            const w0 = Math.min(1, Math.max(0, (tt - ta) / denom));
            const eased = (() => {
              const smootherstep = (x: number) =>
                x * x * x * (x * (x * 6 - 15) + 10);
              const smoothstep = (x: number) => x * x * (3 - 2 * x);

              if (range === "5H" || range === "1W") return smootherstep(w0);
              if (range === "1H") return smoothstep(w0) * 0.65 + w0 * 0.35;
              return smoothstep(w0);
            })();
            const price = a.price + (b.price - a.price) * eased;
            out.push({ t: tt, price });
          }
          return out;
        }, [rawSeriesLiveAdjusted, targetPoints, range]);

        const prices = useMemo(
          () => resampledSeries.map((d) => d.price),
          [resampledSeries],
        );

        // For the line rendering we apply a gentle smoothing so the curve has
        // no sharp corners. Tooltip values remain based on the unsmoothed series.
        const gaussianSmooth = (
          arr: number[],
          radius: number,
          sigma: number,
        ) => {
          if (arr.length < 3) return arr;
          const r = Math.max(1, Math.min(24, Math.floor(radius)));
          const s = Math.max(0.2, sigma);
          const kernel: number[] = [];
          let sum = 0;
          for (let i = -r; i <= r; i++) {
            const w = Math.exp(-(i * i) / (2 * s * s));
            kernel.push(w);
            sum += w;
          }
          const norm = sum || 1;

          const out: number[] = new Array(arr.length);
          for (let i = 0; i < arr.length; i++) {
            let acc = 0;
            for (let k = -r; k <= r; k++) {
              const idx = Math.max(0, Math.min(arr.length - 1, i + k));
              acc += arr[idx]! * (kernel[k + r]! / norm);
            }
            out[i] = acc;
          }
          return out;
        };

        const smoothing = (() => {
          // Weekly/Monthly should be more "liquid".
          if (range === "5H") return { radius: 7, sigma: 3.2 };
          if (range === "1W") return { radius: 8, sigma: 3.6 };
          if (range === "1H") return { radius: 4, sigma: 2.0 };
          if (range === "1MO") return { radius: 3, sigma: 1.6 };
          // MAX: keep it subtle (still avoid tiny kinks)
          return { radius: 2, sigma: 1.2 };
        })();

        const smoothedPrices = useMemo(
          () => gaussianSmooth(prices, smoothing.radius, smoothing.sigma),
          [prices, smoothing.radius, smoothing.sigma],
        );

        const n = Math.max(2, prices.length || 2);

        const minMaxOf = (arr: number[]) => {
          let mn = Number.POSITIVE_INFINITY;
          let mx = Number.NEGATIVE_INFINITY;
          for (const v of arr) {
            if (!Number.isFinite(v)) continue;
            if (v < mn) mn = v;
            if (v > mx) mx = v;
          }
          if (!Number.isFinite(mn) || !Number.isFinite(mx))
            return { mn: 0, mx: 1 };
          return { mn, mx };
        };

        // Make sure the line is always visible and not glued to the edges like a triangle.
        // We add vertical padding and keep space at the bottom for the x-axis labels.
        const { mn: pminA, mx: pmaxA } = prices.length
          ? minMaxOf(prices)
          : {
              mn: marketNow?.pricePerM2CHF ?? 0,
              mx: (marketNow?.pricePerM2CHF ?? 0) + 1,
            };

        const { mn: pminB, mx: pmaxB } = prices.length
          ? minMaxOf(smoothedPrices)
          : { mn: pminA, mx: pmaxA };

        const pminRaw = prices.length ? Math.min(pminA, pminB) : pminA;
        const pmaxRaw = prices.length ? Math.max(pmaxA, pmaxB) : pmaxA;

        let span = pmaxRaw - pminRaw;
        if (!Number.isFinite(span) || span <= 0) {
          span = Math.max(1, Math.abs(pmaxRaw) * 0.02);
        }
        // More padding so the line feels less "stretched" and floats like the reference.
        // LIVE mode: keep the view extremely close and centered around the current price.
        const pCenterBase = prices.length
          ? prices[prices.length - 1]!
          : (marketNow?.pricePerM2CHF ?? 0);

        // Keep LIVE target updated every render (used by the smooth-follow state)
        liveTargetPriceRef.current = pCenterBase;

        const liveWindow = (() => {
          if (!liveMode) return null;

          const center =
            Number.isFinite(liveFollowPrice) && liveFollowPrice !== 0
              ? liveFollowPrice
              : pCenterBase;

          // Always keep it "ganz nah" and do not zoom out based on historical spikes.
          const fallback = Math.max(0.08, Math.abs(center) * 0.00012);
          const maxCap = Math.max(0.25, Math.abs(center) * 0.00025);

          // Slightly wider than fallback so the live movement is visible but still tight.
          const desired = fallback * 1.35;
          return Math.min(maxCap, Math.max(fallback, desired));
        })();

        const pCenter = liveMode
          ? Number.isFinite(liveFollowPrice) && liveFollowPrice !== 0
            ? liveFollowPrice
            : pCenterBase
          : pCenterBase;

        const pad = liveMode ? 0 : span * 0.45;
        const pmin = liveMode
          ? pCenter - (liveWindow ?? Math.max(1, span))
          : pminRaw - pad;
        const pmax = liveMode
          ? pCenter + (liveWindow ?? Math.max(1, span))
          : pmaxRaw + pad;

        // Leave horizontal breathing room so the line "floats" and doesn't feel stretched edge-to-edge.
        const leftMargin = 34;
        const rightMargin = 34;
        const drawWidth = width - leftMargin - rightMargin;
        const padTop = 14;
        const padBottom = 48;
        const usable = Math.max(1, height - padTop - padBottom);

        const normalize = (p: number) =>
          (p - pmin) / Math.max(1e-9, pmax - pmin);
        const toY = (p: number) => padTop + usable * (1 - normalize(p));

        const seriesT0 = resampledSeries[0]?.t
          ? +new Date(resampledSeries[0]!.t as any)
          : 0;
        const seriesT1 = resampledSeries[resampledSeries.length - 1]?.t
          ? +new Date(resampledSeries[resampledSeries.length - 1]!.t as any)
          : 1;
        const toX = (tt: any, i: number) => {
          const t = +new Date(tt);
          if (
            !Number.isFinite(t) ||
            !Number.isFinite(seriesT0) ||
            !Number.isFinite(seriesT1)
          ) {
            return leftMargin + (drawWidth * i) / Math.max(1, n - 1);
          }
          const denom = Math.max(1, seriesT1 - seriesT0);
          return leftMargin + (drawWidth * (t - seriesT0)) / denom;
        };

        const isFlat =
          prices.length >= 2
            ? Math.abs(pmaxRaw - pminRaw) < 1e-6
            : prices.length === 1;
        const baseY = Math.round(padTop + usable * 0.62);

        const points: Array<[number, number]> = (() => {
          const clampY = (yy: number) =>
            Math.max(padTop, Math.min(height - padBottom, yy));

          const seriesOk = (resampledSeries ?? []).length >= 2;

          // LIVE: show a rolling ~6s history that scrolls left.
          // Only the newest point changes; older points keep their y and just move left.
          if (liveMode) {
            const now = liveRafNow || Date.now();
            const samplesAll = (liveSamplesRef.current ?? []).filter(
              (s) => now - s.t <= LIVE_SCROLL_MS,
            );

            if (samplesAll.length >= 2) {
              // Build a fixed number of points for a stable, smooth curve.
              const count = 220;
              const pts: Array<[number, number]> = [];

              // Ensure sorted by time (should already be).
              const samples = samplesAll;
              let j = 0;

              for (let i = 0; i < count; i++) {
                const u = i / Math.max(1, count - 1);
                const tt = now - LIVE_SCROLL_MS * (1 - u);

                while (j < samples.length - 2 && samples[j + 1]!.t < tt) j++;
                const a = samples[j]!;
                const b = samples[j + 1] ?? a;
                const denom = Math.max(1, b.t - a.t);
                const w = Math.max(0, Math.min(1, (tt - a.t) / denom));
                const price = a.price + (b.price - a.price) * w;

                const x = leftMargin + drawWidth * u;
                const yy = toY(price);
                pts.push([x, clampY(yy)]);
              }

              return pts;
            }

            // Fallback: flat line
            const base =
              Number.isFinite(liveFollowPrice) && liveFollowPrice !== 0
                ? liveFollowPrice
                : pCenterBase;
            const y0 = toY(base);
            return [
              [leftMargin, clampY(y0)],
              [leftMargin + drawWidth, clampY(y0)],
            ] as Array<[number, number]>;
          }

          // Normal mode: if the series is flat, keep a clean straight line.
          if (prices.length >= 2 && !isFlat && seriesOk) {
            return (resampledSeries ?? []).map(
              (d, i) =>
                [
                  toX((d as any).t, i),
                  toY((smoothedPrices[i] ?? (d as any).price) as number),
                ] as [number, number],
            );
          }

          return [
            [leftMargin, baseY],
            [leftMargin + drawWidth, baseY],
          ] as Array<[number, number]>;
        })();

        // Curve tuning per range:
        // Weekly/Monthly should be visibly more curvy like in the reference.
        const { curveAlpha, curveK } = (() => {
          if (range === "5H" || range === "1W")
            return { curveAlpha: 0.45, curveK: 0.58 };
          if (range === "1H") return { curveAlpha: 0.5, curveK: 0.4 };
          // Yearly (and default) stays a bit calmer
          return { curveAlpha: 0.45, curveK: 0.46 };
        })();

        const toSmoothPath = (pts: Array<[number, number]>) => {
          if (!pts.length) return `M 0,${baseY} L ${width},${baseY}`;
          if (pts.length === 1)
            return `M ${pts[0]![0]},${pts[0]![1]} L ${width},${pts[0]![1]}`;

          // Catmull-Rom -> Bezier conversion for very rounded, liquid curves
          const alpha = curveAlpha;
          const segs: string[] = [`M ${pts[0]![0]},${pts[0]![1]}`];

          const dist = (a: [number, number], b: [number, number]) => {
            const dx = a[0] - b[0];
            const dy = a[1] - b[1];
            return Math.sqrt(dx * dx + dy * dy);
          };

          for (let i = 0; i < pts.length - 1; i++) {
            const p1 = pts[i]!;
            const p2 = pts[i + 1]!;
            // Extrapolate endpoints so the curve stays rounded even at the edges.
            const p0 =
              pts[i - 1] ??
              ([p1[0] + (p1[0] - p2[0]), p1[1] + (p1[1] - p2[1])] as [
                number,
                number,
              ]);
            const p3 =
              pts[i + 2] ??
              ([p2[0] + (p2[0] - p1[0]), p2[1] + (p2[1] - p1[1])] as [
                number,
                number,
              ]);

            const d01 = Math.max(1e-6, dist(p0, p1));
            const d12 = Math.max(1e-6, dist(p1, p2));
            const d23 = Math.max(1e-6, dist(p2, p3));

            const sa = Math.pow(d01, alpha);
            const sb = Math.pow(d12, alpha);
            const sc = Math.pow(d23, alpha);

            // Control point distance multiplier (bigger = rounder corners)
            const k = curveK;

            const c1x =
              p2[0] === p1[0] && p2[1] === p1[1]
                ? p1[0]
                : p1[0] + (((p2[0] - p0[0]) * sb) / (sa + sb)) * k;
            const c1y =
              p2[0] === p1[0] && p2[1] === p1[1]
                ? p1[1]
                : p1[1] + (((p2[1] - p0[1]) * sb) / (sa + sb)) * k;

            const c2x =
              p2[0] === p1[0] && p2[1] === p1[1]
                ? p2[0]
                : p2[0] - (((p3[0] - p1[0]) * sb) / (sb + sc)) * k;
            const c2y =
              p2[0] === p1[0] && p2[1] === p1[1]
                ? p2[1]
                : p2[1] - (((p3[1] - p1[1]) * sb) / (sb + sc)) * k;

            segs.push(`C ${c1x},${c1y} ${c2x},${c2y} ${p2[0]},${p2[1]}`);
          }

          return segs.join(" ");
        };
        const path = toSmoothPath(points);

        const endPoint = points[points.length - 1]!;
        const endPointClamped: [number, number] = [
          Math.max(leftMargin, Math.min(leftMargin + drawWidth, endPoint[0])),
          Math.max(0, Math.min(height, endPoint[1])),
        ];

        const openP = prices[0] ?? marketNow?.pricePerM2CHF ?? 0;
        const last = prices.length
          ? prices[prices.length - 1]!
          : (marketNow?.pricePerM2CHF ?? 0);

        const [hoverIndex, setHoverIndex] = useState<number | null>(null);
        const [isScrubbing, setIsScrubbing] = useState(false);
        const pressTimerRef = useRef<ReturnType<typeof setTimeout> | null>(
          null,
        );
        const chartWrapRef = useRef<HTMLDivElement | null>(null);

        const [prevPath, setPrevPath] = useState<string | null>(null);
        const [fadeId, setFadeId] = useState(0);
        const fadeTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

        const lastIdx = Math.max(0, points.length - 1);
        const activeIdx = hoverIndex ?? lastIdx;

        const activePoint = points[Math.min(lastIdx, Math.max(0, activeIdx))]!;
        const activePointClamped: [number, number] = [
          Math.max(
            leftMargin,
            Math.min(leftMargin + drawWidth, activePoint[0]),
          ),
          Math.max(0, Math.min(height, activePoint[1])),
        ];

        const findNearestIndex = (clientX: number) => {
          const rect = chartWrapRef.current?.getBoundingClientRect();
          if (!rect || rect.width <= 0) return lastIdx;

          // Map the pointer X directly to an index so scrubbing feels 1:1 with finger movement.
          const xFull = ((clientX - rect.left) / rect.width) * width;
          const x = Math.max(
            leftMargin,
            Math.min(leftMargin + drawWidth, xFull),
          );
          const idx = Math.round(
            ((x - leftMargin) / Math.max(1, drawWidth)) * (points.length - 1),
          );
          return Math.min(lastIdx, Math.max(0, idx));
        };

        const fmtTooltipDate = (tt: any) => {
          try {
            const d = new Date(tt);
            if (range === "1H" || range === "5H") {
              return new Intl.DateTimeFormat("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                hour12: false,
              }).format(d);
            }
            if (range === "MAX") {
              return new Intl.DateTimeFormat("en-US", {
                month: "short",
                year: "2-digit",
              }).format(d);
            }
            return new Intl.DateTimeFormat("en-US", {
              month: "short",
              day: "2-digit",
            }).format(d);
          } catch {
            return "";
          }
        };

        const activePrice = prices[activeIdx] ?? last;

        const rangeStartPrice = prices[0] ?? last;
        const rangeEndPrice = last;
        const rangeChangePct =
          rangeStartPrice > 0 && Number.isFinite(rangeStartPrice)
            ? ((rangeEndPrice - rangeStartPrice) / rangeStartPrice) * 100
            : 0;

        const averagePrice = prices.length
          ? prices.reduce((a, b) => a + b, 0) / Math.max(1, prices.length)
          : last;

        const comparedLabel = (() => {
          if (range === "1H") return "Compared to 24h ago";
          if (range === "5H") return "Compared to last week";
          if (range === "1W") return "Compared to last month";
          if (range === "1MO") return "Compared to last year";

          // MAX: label follows the zoom level (how far back we’re looking).
          const m = minutesForQuery;
          if (m <= 60 * 24) return "Compared to 24h ago";
          if (m <= 60 * 24 * 7) return "Compared to last week";
          if (m <= 60 * 24 * 30) return "Compared to last month";
          if (m <= 60 * 24 * 90) return "Compared to last 3 months";
          if (m <= 60 * 24 * 180) return "Compared to last 6 months";
          if (m <= 60 * 24 * 365) return "Compared to last year";
          return "Compared to beginning";
        })();

        const pct =
          openP > 0 && Number.isFinite(openP)
            ? ((activePrice - openP) / openP) * 100
            : 0;

        const tooltipX = Math.max(
          110,
          Math.min(width - 110, activePointClamped[0]),
        );
        const tooltipY = Math.max(
          10,
          Math.min(height - 92, activePointClamped[1] + 12),
        );
        const tooltipSide =
          activePointClamped[0] > width * 0.68 ? "left" : "right";

        const requestRange = (next: RangeKey) => {
          if (next === range) return;
          if (fadeTimerRef.current) {
            clearTimeout(fadeTimerRef.current);
            fadeTimerRef.current = null;
          }
          // Keep LIVE as-is when switching the time range (do not auto-disable).
          // Immediate switch (no animations)
          setPrevPath(null);
          setFadeId((x) => x + 1);
          onRangeChange(next);
        };

        const MarketRangeSegmentedControl = useMemo(
          () =>
            function MarketRangeSegmentedControl({
              activeKey,
              onSelect,
              onPickerOpenChange,
            }: {
              activeKey: RangeKey;
              onSelect: (k: RangeKey) => void;
              onPickerOpenChange?: (open: boolean) => void;
            }) {
              const segItems: Array<{
                key: RangeKey;
                labelShort: string;
                labelLong: string;
              }> = [
                { key: "1H", labelShort: "24h", labelLong: "24h" },
                { key: "5H", labelShort: "Week", labelLong: "Weekly" },
                { key: "1W", labelShort: "Month", labelLong: "Monthly" },
                { key: "1MO", labelShort: "Year", labelLong: "Yearly" },
                { key: "MAX", labelShort: "Max", labelLong: "Max" },
              ];

              const isValidRangeKey = (v: string): v is RangeKey =>
                segItems.some((it) => it.key === (v as any));

              // iOS-select stability: do not change the chart range while the picker is open.
              // We only commit the selection on blur (Done/close), which avoids the picker
              // “closing/crashing” due to re-renders while scrolling through options.
              const [draftKey, setDraftKey] = useState<RangeKey>(activeKey);
              const [pickerOpen, setPickerOpen] = useState(false);

              useEffect(() => {
                if (!pickerOpen) setDraftKey(activeKey);
              }, [activeKey, pickerOpen]);

              const commitDraft = () => {
                const next = draftKey;
                if (next === activeKey) return;
                if (!isValidRangeKey(next)) return;
                onSelect(next);
              };

              const activeStyle = {
                background: "rgba(255,255,255,0.12)",
                border: "1px solid rgba(255,255,255,0.14)",
                boxShadow:
                  "0 14px 38px rgba(0,0,0,0.40), inset 0 1px 0 rgba(255,255,255,0.10)",
              } as const;

              return (
                <div className="w-full">
                  {/* iPhone: native iOS picker via <select> */}
                  <div className="sm:hidden">
                    <div
                      className="relative w-full h-11 rounded-full overflow-hidden"
                      style={{
                        ...activeStyle,
                        boxShadow:
                          "inset 0 1px 0 rgba(255,255,255,0.10), 0 12px 30px rgba(0,0,0,0.35)",
                      }}
                    >
                      <select
                        value={draftKey}
                        onFocus={() => {
                          setPickerOpen(true);
                          onPickerOpenChange?.(true);
                          setDraftKey(activeKey);
                        }}
                        onBlur={() => {
                          setPickerOpen(false);
                          onPickerOpenChange?.(false);
                          commitDraft();
                        }}
                        onChange={(e) => {
                          const v = e.target.value;
                          if (isValidRangeKey(v)) setDraftKey(v);
                        }}
                        aria-label="Select time range"
                        className="absolute inset-0 w-full h-full rounded-full bg-transparent px-4 pr-10 text-left text-[13px] font-semibold tracking-tight text-white appearance-none focus:outline-none cursor-pointer"
                      >
                        {segItems.map((it) => (
                          <option
                            key={it.key}
                            value={it.key}
                            className="text-black"
                          >
                            {it.labelLong}
                          </option>
                        ))}
                      </select>
                      <div className="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2">
                        <ChevronDown className="h-4 w-4 text-white/80" />
                      </div>
                    </div>
                  </div>

                  {/* Desktop: segmented control */}
                  <div
                    className="hidden sm:block relative w-full overflow-hidden rounded-full border border-white/14"
                    style={{
                      background: "rgba(255,255,255,0.08)",
                      boxShadow:
                        "inset 0 1px 0 rgba(255,255,255,0.10), 0 18px 50px rgba(0,0,0,0.35)",
                      backdropFilter: "blur(14px)",
                    }}
                  >
                    <div className="relative p-1">
                      <div
                        className="pointer-events-none absolute left-2 right-2 bottom-0 h-px"
                        style={{ background: "rgba(255,255,255,0.08)" }}
                      />

                      <div className="relative z-10 grid grid-cols-5 gap-0">
                        {segItems.map((it) => {
                          const active = activeKey === it.key;
                          return (
                            <button
                              key={it.key}
                              type="button"
                              className={
                                "h-10 w-full rounded-full text-[14px] font-semibold tracking-tight focus:outline-none flex items-center justify-center " +
                                (active
                                  ? "text-white"
                                  : "text-white/55 hover:text-white/80")
                              }
                              style={active ? activeStyle : undefined}
                              onClick={() => onSelect(it.key)}
                              aria-pressed={active}
                            >
                              {it.labelLong}
                            </button>
                          );
                        })}
                      </div>
                    </div>
                  </div>
                </div>
              );
            },
          [],
        );

        // keep values available to compute deltas if needed
        void openP;

        // Line thickness (ultra bold)
        const strokeOuter = 18;
        const strokeMid = 11.5;
        const strokeCore = 7.8;

        return (
          <Card
            className={
              "market-force-white relative mx-auto w-full max-w-[760px] overflow-hidden rounded-[34px] border border-white/10 bg-transparent text-white shadow-[0_28px_90px_rgba(0,0,0,0.72)]" +
              (mergeTop ? " sm:rounded-t-none sm:border-t-0" : "")
            }
            style={{
              backgroundColor: "rgb(8, 48, 170)",
            }}
          >
            {" "}
            <style>{`
          @keyframes chartFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
          }
          @keyframes lineDraw {
            from { stroke-dashoffset: 1; opacity: 0.15; }
            to { stroke-dashoffset: 0; opacity: 1; }
          }
           @keyframes liveFloat {
             0% { transform: translateY(0px); }
             25% { transform: translateY(-3.2px); }
             50% { transform: translateY(0px); }
             75% { transform: translateY(3.2px); }
             100% { transform: translateY(0px); }
           }
           @keyframes livePulse {            0% { transform: scale(1); opacity: 0.11; }
            50% { transform: scale(1.18); opacity: 0.06; }
            100% { transform: scale(1); opacity: 0.11; }
          }
          @keyframes liveDotPulse {
            0% { transform: scale(1); opacity: 0.9; }
            55% { transform: scale(1.75); opacity: 0.18; }
            100% { transform: scale(1); opacity: 0.9; }
          }
        `}</style>
            {/* Liquid-glass background (no inner box) */}
            <div
              className="absolute inset-0 pointer-events-none z-0"
              style={{
                backgroundColor: "rgb(8, 48, 170)",
              }}
            />
            <CardHeader className="relative z-10 pb-3 pt-4 sm:pb-4 sm:pt-6">
              <div className="flex items-start justify-between gap-4">
                <div className="flex items-end gap-2">
                  <div
                    className="text-[28px] sm:text-[38px] leading-none font-extrabold tracking-tight text-white tabular-nums"
                    style={{ textShadow: "0 10px 28px rgba(0,0,0,0.55)" }}
                  >
                    {Number(rangeEndPrice ?? 0).toLocaleString("en-US", {
                      minimumFractionDigits: 2,
                      maximumFractionDigits: 2,
                    })}
                  </div>
                  <div className="mb-[2px] text-[12px] sm:text-[13px] font-bold tracking-wide text-white">
                    PPC
                  </div>
                </div>
                <div className="text-right">
                  <div className="hidden sm:block text-[12px] text-white">
                    {comparedLabel}
                  </div>
                  <div
                    className="text-[16px] sm:text-[18px] font-bold tabular-nums text-white"
                    style={{
                      textShadow: "0 10px 24px rgba(0,0,0,0.55)",
                    }}
                  >
                    {" "}
                    {rangeChangePct < 0 ? "" : "+"}
                    {rangeChangePct.toFixed(2)}{" "}
                    <span className="text-white font-semibold">%</span>
                  </div>

                  {/* LIVE toggle: above Max (chart controls) and below the % number */}
                  <div className="mt-2 flex justify-end">
                    <button
                      type="button"
                      onClick={() => {
                        // LIVE should switch instantly (no old history lingering)
                        setHistoryCache(null);
                        setLiveMode((v) => {
                          const next = !v;
                          if (next) {
                            setLivePatternIndex((p) => {
                              const nxt = pickNextPattern(p);
                              livePatternIndexRef.current = nxt;
                              livePatternPhaseStartPerfRef.current =
                                performance.now();
                              return nxt;
                            });
                          }
                          return next;
                        });
                        setHoverIndex(null);
                        setIsScrubbing(false);
                      }}
                      className="rounded-full px-2 py-[2px] text-[11px] font-extrabold tracking-[0.14em]"
                      style={
                        liveMode
                          ? {
                              color: "rgba(255,255,255,0.98)",
                              background:
                                "linear-gradient(180deg, rgba(34,197,94,0.34) 0%, rgba(34,197,94,0.18) 100%)",
                              border: "1px solid rgba(34,197,94,0.45)",
                              boxShadow:
                                "0 14px 36px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.10)",
                              backdropFilter: "blur(14px)",
                            }
                          : {
                              color: "rgba(255,255,255,0.88)",
                              background:
                                "linear-gradient(180deg, rgba(34,197,94,0.18) 0%, rgba(34,197,94,0.10) 100%)",
                              border: "1px solid rgba(34,197,94,0.28)",
                              boxShadow:
                                "0 12px 30px rgba(0,0,0,0.36), inset 0 1px 0 rgba(255,255,255,0.08)",
                              backdropFilter: "blur(14px)",
                            }
                      }
                      aria-pressed={liveMode}
                    >
                      <span className="inline-flex items-center gap-1.5">
                        <span
                          className="relative inline-flex h-2 w-2"
                          aria-hidden="true"
                        >
                          <span
                            className="absolute inset-0 rounded-full"
                            style={{
                              background: "rgba(34,197,94,0.95)",
                              animation: liveMode
                                ? "liveDotPulse 1.2s ease-in-out infinite"
                                : undefined,
                              transformOrigin: "center",
                            }}
                          />
                          <span
                            className="absolute inset-0 rounded-full"
                            style={{ background: "rgba(34,197,94,0.95)" }}
                          />
                        </span>
                        LIVE
                      </span>
                    </button>
                  </div>
                </div>
              </div>
            </CardHeader>
            <CardContent className="relative z-10">
              <div className="mb-3 sm:mb-5 flex justify-center">
                <div className="w-full max-w-[760px]">
                  <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
                    <div className="flex-1">
                      <MarketRangeSegmentedControl
                        activeKey={range}
                        onSelect={requestRange}
                        onPickerOpenChange={(open) => {
                          setRangePickerOpen(open);
                          onTimePickerOpenChange?.(open);
                        }}
                      />

                      {/* When LIVE is active, show a second small "NOW LIVE" button under the time controls */}
                      {liveMode && (
                        <div className="mt-2 flex justify-end sm:grid sm:grid-cols-5">
                          <div className="hidden sm:block sm:col-span-4" />
                          <div className="sm:col-span-1 flex justify-end sm:justify-center">
                            <button
                              type="button"
                              className="rounded-full px-3 py-[6px] text-[11px] font-extrabold tracking-[0.12em]"
                              style={{
                                color: "rgba(255,255,255,0.98)",
                                background:
                                  "linear-gradient(180deg, rgba(34,197,94,0.30) 0%, rgba(34,197,94,0.16) 100%)",
                                border: "1px solid rgba(34,197,94,0.42)",
                                boxShadow:
                                  "0 14px 32px rgba(0,0,0,0.42), inset 0 1px 0 rgba(255,255,255,0.10)",
                                backdropFilter: "blur(14px)",
                              }}
                              aria-label="Now Live (2 sec)"
                              onClick={() => {
                                // Pick a new pattern each time (keep LIVE on + keep the line history)
                                setLivePatternIndex((p) => {
                                  const nxt = pickNextPattern(p);
                                  livePatternIndexRef.current = nxt;
                                  livePatternPhaseStartPerfRef.current =
                                    performance.now();
                                  return nxt;
                                });
                              }}
                            >
                              <span className="flex flex-col items-center leading-[1.05]">
                                <span className="inline-flex items-center gap-1.5">
                                  <span
                                    className="relative inline-flex h-2 w-2"
                                    aria-hidden
                                  >
                                    <span
                                      className="absolute inset-0 rounded-full"
                                      style={{
                                        background: "rgba(34,197,94,0.95)",
                                        animation:
                                          "liveDotPulse 1.2s ease-in-out infinite",
                                        transformOrigin: "center",
                                      }}
                                    />
                                    <span
                                      className="absolute inset-0 rounded-full"
                                      style={{
                                        background: "rgba(34,197,94,0.95)",
                                      }}
                                    />
                                  </span>
                                  NOW LIVE
                                </span>
                                <span className="mt-[2px] text-[10px] font-semibold tracking-normal text-white/80">
                                  2 sec
                                </span>
                              </span>
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>

              <div className="mb-2">
                <div className="text-[11px] leading-tight font-semibold text-white">
                  <span className="sm:hidden">PP ≈ $1 · reference only</span>
                  <span className="hidden sm:inline">
                    PP coins ≈ 1 USD (reference only, not redeemable)
                  </span>
                </div>
              </div>
              <div className="w-full">
                <div
                  ref={chartWrapRef}
                  className="relative w-full h-[165px] sm:h-[210px]"
                >
                  {/* Solid blue background across the whole chart area */}
                  <div
                    className="absolute inset-0 pointer-events-none"
                    style={{
                      backgroundColor: "rgb(8, 48, 170)",
                      opacity: 1,
                    }}
                  />
                  <svg
                    viewBox={`0 0 ${width} ${height}`}
                    className="absolute inset-0 w-full h-full touch-none select-none"
                    preserveAspectRatio="xMidYMid meet"
                    onPointerDown={(e) => {
                      if (liveMode) return;
                      if (pressTimerRef.current)
                        clearTimeout(pressTimerRef.current);
                      const clientX = e.clientX;
                      const pointerId = e.pointerId;
                      pressTimerRef.current = setTimeout(() => {
                        setIsScrubbing(true);
                        setHoverIndex(findNearestIndex(clientX));
                      }, 220);
                      try {
                        (e.currentTarget as any).setPointerCapture?.(pointerId);
                      } catch {}
                    }}
                    onPointerMove={(e) => {
                      if (!isScrubbing) return;
                      setHoverIndex(findNearestIndex(e.clientX));
                    }}
                    onPointerUp={(e) => {
                      if (pressTimerRef.current) {
                        clearTimeout(pressTimerRef.current);
                        pressTimerRef.current = null;
                      }
                      setIsScrubbing(false);
                      setHoverIndex(null);
                      try {
                        (e.currentTarget as any).releasePointerCapture?.(
                          e.pointerId,
                        );
                      } catch {}
                    }}
                    onPointerCancel={() => {
                      if (pressTimerRef.current) {
                        clearTimeout(pressTimerRef.current);
                        pressTimerRef.current = null;
                      }
                      setIsScrubbing(false);
                      setHoverIndex(null);
                    }}
                    onPointerLeave={() => {
                      if (!isScrubbing) return;
                      setIsScrubbing(false);
                      setHoverIndex(null);
                    }}
                  >
                    {" "}
                    <defs>
                      {/* Liquid-glass line glow layers (match reference) */}
                      <filter
                        id="lineGlowStrong"
                        x="-150%"
                        y="-150%"
                        width="400%"
                        height="400%"
                      >
                        <feGaussianBlur stdDeviation="7" result="blur" />
                        <feColorMatrix
                          in="blur"
                          type="matrix"
                          values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.40 0"
                          result="glow"
                        />
                        <feMerge>
                          <feMergeNode in="glow" />
                          <feMergeNode in="SourceGraphic" />
                        </feMerge>
                      </filter>

                      <filter
                        id="lineGlowSoft"
                        x="-130%"
                        y="-130%"
                        width="360%"
                        height="360%"
                      >
                        <feGaussianBlur stdDeviation="3.5" result="blur" />
                        <feColorMatrix
                          in="blur"
                          type="matrix"
                          values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.55 0"
                          result="glow"
                        />
                        <feMerge>
                          <feMergeNode in="glow" />
                          <feMergeNode in="SourceGraphic" />
                        </feMerge>
                      </filter>

                      <filter
                        id="markerShadow"
                        x="-100%"
                        y="-100%"
                        width="300%"
                        height="300%"
                      >
                        <feDropShadow
                          dx="0"
                          dy="2"
                          stdDeviation="4"
                          floodColor="#000000"
                          floodOpacity="0.45"
                        />
                      </filter>
                    </defs>
                    {/* no inner grid: line floats freely like the reference */}
                    {/* Cross-fade when switching ranges */}
                    {prevPath && (
                      <g
                        key={`prev-${fadeId}`}
                        style={{ animation: "chartFadeOut 420ms ease both" }}
                      >
                        <path
                          d={prevPath}
                          fill="none"
                          stroke="#3b82f6"
                          strokeWidth={strokeOuter}
                          strokeLinejoin="round"
                          strokeLinecap="round"
                          opacity={0.085}
                          filter="url(#lineGlowStrong)"
                        />
                        <path
                          d={prevPath}
                          fill="none"
                          stroke="#60a5fa"
                          strokeWidth={strokeMid}
                          strokeLinejoin="round"
                          strokeLinecap="round"
                          opacity={0.16}
                          filter="url(#lineGlowSoft)"
                        />
                        <path
                          d={prevPath}
                          fill="none"
                          stroke="#60a5fa"
                          strokeWidth={strokeCore}
                          strokeLinejoin="round"
                          strokeLinecap="round"
                        />
                      </g>
                    )}
                    <g key={`curr-${fadeId}`}>
                      {/* LIVE movement is handled by subtle path warping + timing pattern */}
                      {/* the line (animated on time range switch) */}
                      <path
                        d={path}
                        fill="none"
                        stroke="#3b82f6"
                        strokeWidth={strokeOuter}
                        strokeLinejoin="round"
                        strokeLinecap="round"
                        opacity={0.085}
                        filter="url(#lineGlowStrong)"
                        pathLength={1}
                        strokeDasharray={1}
                        strokeDashoffset={0}
                        style={
                          prevPath
                            ? { animation: "lineDraw 480ms ease both" }
                            : undefined
                        }
                      />
                      <path
                        d={path}
                        fill="none"
                        stroke="#60a5fa"
                        strokeWidth={strokeMid}
                        strokeLinejoin="round"
                        strokeLinecap="round"
                        opacity={0.16}
                        filter="url(#lineGlowSoft)"
                        pathLength={1}
                        strokeDasharray={1}
                        strokeDashoffset={0}
                        style={
                          prevPath
                            ? {
                                animation: "lineDraw 480ms ease both",
                                animationDelay: "35ms",
                              }
                            : undefined
                        }
                      />
                      <path
                        d={path}
                        fill="none"
                        stroke="#60a5fa"
                        strokeWidth={strokeCore}
                        strokeLinejoin="round"
                        strokeLinecap="round"
                        pathLength={1}
                        strokeDasharray={1}
                        strokeDashoffset={0}
                        style={
                          prevPath
                            ? {
                                animation: "lineDraw 480ms ease both",
                                animationDelay: "60ms",
                              }
                            : undefined
                        }
                      />
                    </g>
                    {/* always show the current (live) point */}
                    {!isScrubbing && (
                      <g>
                        <circle
                          cx={endPointClamped[0]}
                          cy={endPointClamped[1]}
                          r={12.2}
                          fill="#3b82f6"
                          opacity={0.11}
                          filter="url(#markerShadow)"
                          style={
                            liveMode
                              ? {
                                  transformOrigin: "center",
                                  transformBox: "fill-box",
                                  animation:
                                    "livePulse 1.4s ease-in-out infinite",
                                }
                              : undefined
                          }
                        />
                        <circle
                          cx={endPointClamped[0]}
                          cy={endPointClamped[1]}
                          r={7.2}
                          fill="rgba(255,255,255,0.90)"
                          opacity={0.96}
                        />
                        <circle
                          cx={endPointClamped[0]}
                          cy={endPointClamped[1]}
                          r={9.8}
                          fill="none"
                          stroke="#60a5fa"
                          strokeWidth={3.0}
                          opacity={0.8}
                        />
                      </g>
                    )}
                    {/* marker + crosshair only while scrubbing (matches reference) */}
                    {isScrubbing && (
                      <g>
                        <line
                          x1={activePointClamped[0]}
                          y1={padTop}
                          x2={activePointClamped[0]}
                          y2={height - padBottom}
                          stroke="rgba(255,255,255,0.12)"
                          strokeWidth={1}
                        />
                        <line
                          x1={leftMargin}
                          y1={activePointClamped[1]}
                          x2={leftMargin + drawWidth}
                          y2={activePointClamped[1]}
                          stroke="rgba(255,255,255,0.10)"
                          strokeWidth={1}
                        />

                        <circle
                          cx={activePointClamped[0]}
                          cy={activePointClamped[1]}
                          r={14.6}
                          fill="#3b82f6"
                          opacity={0.13}
                          filter="url(#markerShadow)"
                        />
                        <circle
                          cx={activePointClamped[0]}
                          cy={activePointClamped[1]}
                          r={8.2}
                          fill="rgba(255,255,255,0.90)"
                          opacity={0.97}
                        />
                        <circle
                          cx={activePointClamped[0]}
                          cy={activePointClamped[1]}
                          r={11.4}
                          fill="none"
                          stroke="#60a5fa"
                          strokeWidth={3.3}
                          opacity={0.92}
                        />
                      </g>
                    )}
                  </svg>
                  {isScrubbing && (
                    <div
                      className="absolute"
                      style={{
                        left: `${(tooltipX / width) * 100}%`,
                        top: `${(tooltipY / height) * 100}%`,
                        transform:
                          tooltipSide === "right"
                            ? "translateX(14px)"
                            : "translateX(calc(-100% - 14px))",
                      }}
                    >
                      <div
                        className="rounded-[20px] px-4 py-3 min-w-[160px]"
                        style={{
                          background: "rgba(0,0,0,0.28)",
                          border: "1px solid rgba(255,255,255,0.12)",
                          boxShadow:
                            "0 18px 50px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.08)",
                          backdropFilter: "blur(14px)",
                        }}
                      >
                        <div className="text-[12px] font-semibold text-white">
                          {fmtTooltipDate(resampledSeries[activeIdx]?.t)}
                        </div>
                        <div className="mt-0.5 flex items-baseline gap-2">
                          <div className="text-[20px] font-extrabold tracking-tight text-white">
                            {Number(activePrice ?? 0).toLocaleString("en-US", {
                              minimumFractionDigits: 2,
                              maximumFractionDigits: 2,
                            })}
                          </div>
                          <div className="text-[12px] font-bold tracking-wide text-white">
                            PPC
                          </div>
                        </div>
                        <div className="text-[12px] font-semibold text-white mt-0.5">
                          {pct >= 0 ? "+" : "-"}
                          {Math.abs(pct).toFixed(2)}%
                        </div>
                      </div>
                    </div>
                  )}
                  {/* x-axis labels (match the screenshot style) */}
                  {!liveMode &&
                    (() => {
                      const s = (resampledSeries ?? []) as any[];
                      if (s.length < 2) return null;
                      const ticks = [0, 0.25, 0.5, 0.75, 1].map(
                        (p) => s[Math.round(p * (s.length - 1))]?.t,
                      );

                      const fmtTick = (d: any) => {
                        try {
                          const dd = new Date(d);
                          if (range === "1H" || range === "5H") {
                            return new Intl.DateTimeFormat("en-US", {
                              hour: "numeric",
                              minute: "2-digit",
                              hour12: false,
                            }).format(dd);
                          }
                          if (range === "MAX") {
                            return new Intl.DateTimeFormat("en-US", {
                              month: "short",
                              year: "2-digit",
                            }).format(dd);
                          }
                          return new Intl.DateTimeFormat("en-US", {
                            month: "short",
                            day: "numeric",
                          }).format(dd);
                        } catch {
                          return "";
                        }
                      };

                      return (
                        <div className="absolute left-0 right-0 bottom-1 sm:bottom-2 px-4 sm:px-5">
                          <div className="flex items-center justify-between text-[12px] sm:text-[14px] text-white">
                            {ticks.map((t, idx) => (
                              <span key={idx} className="tabular-nums">
                                {fmtTick(t)}
                              </span>
                            ))}
                          </div>
                        </div>
                      );
                    })()}
                </div>
              </div>

              <div className="mt-3 sm:mt-5 flex items-end justify-between gap-3 sm:gap-4 px-1">
                <div>
                  <div className="text-[12px] sm:text-[14px] text-white">
                    {range === "1H"
                      ? "24h avg"
                      : range === "5H"
                        ? "Weekly avg"
                        : range === "1W"
                          ? "Monthly avg"
                          : range === "1MO"
                            ? "Yearly avg"
                            : "All‑time avg"}
                  </div>
                  <div className="mt-1 flex items-end gap-2">
                    <div
                      className="text-[28px] sm:text-[34px] leading-none font-extrabold tracking-tight text-white tabular-nums"
                      style={{ textShadow: "0 10px 28px rgba(0,0,0,0.55)" }}
                    >
                      {Number(averagePrice ?? 0).toLocaleString("en-US", {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2,
                      })}
                    </div>
                    <div className="mb-[3px] text-[13px] font-bold tracking-wide text-white">
                      PPC
                    </div>
                    <div className="mb-[2px] text-white text-[16px] sm:text-[18px] font-bold">
                      ↗
                    </div>
                  </div>
                </div>

                <button
                  type="button"
                  className="hidden sm:flex items-center gap-2 text-[16px] font-semibold text-white hover:text-white"
                  onClick={() => navigate("/general#pp15-how-it-works")}
                >
                  <span className="inline-flex h-7 w-7 items-center justify-center rounded-full border border-white/15 bg-white/8 text-white">
                    ?
                  </span>
                  How it works?
                </button>
              </div>
            </CardContent>
          </Card>
        );
      },
    [],
  );

  const { t } = useLang();
  const auth = useAuth();
  const isGuest = useIsGuest();
  const supa = useSupabase();
  const accessToken =
    supa.accessToken ?? (window as any).__supaAccessToken ?? undefined;

  // Speed up first paint: show last known market snapshot instantly (if available)
  // while fresh data loads in the background.
  const marketPlaceholder = React.useMemo(() => {
    try {
      if (typeof window === "undefined") return undefined;
      const raw = window.localStorage.getItem("pp15_market_cache_v1");
      if (!raw) return undefined;
      const parsed = JSON.parse(raw) as {
        ts?: number;
        data?: MarketOutput;
      };
      const ts = Number(parsed?.ts ?? 0);
      if (!ts || Date.now() - ts > 5 * 60_000) return undefined;
      return parsed?.data;
    } catch {
      return undefined;
    }
  }, []);

  const {
    data: market,
    isInitialLoading: marketInitialLoading,
    isFetching: marketIsFetching,
    isError: marketError,
    refetch: refetchMarket,
  } = useQuery<MarketOutput>(["market"], () => apiClient.getMarket(), {
    placeholderData: marketPlaceholder,
    // Keep this lightweight: realtime updates handle “live” changes.
    // Reduce polling to lower battery/network usage and improve responsiveness.
    staleTime: suspendMarketPolling ? 20_000 : 15_000,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
    refetchInterval: suspendMarketPolling ? false : 15_000,
    refetchIntervalInBackground: false,
    retry: 0,
    onSuccess: (data) => {
      try {
        if (typeof window === "undefined") return;
        window.localStorage.setItem(
          "pp15_market_cache_v1",
          JSON.stringify({ ts: Date.now(), data }),
        );
      } catch {}
    },
  });

  const { data: marketStats } = useQuery<MarketStatsOutput>(
    ["marketStats"],
    () => apiClient.getMarketStats(),
    {
      staleTime: suspendMarketPolling ? 20_000 : 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchInterval: suspendMarketPolling ? false : 15_000,
      refetchIntervalInBackground: false,
      retry: 0,
    },
  );
  // No profile query needed for admin check; demo button is visible to everyone

  // Apple Pay and fixed amounts removed.
  // Demo-Aufladung entfernt.
  const [rtMarket, setRtMarket] = useRealtimeStore("market", {
    price: market?.pricePerM2CHF ?? 0,
    availableSupplyM2: market?.availableSupplyM2 ?? 0,
    cumulativeSoldM2: market?.cumulativeSoldM2 ?? 0,
  });
  const [mapRT] = useRealtimeStore("map", { ts: 0, changes: [] as any[] });
  const [secondaryRT] = useRealtimeStore("secondary", { ts: 0 as any });

  const { data: portfolio } = useQuery<PortfolioOutput>(
    ["portfolio", accessToken],
    () => apiClient.getPortfolio({ accessToken } as any),
    {
      enabled: auth.status === "authenticated" && !!accessToken && !isGuest,
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      retry: 0,
    },
  );
  const [buyM2, setBuyM2] = useState<string>("");
  // Ensure realtime market reflects initial fetch result (otherwise stays 0 until first broadcast)
  useEffect(() => {
    if (market) {
      setRtMarket({
        price: market.pricePerM2CHF,
        availableSupplyM2: market.availableSupplyM2,
        cumulativeSoldM2: market.cumulativeSoldM2,
      });
    }
  }, [
    market?.pricePerM2CHF,
    market?.availableSupplyM2,
    market?.cumulativeSoldM2,
  ]);
  const [sellM2, setSellM2] = useState<string>("");
  // Demo-Aufladungszustand entfernt (nur noch Admin-Button + echte Kaufseite)
  const [debouncedBuy, setDebouncedBuy] = useState<number>(0);
  const [debouncedSell, setDebouncedSell] = useState<number>(0);
  useEffect(() => {
    const id = window.setTimeout(
      () => setDebouncedBuy(Number(buyM2 || 0)),
      300,
    );
    return () => window.clearTimeout(id);
  }, [buyM2]);
  useEffect(() => {
    const id = window.setTimeout(
      () => setDebouncedSell(Number(sellM2 || 0)),
      300,
    );
    return () => window.clearTimeout(id);
  }, [sellM2]);

  // Live activity ping logic (m², house builds, 2nd market)
  const [blinkEnabled, setBlinkEnabled] = useState<boolean>(() => {
    try {
      const v = localStorage.getItem("blinkEnabled");
      return v === null ? true : v === "1";
    } catch {
      return true;
    }
  });
  useEffect(() => {
    try {
      localStorage.setItem("blinkEnabled", blinkEnabled ? "1" : "0");
    } catch {}
  }, [blinkEnabled]);
  const [flashAt, setFlashAt] = useState<{
    m2: number;
    house: number;
    second: number;
  }>({ m2: 0, house: 0, second: 0 });
  const lastMarketValuesRef = useRef<{ price?: number; sold?: number } | null>(
    null,
  );

  // Blink on market deltas (covers primary buys/sells and non-map buys)
  useEffect(() => {
    const prev = lastMarketValuesRef.current;
    const pChanged =
      prev &&
      (prev.price !== rtMarket?.price ||
        prev.sold !== rtMarket?.cumulativeSoldM2);
    if (prev && pChanged) {
      setFlashAt((f) => ({ ...f, m2: Date.now() }));
    }
    lastMarketValuesRef.current = {
      price: rtMarket?.price,
      sold: rtMarket?.cumulativeSoldM2,
    };
  }, [rtMarket?.price, rtMarket?.cumulativeSoldM2]);

  // Blink on map changes (m² ownership or houses)
  useEffect(() => {
    if (!mapRT || !mapRT.changes || !(mapRT as any).ts) return;
    const changes: Array<{
      ownerId?: string | null;
      houseType?: string | null;
    }> = (mapRT as any).changes || [];
    let m2Hit = false;
    let houseHit = false;
    for (const c of changes) {
      if (typeof c.ownerId !== "undefined") m2Hit = true;
      if (c.houseType && c.houseType !== "NONE") houseHit = true;
      if (m2Hit && houseHit) break;
    }
    if (m2Hit) setFlashAt((f) => ({ ...f, m2: Date.now() }));
    if (houseHit) setFlashAt((f) => ({ ...f, house: Date.now() }));
  }, [(mapRT as any)?.ts]);

  // Blink on secondary events (listed / sold / cancel)
  useEffect(() => {
    if (!secondaryRT || !(secondaryRT as any).ts) return;
    setFlashAt((f) => ({ ...f, second: Date.now() }));
  }, [(secondaryRT as any)?.ts]);

  const isFlashing = (ts: number) => ts && Date.now() - ts < 500;

  const {
    data: buySim,
    isError: buySimError,
    refetch: refetchBuySim,
  } = useQuery<SimBuyOutput>(
    ["buySim", debouncedBuy],
    () => apiClient.simulateBuyCost({ m2: debouncedBuy }),
    {
      enabled: debouncedBuy > 0,
      retry: 1,
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
    },
  );
  const {
    data: sellSim,
    isError: sellSimError,
    refetch: refetchSellSim,
  } = useQuery<SimSellOutput>(
    ["sellSim", debouncedSell],
    () => apiClient.simulateSellProceeds({ m2: debouncedSell }),
    {
      enabled: debouncedSell > 0,
      retry: 1,
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
    },
  );

  /* Quick sell now routes to map for plot selection */

  const navigate = useNavigate();
  void navigate;
  const goBuyOnMap = (qty: number) => {
    if (!Number.isFinite(qty) || qty < 1) {
      console.log("Nav blocked: invalid buy qty", { qty });
      return;
    }
    try {
      navigate(`/map?buy=${qty}`);
    } catch (e) {
      console.log("Nav info (buy)", e);
    }
  };
  // Instant sell in the market — map selling remains available via the Map screen.
  // goSellOnMap removed because the market button sells directly now.

  // Keep the fetch alive in the background, but don't show a full-screen loader.
  void marketInitialLoading;
  void marketIsFetching;

  return (
    <ScreenContainer title={t("market")}>
      <div className="mt-3 sm:mt-4 grid gap-3 sm:gap-4 text-white">
        {" "}
        {/* Market quick stats + chart (merged) */}
        <div className="grid gap-0">
          <Card
            className="hidden sm:block market-force-white relative mx-auto w-full max-w-[760px] overflow-hidden rounded-[34px] rounded-b-none border border-white/10 border-b-0 bg-transparent text-white shadow-[0_28px_90px_rgba(0,0,0,0.72)]"
            style={{
              backgroundColor: "rgb(8, 48, 170)",
            }}
          >
            <div
              className="absolute inset-0 pointer-events-none"
              style={{
                backgroundColor: "rgb(8, 48, 170)",
              }}
            />
            <CardContent className="relative z-10 px-3 py-2 sm:px-4 sm:py-2.5">
              <TooltipProvider>
                <div className="grid grid-cols-4 divide-x divide-white/10">
                  {(
                    [
                      {
                        label: "Supply",
                        info: "How many m² are still available right now.",
                        value: Number(
                          marketStats?.availableSupplyM2 ??
                            rtMarket?.availableSupplyM2 ??
                            market?.availableSupplyM2 ??
                            0,
                        ).toLocaleString("en-US"),
                        suffix: "m²",
                      },
                      {
                        label: "Liquidity",
                        info: "How much PPC liquidity is currently in the market.",
                        value: Number(
                          marketStats?.liquidityPPC ?? 0,
                        ).toLocaleString("en-US", {
                          minimumFractionDigits: 0,
                          maximumFractionDigits: 0,
                        }),
                        suffix: "PPC",
                      },
                      {
                        label: "Volume",
                        info: "Trading volume over the last 24 hours (in PPC).",
                        value: Number(
                          marketStats?.volume24hPPC ?? 0,
                        ).toLocaleString("en-US", {
                          minimumFractionDigits: 0,
                          maximumFractionDigits: 0,
                        }),
                        suffix: "PPC",
                        sub: "24h",
                      },
                      {
                        label: "ATH",
                        info: "All-time high: the highest m² price ever reached.",
                        value: Number(
                          marketStats?.athPricePerM2PPC ??
                            market?.pricePerM2CHF ??
                            0,
                        ).toLocaleString("en-US", {
                          minimumFractionDigits: 2,
                          maximumFractionDigits: 2,
                        }),
                        suffix: "PPC",
                        sub: "per m²",
                      },
                    ] as const
                  ).map((it) => (
                    <div key={it.label} className="px-2 py-1.5 sm:px-3 sm:py-2">
                      <div className="flex items-center gap-1 text-[10px] sm:text-[11px] font-extrabold tracking-wide text-white/70">
                        <span>{it.label}</span>
                        {(it as any).info ? (
                          <Popover>
                            <PopoverTrigger asChild>
                              <button
                                type="button"
                                className="ml-0.5 inline-flex h-4 w-4 items-center justify-center rounded-full text-white/60 hover:text-white/85"
                                aria-label={`Info: ${it.label}`}
                                onClick={(e) => e.stopPropagation()}
                              >
                                <Info className="h-3.5 w-3.5" />
                              </button>
                            </PopoverTrigger>
                            <PopoverContent
                              className="max-w-[240px]"
                              side="bottom"
                            >
                              <div className="text-xs leading-snug">
                                {(it as any).info}
                              </div>
                            </PopoverContent>
                          </Popover>
                        ) : null}
                      </div>
                      <div className="mt-0.5 flex items-baseline gap-1">
                        <div className="text-[13px] sm:text-[15px] font-extrabold tracking-tight text-white tabular-nums">
                          {it.value}
                        </div>
                        <div className="text-[10px] sm:text-[11px] font-bold text-white/80">
                          {it.suffix}
                        </div>
                        {(it as any).sub ? (
                          <div className="ml-1 text-[10px] font-semibold text-white/55">
                            {(it as any).sub}
                          </div>
                        ) : null}
                      </div>
                    </div>
                  ))}
                </div>
              </TooltipProvider>
            </CardContent>
          </Card>
          <InlineMarketChart
            marketNow={
              market
                ? ({
                    ...market,
                    pricePerM2CHF: rtMarket?.price ?? market.pricePerM2CHF,
                  } as any)
                : rtMarket?.price
                  ? ({ pricePerM2CHF: rtMarket.price } as any)
                  : undefined
            }
            range={chartRange}
            onRangeChange={setChartRange}
            onTimePickerOpenChange={setSuspendMarketPolling}
            enabled={chartReady}
            mergeTop={true}
          />

          {/* iPhone: infos under the chart, expandable */}
          <div className="sm:hidden mx-auto w-full max-w-[760px]">
            <div
              className="mt-2 overflow-hidden rounded-[26px] border border-white/10 shadow-[0_18px_60px_rgba(0,0,0,0.55)]"
              style={{ backgroundColor: "rgb(8, 48, 170)" }}
            >
              <button
                type="button"
                className="w-full h-11 px-4 flex items-center justify-between text-white"
                onClick={() => setMobileMarketInfosOpen((v) => !v)}
                aria-expanded={mobileMarketInfosOpen}
              >
                <span className="text-[13px] font-extrabold tracking-wide">
                  {mobileMarketInfosOpen ? "Hide infos" : "Show infos"}
                </span>
                <ChevronDown
                  className={
                    "h-4 w-4 text-white/85 transition-transform " +
                    (mobileMarketInfosOpen ? "rotate-180" : "")
                  }
                />
              </button>

              {mobileMarketInfosOpen && (
                <div className="px-4 pb-2">
                  <div className="divide-y divide-white/10">
                    {(
                      [
                        {
                          label: "Supply",
                          info: "How many m² are still available right now.",
                          value: Number(
                            marketStats?.availableSupplyM2 ??
                              rtMarket?.availableSupplyM2 ??
                              market?.availableSupplyM2 ??
                              0,
                          ).toLocaleString("en-US"),
                          suffix: "m²",
                        },
                        {
                          label: "Liquidity",
                          info: "How much PPC liquidity is currently in the market.",
                          value: Number(
                            marketStats?.liquidityPPC ?? 0,
                          ).toLocaleString("en-US", {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0,
                          }),
                          suffix: "PPC",
                        },
                        {
                          label: "Volume",
                          info: "Trading volume over the last 24 hours (in PPC).",
                          value: Number(
                            marketStats?.volume24hPPC ?? 0,
                          ).toLocaleString("en-US", {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0,
                          }),
                          suffix: "PPC",
                          sub: "24h",
                        },
                        {
                          label: "ATH",
                          info: "All-time high: the highest m² price ever reached.",
                          value: Number(
                            marketStats?.athPricePerM2PPC ??
                              market?.pricePerM2CHF ??
                              0,
                          ).toLocaleString("en-US", {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2,
                          }),
                          suffix: "PPC",
                          sub: "per m²",
                        },
                      ] as const
                    ).map((it) => (
                      <div key={it.label} className="py-2">
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-1.5 text-[11px] font-extrabold tracking-wide text-white/70">
                            <span>{it.label}</span>
                            {(it as any).info ? (
                              <Popover>
                                <PopoverTrigger asChild>
                                  <button
                                    type="button"
                                    className="inline-flex h-5 w-5 items-center justify-center rounded-full text-white/60 hover:text-white/85"
                                    aria-label={`Info: ${it.label}`}
                                    onClick={(e) => e.stopPropagation()}
                                  >
                                    <Info className="h-4 w-4" />
                                  </button>
                                </PopoverTrigger>
                                <PopoverContent
                                  className="max-w-[240px]"
                                  side="bottom"
                                >
                                  <div className="text-xs leading-snug">
                                    {(it as any).info}
                                  </div>
                                </PopoverContent>
                              </Popover>
                            ) : null}
                          </div>
                          {(it as any).sub ? (
                            <div className="text-[11px] font-semibold text-white/55">
                              {(it as any).sub}
                            </div>
                          ) : null}
                        </div>
                        <div className="mt-0.5 flex items-baseline justify-between gap-3">
                          <div className="text-[16px] font-extrabold tracking-tight text-white tabular-nums">
                            {it.value}
                          </div>
                          <div className="text-[11px] font-bold text-white/80">
                            {it.suffix}
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>{" "}
        {/* Live activity mini-bar */}
        <div className="hidden flex items-center justify-between gap-3 my-2">
          <div className="flex items-center gap-2 w-full">
            <div
              className="flex-1 rounded-md border bg-card px-3 py-2 text-xs flex items-center justify-between neon-green"
              style={{
                animation:
                  blinkEnabled && isFlashing(flashAt.m2)
                    ? "neon-blink 0.8s ease-out, shake-quick 0.36s ease-in-out"
                    : undefined,
              }}
            >
              <span className="font-medium">m²</span>
              <span className="text-white">Primary</span>
            </div>
            <div
              className="flex-1 rounded-md border bg-card px-3 py-2 text-xs flex items-center justify-between neon-violet"
              style={{
                animation:
                  blinkEnabled && isFlashing(flashAt.house)
                    ? "neon-blink 0.8s ease-out, shake-quick 0.36s ease-in-out"
                    : undefined,
              }}
            >
              <span className="font-medium">House</span>
              <span className="text-white">Basic • Villa • Mansion</span>
            </div>
            <div
              className="flex-1 rounded-md border bg-card px-3 py-2 text-xs flex flex-col items-center justify-center text-center neon-cyan"
              style={{
                animation:
                  blinkEnabled && isFlashing(flashAt.second)
                    ? "neon-blink 0.8s ease-out, shake-quick 0.36s ease-in-out"
                    : undefined,
              }}
            >
              <span className="font-medium">2nd Market</span>
              <span className="text-white">Buy/Sell</span>
            </div>
          </div>
          <Button
            variant="secondary"
            size="sm"
            onClick={() => setBlinkEnabled((v) => !v)}
            aria-label={
              blinkEnabled ? "Disable live blink" : "Enable live blink"
            }
          >
            {blinkEnabled ? "Blink off" : "Blink on"}
          </Button>
        </div>
        {/* Top up: blue pill button */}
        <div className="w-full flex flex-col items-center justify-center gap-1.5 sm:gap-2">
          {" "}
          <Button
            onClick={() => {
              if (isGuest) {
                try {
                  window.dispatchEvent(new Event("openSignIn"));
                } catch {}
                return;
              }
              setTopupOpen(true);
            }}
            className="rounded-full bg-primary text-primary-foreground hover:bg-primary/90 px-8 sm:px-10 py-3 sm:py-5 text-sm sm:text-base font-extrabold tracking-wide shadow-md"
          >
            ADD PP COINS
          </Button>
          <div className="hidden sm:block text-xs text-white text-center">
            {t("secureRedirectNote")}
          </div>
          <Dialog open={topupOpen} onOpenChange={setTopupOpen}>
            <DialogContent className="w-[calc(100vw-12px)] max-w-[420px] p-0 border-0 bg-transparent shadow-none overflow-visible">
              <DialogHeader className="sr-only">
                <DialogTitle>Add PP coins</DialogTitle>
                <DialogDescription>Top up PP coins</DialogDescription>
              </DialogHeader>
              <div
                className="relative overflow-hidden rounded-[16px] border shadow-[0_12px_48px_rgba(0,0,0,0.45)] min-h-[290px] sm:min-h-[280px] max-h-[68vh] flex flex-col text-primary-foreground"
                style={{
                  backgroundColor: "hsl(var(--primary))",
                  borderColor: "rgba(255,255,255,0.18)",
                }}
              >
                <div className="relative p-2.5 sm:p-3 flex-1 flex flex-col">
                  <div className="flex items-start justify-between gap-4">
                    <div className="min-w-0">
                      <div className="flex items-center gap-2">
                        <div
                          className="inline-flex h-8 w-8 items-center justify-center rounded-full border"
                          style={{
                            backgroundColor: "rgba(255,255,255,0.12)",
                            borderColor: "rgba(255,255,255,0.22)",
                          }}
                          aria-hidden
                        >
                          <CoinIcon className="h-4 w-4" />
                        </div>
                        <div className="text-xs font-extrabold tracking-wide opacity-80">
                          ADD PP COINS
                        </div>
                      </div>
                      <div className="mt-1.5 text-[20px] sm:text-[22px] font-extrabold tracking-tight leading-tight">
                        Add PP coins
                      </div>
                      <div className="mt-1 text-[11px] sm:text-xs font-semibold opacity-75">
                        PP coins ≈ 1 USD (reference only, not redeemable)
                      </div>
                    </div>

                    <DialogClose asChild>
                      <button
                        type="button"
                        className="shrink-0 rounded-full border p-1.5 hover:opacity-90"
                        style={{
                          backgroundColor: "rgba(255,255,255,0.12)",
                          borderColor: "rgba(255,255,255,0.22)",
                        }}
                        aria-label="Close"
                      >
                        <X className="h-3.5 w-3.5" />
                      </button>
                    </DialogClose>
                  </div>

                  <div
                    className="mt-3 rounded-[16px] border p-3 sm:p-4 flex-1 relative overflow-hidden"
                    style={{
                      backgroundColor: "rgba(255,255,255,0.08)",
                      borderColor: "rgba(255,255,255,0.16)",
                    }}
                  >
                    <div className="relative">
                      <PPCoinTopup
                        variant="inline"
                        amountUnit="PPc"
                        confirmLabel="CONFIRM"
                        showFx={false}
                        uiStyle="tour"
                        onClose={() => setTopupOpen(false)}
                      />
                    </div>
                  </div>
                </div>
              </div>
            </DialogContent>
          </Dialog>
        </div>
        {/* Quick Buy navigation button: goes to its own page */}
        <div className="mt-2 sm:mt-3 w-full flex flex-col items-center justify-center gap-2 sm:gap-3 sm:flex-row sm:justify-center">
          <Button
            onClick={() => {
              if (isGuest) {
                try {
                  window.dispatchEvent(new Event("openSignIn"));
                } catch {}
                return;
              }
              navigate("/quick-buy");
            }}
            className="rounded-full bg-primary text-primary-foreground hover:bg-primary/90 px-4 sm:px-8 py-3 sm:py-4 text-sm sm:text-base font-extrabold tracking-wide shadow-md w-[48%] max-w-[190px] sm:w-auto"
          >
            QUICK BUY
          </Button>
          <Button
            onClick={() => {
              if (isGuest) {
                try {
                  window.dispatchEvent(new Event("openSignIn"));
                } catch {}
                return;
              }
              navigate("/quick-sell");
            }}
            className="rounded-full bg-primary text-primary-foreground hover:bg-primary/90 px-4 sm:px-8 py-3 sm:py-4 text-sm sm:text-base font-extrabold tracking-wide shadow-md w-[48%] max-w-[190px] sm:w-auto"
          >
            QUICK SELL
          </Button>
        </div>
        {/* Ehemalige Apple‑Pay‑Sektion: jetzt Echtgeld-Aufladung per Kaufseite */}
        {marketError && (
          <Alert>
            <AlertDescription className="text-sm">
              {t("priceLoadError")}
              <Button
                className="ml-2"
                size="sm"
                variant="secondary"
                onClick={() => refetchMarket()}
              >
                Reload
              </Button>
            </AlertDescription>
          </Alert>
        )}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-base">{t("buy")}</CardTitle>
          </CardHeader>
          <CardContent className="grid gap-3">
            <div className="grid grid-cols-3 items-center gap-3">
              <Label className="col-span-1">{t("amount")}</Label>
              <Input
                type="tel"
                inputMode="numeric"
                pattern="[0-9]*"
                value={buyM2}
                onChange={(e) => setBuyM2(e.target.value.replace(/\D+/g, ""))}
                placeholder="e.g. 1000"
                className="col-span-2"
              />
            </div>
            <div className="text-sm text-white">
              Cost preview:{" "}
              <span className="font-medium">
                {`${(buySim?.totalCostCHF ?? 0).toFixed(2)} PPC`}{" "}
              </span>
              {buySim?.clampedM2 &&
              buyM2 &&
              Number(buyM2) > buySim.clampedM2 ? (
                <span className="ml-2 text-destructive">
                  (limited to available amount)
                </span>
              ) : null}
              {buySimError && (
                <span className="ml-2">
                  Preview failed.
                  <Button
                    size="sm"
                    variant="secondary"
                    className="ml-2"
                    onClick={() => refetchBuySim()}
                  >
                    {t("reload")}
                  </Button>
                </span>
              )}
            </div>
            <Button
              className="w-[88%] sm:w-[420px] mx-auto bg-primary text-primary-foreground hover:bg-primary/90 disabled:bg-primary disabled:text-primary-foreground disabled:opacity-90"
              disabled={!buyM2}
              onClick={() => {
                if (isGuest) {
                  try {
                    window.dispatchEvent(new Event("openSignIn"));
                  } catch {}
                  return;
                }
                const qty = Number(buyM2 || 0);
                if (!qty || qty < 1) return;
                goBuyOnMap(qty);
              }}
            >
              {t("buyOnMap")}
            </Button>
            <div className="text-xs text-white">
              Balance:{" "}
              <span className="font-medium">
                {`${(portfolio?.balance ?? 0).toLocaleString("de-CH", { maximumFractionDigits: 0 })} PPC`}
              </span>
            </div>
          </CardContent>
        </Card>
        {/* (Optional) Quick Sell – weiterhin ausgeblendet */}
        <Card className="hidden">
          <CardHeader className="pb-2">
            <CardTitle className="text-base">{t("quickSell")}</CardTitle>
          </CardHeader>
          <CardContent className="grid gap-3">
            <div className="grid grid-cols-3 items-center gap-3">
              <Label className="col-span-1">{t("amount")}</Label>
              <Input
                type="tel"
                inputMode="numeric"
                pattern="[0-9]*"
                value={sellM2}
                onChange={(e) => setSellM2(e.target.value.replace(/\D+/g, ""))}
                placeholder="e.g. 500"
                className="col-span-2"
              />
            </div>
            <div className="text-sm text-white">
              {t("gross")}:{" "}
              <span className="font-medium">
                {currencyUSD(sellSim?.grossCHF)}
              </span>{" "}
              • {t("fee")}:{" "}
              <span className="font-medium">
                {currencyUSD(sellSim?.feeCHF)}
              </span>{" "}
              • {t("net")}:{" "}
              <span className="font-medium">
                {currencyUSD(sellSim?.netCHF)}
              </span>
              {sellSimError && (
                <span className="ml-2">
                  Preview failed.
                  <Button
                    size="sm"
                    variant="secondary"
                    className="ml-2"
                    onClick={() => refetchSellSim()}
                  >
                    {t("reload")}
                  </Button>
                </span>
              )}
            </div>
            <Button
              variant="secondary"
              className="w-full"
              disabled={!sellM2}
              onClick={() => {
                const qty = Number(sellM2 || 0);
                if (!qty || qty < 1) return;
                navigate(`/quick-sell?m2=${qty}`);
              }}
            >
              {t("sellOnMap")}
            </Button>
          </CardContent>
        </Card>
      </div>
    </ScreenContainer>
  );
}

export function PriceHistoryButton_REPLACED() {
  const { t } = useLang();
  // Diagnostic: track open/close events
  const [open, setOpen] = useState(false);
  useEffect(() => {
    console.log(open ? "PriceHistory: opened" : "PriceHistory: closed");
  }, [open]);
  const [minutes, setMinutes] = useState<number>(60);
  const { data, isFetching, isError, refetch } = useQuery<PriceHistoryOutput>(
    ["priceHistory", minutes],
    () => apiClient.getPriceHistory({ minutes }),
    {
      enabled: open,
      retry: 1,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      staleTime: 60_000,
      // Polling here isn't critical; keep it light to avoid slowing down the app.
      refetchInterval: 60_000,
      refetchIntervalInBackground: false,
    },
  );

  const prices = (data ?? []).map((d) => d.price);
  const min = prices.length ? Math.min(...prices) : 0;
  const max = prices.length ? Math.max(...prices) : 0;
  const last = prices.length ? prices[prices.length - 1] : 0;
  const range = Math.max(1, max - min);

  const width = 320;
  const height = 100;
  const n = prices.length;
  const step = n > 1 ? width / (n - 1) : width;
  const path =
    n > 1
      ? "M " +
        prices
          .map((p, i) => {
            const x = i * step;
            const y = height - ((p - min) / range) * height;
            return `${x},${y}`;
          })
          .join(" L ")
      : "";

  return (
    <Drawer open={open} onOpenChange={setOpen}>
      <DrawerTrigger asChild>
        <Button variant="ghost" size="icon" aria-label="Price history">
          <TrendingUp className="h-5 w-5" />
        </Button>
      </DrawerTrigger>
      <DrawerContent>
        <DrawerHeader className="text-left">
          <DrawerTitle>{t("priceHistory")}</DrawerTitle>
          <DrawerDescription>{t("priceHistoryDesc")}</DrawerDescription>
        </DrawerHeader>
        <div className="px-4 pb-4 grid gap-3">
          <Tabs
            value={String(minutes)}
            onValueChange={(v) => setMinutes(Number(v))}
          >
            <TabsList className="grid grid-cols-3">
              <TabsTrigger value="15">{t("fifteenMin")}</TabsTrigger>
              <TabsTrigger value="60">{t("oneHour")}</TabsTrigger>
              <TabsTrigger value="1440">{t("twentyFourHours")}</TabsTrigger>
            </TabsList>
          </Tabs>

          <div className="rounded-lg border p-3">
            <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-24">
              {n < 2 ? (
                (() => {
                  const fallback = typeof last === "number" ? last : 0;
                  const y = height - ((fallback - fallback) / 1) * height;
                  return (
                    <path
                      d={`M 0,${y} L ${width},${y}`}
                      fill="none"
                      stroke="hsl(var(--muted-foreground))"
                      strokeDasharray="4 4"
                      strokeWidth="2"
                    />
                  );
                })()
              ) : (
                <path
                  d={path}
                  fill="none"
                  stroke="hsl(var(--primary))"
                  strokeWidth="2"
                />
              )}
            </svg>
            <div className="mt-2 grid grid-cols-3 text-xs">
              <div className="text-muted-foreground">{t("minLabel")}</div>
              <div className="text-muted-foreground text-center">
                {t("maxLabel")}
              </div>
              <div className="text-muted-foreground text-right">
                {t("lastLabel")}
              </div>
              <div className="font-medium">{currencyUSD(min || last)}</div>
              <div className="font-medium text-center">
                {currencyUSD(max || last)}
              </div>
              <div className="font-medium text-right">{currencyUSD(last)}</div>
            </div>
          </div>

          {isError && (
            <Alert className="mt-2">
              <AlertDescription className="text-xs">
                {t("priceHistoryLoadError")}{" "}
                <Button
                  size="sm"
                  variant="secondary"
                  className="ml-2"
                  onClick={() => refetch()}
                >
                  Reload
                </Button>
              </AlertDescription>
            </Alert>
          )}
          {isFetching && (
            <div className="text-xs text-muted-foreground">Refreshing…</div>
          )}
        </div>
        <DrawerFooter className="pt-2">
          <Button variant="secondary" onClick={() => setOpen(false)}>
            Close
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function SettingsButton() {
  const { t, setLang } = useLang();
  const isGuest = useIsGuest();
  const navigate = useNavigate();
  const [open, setOpen] = useState(false);
  const presets = [
    { key: "blue", name: "Blue", primary: "221 83% 53%", ring: "221 83% 53%" },
    {
      key: "teal",
      name: "Turquoise",
      primary: "180 76% 40%",
      ring: "180 76% 40%",
    },
    {
      key: "violet",
      name: "Violet",
      primary: "262 83% 57%",
      ring: "262 83% 57%",
    },
  ] as const;
  const [selected, setSelected] = useState<"blue" | "teal" | "violet">("blue");

  useEffect(() => {
    const p = presets.find((x) => x.key === selected) ?? presets[0]!;
    const root = document.documentElement;
    root.style.setProperty("--primary", p.primary);
    root.style.setProperty("--ring", p.ring);
  }, [selected]);

  // Expose global open/close helpers so other UI (e.g., profile menu) can open Settings
  useEffect(() => {
    const open = () => setOpen(true);
    const close = () => setOpen(false);
    (window as any).__openSettings = open;
    (window as any).__closeSettings = close;
    const evtHandler = () => setOpen(true);
    window.addEventListener("openSettings", evtHandler as any);
    return () => {
      try {
        delete (window as any).__openSettings;
        delete (window as any).__closeSettings;
      } catch {}
      window.removeEventListener("openSettings", evtHandler as any);
    };
  }, []);

  const { toast } = useToast();
  const queryClient = useQueryClient();
  const supa = useSupabase();
  const accessToken = supa.accessToken ?? undefined;

  const { data: profile } = useQuery<GetProfileOutput>(
    ["profile", open, accessToken ?? null],
    () =>
      accessToken
        ? apiClient.getProfile({ accessToken })
        : apiClient.getProfile(),
    { enabled: open },
  );

  const [name, setName] = useState("");
  const [avatarPreview, setAvatarPreview] = useState<string | null>(null);

  useEffect(() => {
    if (open) {
      setName(profile?.displayName ?? "");
      setAvatarPreview(profile?.profileImageUrl ?? null);
      const preset = (profile as any)?.themePreset ?? "blue";
      setSelected(preset);
      // ensure UI theme reflects current preset immediately when opening
      applyThemePreset();
    }
  }, [
    open,
    profile?.displayName,
    profile?.profileImageUrl,
    (profile as any)?.themePreset,
  ]);

  const updateMutation = useMutation(apiClient.updateProfile, {
    onSuccess: async () => {
      toast({ title: t("profileUpdated") });
      await queryClient.invalidateQueries(["profile"]);
    },
    onError: (e: any) =>
      toast({
        title: t("saveFailed"),
        description: e?.message ?? "Unknown error",
      }),
  });

  return (
    <Drawer open={open} onOpenChange={setOpen}>
      <DrawerTrigger asChild>
        <Button variant="ghost" size="icon" aria-label={t("settings")}>
          <Settings className="h-5 w-5" />
        </Button>
      </DrawerTrigger>
      <DrawerContent>
        <DrawerHeader className="text-left">
          <DrawerTitle>{t("settings")}</DrawerTitle>
          <DrawerDescription>{t("settingsDesc")}</DrawerDescription>
        </DrawerHeader>

        {isGuest && (
          <div className="px-4">
            <Alert className="mb-3">
              <AlertTitle>Guest preview</AlertTitle>
              <AlertDescription>
                You can look around, but changing settings requires sign-in.
                <div className="mt-3">
                  <Button
                    size="sm"
                    onClick={() =>
                      window.dispatchEvent(new Event("openSignIn"))
                    }
                  >
                    Sign in
                  </Button>
                </div>
              </AlertDescription>
            </Alert>
          </div>
        )}

        <div className="max-h-[70vh] overflow-y-auto touch-pan-y px-0">
          <div className="px-4 pb-4 grid gap-5 text-sm">
            <div>
              <div className="text-xs uppercase tracking-wide text-muted-foreground mb-2">
                {t("profile")}
              </div>
              <div className="flex items-center gap-3 mb-3">
                <Avatar>
                  <AvatarImage src={avatarPreview ?? undefined} />
                  <AvatarFallback
                    className="text-transparent"
                    style={_avatarGradientStyle(
                      name || profile?.displayName || "user",
                    )}
                  >
                    <span className="sr-only">
                      {name || profile?.displayName || "User"}
                    </span>
                  </AvatarFallback>
                </Avatar>
                <div className="text-sm font-medium">
                  {name || profile?.displayName || "—"}
                </div>
              </div>
              <Button
                onClick={() => {
                  if (isGuest) {
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                  }
                  navigate("/profile");
                }}
              >
                Profile
              </Button>
              <div className="text-xs text-muted-foreground mt-2">
                You can view the profile page anytime. To edit your profile,
                please sign in.
              </div>
            </div>

            <div>
              <div className="text-xs uppercase tracking-wide text-muted-foreground mb-2">
                {t("languageLabel")}
              </div>{" "}
              <div className="grid grid-cols-3 gap-2">
                {(["de", "en", "es"] as const).map((code) => (
                  <Button
                    key={code}
                    variant={
                      profile?.language === code ? "default" : "secondary"
                    }
                    onClick={() => {
                      if (isGuest) {
                        try {
                          window.dispatchEvent(new Event("openSignIn"));
                        } catch {}
                        return;
                      }
                      setLang(code);
                      updateMutation.mutate({
                        language: code,
                        ...(accessToken ? { accessToken } : {}),
                      });
                    }}
                  >
                    {code === "de"
                      ? "German"
                      : code === "en"
                        ? "English"
                        : "Spanish"}
                  </Button>
                ))}
              </div>
            </div>

            {/* Farben sind marken-locked; kein Umschalten in der App */}
            <div className="hidden">
              <div className="text-xs uppercase tracking-wide text-muted-foreground mb-2">
                {t("colors")}
              </div>
              <div className="grid grid-cols-3 gap-2" />
            </div>
          </div>
          {/* Top-Up Section */}
          <div className="px-4 pb-5">
            <div className="text-xs uppercase tracking-wide text-muted-foreground mb-2">
              {t("topupTitle")}
            </div>
            <div className="rounded-xl border bg-card p-4 text-center">
              <div className="text-base font-semibold tracking-tight">
                PP coins ≈ 1 USD
              </div>
            </div>
          </div>
          {/* Admin & Payout sections removed */}
          <div className="hidden px-4 pb-5" />
        </div>

        <DrawerFooter className="pt-2">
          {" "}
          <Button variant="secondary" onClick={() => setOpen(false)}>
            Close
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );
}

export function formatDateDDMMYY(d?: Date | string) {
  // legacy helper kept for compatibility

  if (!d) return "";
  const dt = new Date(d);
  const dd = String(dt.getDate()).padStart(2, "0");
  const mm = String(dt.getMonth() + 1).padStart(2, "0");
  const yy = String(dt.getFullYear()).slice(-2);
  return `${dd}.${mm}.${yy}`;
}

export function formatDateTime(d?: Date | string) {
  if (!d) return "";
  const dt = new Date(d);
  const dd = String(dt.getDate()).padStart(2, "0");
  const mm = String(dt.getMonth() + 1).padStart(2, "0");
  const yy = String(dt.getFullYear()).slice(-2);
  const hh = String(dt.getHours()).padStart(2, "0");
  const min = String(dt.getMinutes()).padStart(2, "0");
  return `${dd}.${mm}.${yy} ${hh}:${min}`;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function CertificateViewer() {
  const { t } = useLang();
  const [open, setOpen] = useState(false);
  const { data, isFetching } = useQuery(
    ["certificates", open],
    () => Promise.resolve([]),
    { enabled: open, keepPreviousData: true, refetchOnWindowFocus: false },
  );
  const { data: mkt } = useQuery<MarketOutput>(
    ["market", open, "certificateTemplate"],
    () => apiClient.getMarket(),
    { enabled: open },
  );
  const templateUrl = mkt?.certificateTemplateUrl ?? null;
  const { toast } = useToast();
  const navigate = useNavigate();
  void navigate;
  const queryClient = useQueryClient();
  const uploadMutation = useMutation(
    apiClient.setCertificateTemplateFromBase64,
    {
      onSuccess: async () => {
        toast({ title: "Certificate template saved" });
        await queryClient.invalidateQueries(["market"]);
      },
      onError: (e: any) =>
        toast({ title: "Upload failed", description: e?.message }),
    },
  );

  return (
    <Drawer open={open} onOpenChange={setOpen}>
      <DrawerTrigger asChild>
        <Button variant="secondary">{t("certificates")}</Button>
      </DrawerTrigger>
      <DrawerContent>
        <DrawerHeader className="text-left relative">
          <DrawerClose asChild>
            <button
              aria-label={t("close")}
              className="absolute left-2 top-2 rounded-full p-1 hover:bg-secondary active:scale-95 transition-transform"
            >
              <X className="h-4 w-4" />
            </button>
          </DrawerClose>
          <DrawerTitle>{t("certificates")}</DrawerTitle>
          <DrawerDescription>
            One certificate per purchased m². When you sell, the matching
            certificate is selected automatically.
          </DrawerDescription>
        </DrawerHeader>
        <div className="px-4 pb-4">
          {true && (
            <div className="mb-4 p-3 border rounded text-xs flex items-center justify-between gap-3">
              <div>
                {templateUrl
                  ? "Change template: upload a PNG/JPG."
                  : "No certificate template. Upload a PNG/JPG to use your design."}{" "}
              </div>
              <Input
                type="file"
                accept="image/*"
                onChange={async (e) => {
                  const f = e.target.files?.[0];
                  if (!f) return;
                  try {
                    if (f.type === "application/pdf") {
                      toast({
                        title: "PDF not supported",
                        description:
                          "Please convert your PDF to a PNG/JPG first, then upload the image.",
                      });
                      return;
                    }

                    const base64 = await encodeFileAsBase64DataURL(f);
                    if (!base64) return;
                    uploadMutation.mutate({ base64, fileName: f.name });
                  } catch (e: any) {
                    toast({
                      title: "Upload failed",
                      description: e?.message ?? String(e),
                    });
                  }
                }}
              />{" "}
            </div>
          )}
          <div className="max-h-[70vh] overflow-y-auto pr-1">
            {isFetching && (
              <div className="text-sm text-muted-foreground">Loading…</div>
            )}
            {!isFetching && (!data || data.length === 0) && (
              <div className="text-sm text-muted-foreground">
                {t("noCertificates")}{" "}
              </div>
            )}
            <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-2 mt-2">
              {data?.map((c: any) => {
                const goToPlot = () => {
                  navigate(`/certificate/${c.id}`);
                };
                const goToMap = () => {
                  if (c?.plot) {
                    setOpen(false);
                    navigate(
                      `/map?focusX=${c.plot.x}&focusY=${c.plot.y}&certId=${c.id}`,
                    );
                    return;
                  }
                  toast({
                    title: "No location",
                    description: "This certificate has no m² coordinates yet.",
                  });
                };
                return (
                  <div key={c.id} className="relative text-left">
                    <button
                      className="w-full transition-transform active:scale-95"
                      onClick={goToPlot}
                    >
                      <AspectRatio ratio={210 / 297}>
                        <div className="absolute inset-0 border rounded-lg overflow-hidden bg-card">
                          {templateUrl ? (
                            <img
                              src={templateUrl}
                              alt="Certificate"
                              className="w-full h-full object-contain select-none pointer-events-none"
                            />
                          ) : (
                            <div className="w-full h-full flex items-center justify-center text-xs text-muted-foreground">
                              No template
                            </div>
                          )}
                          <div className="absolute left-2 bottom-2 text-[10px] px-1.5 py-0.5 rounded bg-background/80">
                            {formatDateTime(c.purchasedAt)}
                            {c.plot ? ` • (${c.plot.x},${c.plot.y})` : ""}
                          </div>
                        </div>
                      </AspectRatio>
                    </button>

                    {c?.plot && (
                      <div className="absolute right-1 top-1">
                        <Button
                          size="sm"
                          variant="secondary"
                          className="h-7 px-2 text-[11px]"
                          onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            goToMap();
                          }}
                        >
                          Show on map
                        </Button>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        </div>
        <DrawerFooter className="pt-2">
          <Button variant="secondary" onClick={() => setOpen(false)}>
            Close
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );
}

function PPLandingScreen() {
  const { data: marketCoin } = useQuery<MarketOutput>(
    ["market", "landingCoin"],
    () => apiClient.getMarket(),
    {
      enabled: false,
      // Favor fast page load: avoid constant polling that can compete with image downloads.
      // Landing doesn't need second-by-second freshness.
      staleTime: 5 * 60_000,
      refetchOnWindowFocus: false,
      refetchOnMount: false,
      refetchInterval: false,
      refetchIntervalInBackground: false,
      refetchOnReconnect: true,
    },
  );

  const { data: landingAssets } = useQuery<
    inferRPCOutputType<"getLandingAssets">
  >(["landingAssets"], () => apiClient.getLandingAssets(), {
    staleTime: 10 * 60_000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    refetchInterval: false,
    refetchIntervalInBackground: false,
    refetchOnReconnect: true,
  });
  type LandingCache = {
    hero?: string;
    bottom?: string;
    gallery?: string;
    market?: string;
    map?: string;
    islands?: string;
    secondMarket?: string;
    wallet?: string;
    selectSecondMarket?: string;
    selectWallet?: string;
    savedAt?: number;
  };

  const cachedLanding = useMemo<LandingCache | null>(() => {
    if (typeof window === "undefined") return null;
    try {
      const raw = window.localStorage.getItem("pp15_landing_cache_v1");
      if (!raw) return null;
      const parsed = JSON.parse(raw) as LandingCache;
      const safe = (u: any) =>
        typeof u === "string" && u.length > 6 ? u : undefined;

      const out: LandingCache = {
        hero: safe((parsed as any).hero),
        bottom: safe((parsed as any).bottom),
        gallery: safe((parsed as any).gallery),
        market: safe((parsed as any).market),
        map: safe((parsed as any).map),
        islands: safe((parsed as any).islands),
        secondMarket: safe((parsed as any).secondMarket),
        wallet: safe((parsed as any).wallet),
        selectSecondMarket: safe((parsed as any).selectSecondMarket),
        selectWallet: safe((parsed as any).selectWallet),
        savedAt:
          typeof (parsed as any).savedAt === "number"
            ? (parsed as any).savedAt
            : undefined,
      };

      // Ignore very old cache (e.g. if images were changed long ago).
      if (out.savedAt && Date.now() - out.savedAt > 1000 * 60 * 60 * 24 * 14) {
        return null;
      }

      const hasAny =
        !!out.hero ||
        !!out.bottom ||
        !!out.gallery ||
        !!out.market ||
        !!out.map ||
        !!out.islands ||
        !!out.secondMarket ||
        !!out.wallet ||
        !!out.selectSecondMarket ||
        !!out.selectWallet;

      return hasAny ? out : null;
    } catch {
      return null;
    }
  }, []);

  const marketHeroUrl =
    ((landingAssets as any)?.landingImageUrl as string | undefined) ?? null;
  const marketBottomUrl =
    ((landingAssets as any)?.bottomLandingImageUrl as string | undefined) ??
    null;
  const marketGalleryUrl =
    ((landingAssets as any)?.landingImageUrl5 as string | undefined) ?? null;
  const marketSectionImageUrl =
    ((landingAssets as any)?.landingImageUrl2 as string | undefined) ??
    cachedLanding?.market ??
    null;
  const secondMarketImageUrl =
    ((landingAssets as any)?.landingImageUrl3 as string | undefined) ??
    cachedLanding?.secondMarket ??
    null;
  const walletImageUrl =
    ((landingAssets as any)?.landingImageUrl4 as string | undefined) ??
    cachedLanding?.wallet ??
    null;

  const landingSelectSecondMarketImageUrl =
    ((landingAssets as any)?.landingSelectSecondMarketImageUrl as
      | string
      | undefined) ??
    cachedLanding?.selectSecondMarket ??
    null;
  const landingSelectWalletImageUrl =
    ((landingAssets as any)?.landingSelectWalletImageUrl as
      | string
      | undefined) ??
    cachedLanding?.selectWallet ??
    null;
  const islandsImageUrl =
    ((landingAssets as any)?.landingIslandsImageUrl as string | undefined) ??
    cachedLanding?.islands ??
    null;
  const mapImageUrl =
    ((landingAssets as any)?.mapBackgroundUrl as string | undefined) ??
    cachedLanding?.map ??
    null;

  const landingImageUrl = marketHeroUrl ?? cachedLanding?.hero ?? null;
  const bottomLandingImageUrl =
    marketBottomUrl ?? cachedLanding?.bottom ?? null;
  const galleryImages = [marketGalleryUrl ?? cachedLanding?.gallery].filter(
    Boolean,
  ) as string[];

  useEffect(() => {
    if (typeof window === "undefined") return;

    const payload: LandingCache = {
      hero: marketHeroUrl ?? undefined,
      bottom: marketBottomUrl ?? undefined,
      gallery: marketGalleryUrl ?? undefined,
      market:
        ((marketCoin as any)?.landingImageUrl2 as string | undefined) ??
        undefined,
      map:
        ((marketCoin as any)?.mapBackgroundUrl as string | undefined) ??
        undefined,
      islands:
        ((marketCoin as any)?.landingIslandsImageUrl as string | undefined) ??
        undefined,
      secondMarket:
        ((marketCoin as any)?.landingImageUrl3 as string | undefined) ??
        undefined,
      wallet:
        ((marketCoin as any)?.landingImageUrl4 as string | undefined) ??
        undefined,
      selectSecondMarket:
        ((marketCoin as any)?.landingSelectSecondMarketImageUrl as
          | string
          | undefined) ?? undefined,
      selectWallet:
        ((marketCoin as any)?.landingSelectWalletImageUrl as
          | string
          | undefined) ?? undefined,
      savedAt: Date.now(),
    };

    const hasAny =
      !!payload.hero ||
      !!payload.bottom ||
      !!payload.gallery ||
      !!payload.market ||
      !!payload.map ||
      !!payload.islands ||
      !!payload.secondMarket ||
      !!payload.wallet ||
      !!payload.selectSecondMarket ||
      !!payload.selectWallet;

    if (!hasAny) return;

    try {
      window.localStorage.setItem(
        "pp15_landing_cache_v1",
        JSON.stringify(payload),
      );
    } catch {
      // ignore
    }
  }, [marketCoin, marketHeroUrl, marketBottomUrl, marketGalleryUrl]);
  const [activeSection, setActiveSection] = useState<
    "market" | "map" | "islands" | "secondMarket" | "wallet"
  >("market");
  const [infoSection, setInfoSection] = useState<
    "market" | "map" | "islands" | "secondMarket" | "wallet" | null
  >(null);
  const navigate = useNavigate();
  const { t } = useLang();
  const queryClient = useQueryClient();

  // Landing page is now locked: images cannot be changed from inside the app.
  const isAdmin = false;
  const canEditSelectImages = false;

  const { toast } = useToast();

  const footerRef = useRef<HTMLElement | null>(null);
  const [showFloatingCta, setShowFloatingCta] = useState(true);

  const [flippedBenefits, setFlippedBenefits] = useState<
    Record<string, boolean>
  >({});
  const [activeBenefitId, setActiveBenefitId] = useState<string | null>(null);

  const benefitCards = useMemo(
    () =>
      [
        {
          id: "b1",
          title: "Trade when you want",
          lines: [
            "Buy virtual m².",
            "List or remove them whenever you decide.",
          ],
        },
        {
          id: "b2",
          title: "Direct user-to-user",
          lines: [
            "List in minutes.",
            "Interact directly with other users.",
            "Trades use PP coins (no real money).",
          ],
        },
        {
          id: "b3",
          title: "Start without commitment",
          lines: [
            "Create an account for free.",
            "Browse freely.",
            "Buy only if you choose to.",
          ],
        },
        {
          id: "b4",
          title: "Compare or create islands",
          lines: [
            "Each island has its own pricing.",
            "Compare existing islands or create your own.",
          ],
        },
      ] as const,
    [],
  );
  useEffect(() => {
    const onScroll = () => {
      if (typeof window === "undefined") return;

      const y = window.scrollY || 0;
      const h = window.innerHeight || 0;

      const footerEl = footerRef.current;
      const footerTop = footerEl
        ? footerEl.getBoundingClientRect().top + y
        : Number.POSITIVE_INFINITY;

      // Keep the CTA always visible, but stop once the footer text comes into view.
      const footerIsEnteringView = y + h >= footerTop - 40;
      setShowFloatingCta(!footerIsEnteringView);
    };

    onScroll();

    if (typeof window === "undefined") return;

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", onScroll);
    return () => {
      window.removeEventListener("scroll", onScroll);
      window.removeEventListener("resize", onScroll);
    };
  }, []);

  const walletTapRef = useRef<number>(0);
  const secondMarketTapRef = useRef<number>(0);
  const walletCardTapRef = useRef<number>(0);
  const secondMarketCardTapRef = useRef<number>(0);
  const heroTapRef = useRef<number>(0);
  const bottomTapRef = useRef<number>(0);

  const [selectSecondMarketPreviewUrl, setSelectSecondMarketPreviewUrl] =
    useState<string | null>(null);
  const [selectWalletPreviewUrl, setSelectWalletPreviewUrl] = useState<
    string | null
  >(null);
  const [selectSecondMarketIsSaving, setSelectSecondMarketIsSaving] =
    useState(false);
  const [selectWalletIsSaving, setSelectWalletIsSaving] = useState(false);
  const [selectSecondMarketError, setSelectSecondMarketError] = useState<
    string | null
  >(null);
  const [selectWalletError, setSelectWalletError] = useState<string | null>(
    null,
  );

  const [selectSecondMarketSavedAt, setSelectSecondMarketSavedAt] = useState<
    number | null
  >(null);
  const [selectWalletSavedAt, setSelectWalletSavedAt] = useState<number | null>(
    null,
  );

  useEffect(() => {
    if (!selectSecondMarketSavedAt) return;
    const t = window.setTimeout(() => setSelectSecondMarketSavedAt(null), 4500);
    return () => window.clearTimeout(t);
  }, [selectSecondMarketSavedAt]);

  useEffect(() => {
    if (!selectWalletSavedAt) return;
    const t = window.setTimeout(() => setSelectWalletSavedAt(null), 4500);
    return () => window.clearTimeout(t);
  }, [selectWalletSavedAt]);

  const [, setSelectSecondMarketNaturalSize] = useState<{
    w: number;
    h: number;
  } | null>(null);
  const [, setSelectWalletNaturalSize] = useState<{
    w: number;
    h: number;
  } | null>(null);

  const [heroPreviewUrl, setHeroPreviewUrl] = useState<string | null>(null);
  const [bottomPreviewUrl, setBottomPreviewUrl] = useState<string | null>(null);
  const [heroIsSaving, setHeroIsSaving] = useState(false);
  const [bottomIsSaving, setBottomIsSaving] = useState(false);
  const [heroError, setHeroError] = useState<string | null>(null);
  const [bottomError, setBottomError] = useState<string | null>(null);
  const [heroSavedAt, setHeroSavedAt] = useState<number | null>(null);
  const [bottomSavedAt, setBottomSavedAt] = useState<number | null>(null);

  const [walletCardPreviewUrl, setWalletCardPreviewUrl] = useState<
    string | null
  >(null);
  const [secondMarketCardPreviewUrl, setSecondMarketCardPreviewUrl] = useState<
    string | null
  >(null);
  const [walletCardIsSaving, setWalletCardIsSaving] = useState(false);
  const [secondMarketCardIsSaving, setSecondMarketCardIsSaving] =
    useState(false);
  const [walletCardError, setWalletCardError] = useState<string | null>(null);
  const [secondMarketCardError, setSecondMarketCardError] = useState<
    string | null
  >(null);
  const [walletCardSavedAt, setWalletCardSavedAt] = useState<number | null>(
    null,
  );
  const [secondMarketCardSavedAt, setSecondMarketCardSavedAt] = useState<
    number | null
  >(null);

  useEffect(() => {
    if (!heroSavedAt) return;
    const t = window.setTimeout(() => setHeroSavedAt(null), 4500);
    return () => window.clearTimeout(t);
  }, [heroSavedAt]);

  useEffect(() => {
    if (!bottomSavedAt) return;
    const t = window.setTimeout(() => setBottomSavedAt(null), 4500);
    return () => window.clearTimeout(t);
  }, [bottomSavedAt]);

  useEffect(() => {
    if (!walletCardSavedAt) return;
    const t = window.setTimeout(() => setWalletCardSavedAt(null), 4500);
    return () => window.clearTimeout(t);
  }, [walletCardSavedAt]);

  useEffect(() => {
    if (!secondMarketCardSavedAt) return;
    const t = window.setTimeout(() => setSecondMarketCardSavedAt(null), 4500);
    return () => window.clearTimeout(t);
  }, [secondMarketCardSavedAt]);

  const [heroImgFailed, setHeroImgFailed] = useState(false);
  const [bottomImgFailed, setBottomImgFailed] = useState(false);
  const [heroRetryBuster, setHeroRetryBuster] = useState<number>(0);
  const [bottomRetryBuster, setBottomRetryBuster] = useState<number>(0);
  const [heroRetryCount, setHeroRetryCount] = useState<number>(0);
  const [bottomRetryCount, setBottomRetryCount] = useState<number>(0);

  const [, setHeroLoaded] = useState(false);

  const [landingImgReady, setLandingImgReady] = useState<
    Record<string, boolean>
  >({});
  const markLandingImgReady = useCallback((key: string) => {
    setLandingImgReady((prev) => {
      if (prev[key]) return prev;
      return { ...prev, [key]: true };
    });
  }, []);
  const isInstantSrc = useCallback((src: string | null | undefined) => {
    if (!src) return true;
    return src.startsWith("data:") || src.startsWith("blob:");
  }, []);
  const showSkeletonFor = useCallback(
    (key: string, src: string | null | undefined) => {
      if (!src) return false;
      if (isInstantSrc(src)) return false;
      return !landingImgReady[key];
    },
    [isInstantSrc, landingImgReady],
  );

  const landingSelectPlaceholder = (title: string, subtitle: string) =>
    `data:image/svg+xml;utf8,${encodeURIComponent(
      `<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="900" viewBox="0 0 1200 900">
        <defs>
          <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#0b1220"/>
            <stop offset="1" stop-color="#111827"/>
          </linearGradient>
        </defs>
        <rect width="1200" height="900" fill="url(#g)"/>
        <rect x="60" y="60" width="1080" height="780" rx="48" fill="none" stroke="#334155" stroke-width="6"/>
        <text x="600" y="465" font-family="Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial" font-size="72" font-weight="800" fill="#e5e7eb" text-anchor="middle">${title}</text>
        <text x="600" y="535" font-family="Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial" font-size="26" font-weight="600" fill="#94a3b8" text-anchor="middle">${subtitle}</text>
      </svg>`,
    )}`;

  const withBuster = (url: string, buster: number) => {
    if (!buster) return url;
    if (url.startsWith("data:") || url.startsWith("blob:")) return url;
    const sep = url.includes("?") ? "&" : "?";
    return `${url}${sep}v=${buster}`;
  };

  // If an image URL exists but fails to load (CDN still warming up), retry a few times automatically.
  useEffect(() => {
    if (!landingImageUrl) return;
    if (!heroImgFailed) return;
    if (heroRetryCount >= 6) return;
    const t = window.setTimeout(() => {
      setHeroRetryBuster(Date.now());
      setHeroImgFailed(false);
      setHeroRetryCount((c) => c + 1);
    }, 450);
    return () => window.clearTimeout(t);
  }, [heroImgFailed, landingImageUrl, heroRetryCount]);

  useEffect(() => {
    if (!bottomLandingImageUrl) return;
    if (!bottomImgFailed) return;
    if (bottomRetryCount >= 6) return;
    const t = window.setTimeout(() => {
      setBottomRetryBuster(Date.now());
      setBottomImgFailed(false);
      setBottomRetryCount((c) => c + 1);
    }, 450);
    return () => window.clearTimeout(t);
  }, [bottomImgFailed, bottomLandingImageUrl, bottomRetryCount]);

  const heroEffectiveUrl = heroPreviewUrl ?? landingImageUrl;
  const bottomEffectiveUrl = bottomPreviewUrl ?? bottomLandingImageUrl;

  // Always show *something* (either the published image or a placeholder)
  const heroDisplayUrl = heroEffectiveUrl
    ? heroImgFailed
      ? landingSelectPlaceholder("PP15", "Loading image…")
      : withBuster(heroEffectiveUrl, heroRetryBuster)
    : landingSelectPlaceholder("PP15", "No image set yet");
  const bottomDisplayUrl = bottomEffectiveUrl
    ? bottomImgFailed
      ? landingSelectPlaceholder("PP15", "Loading image…")
      : withBuster(bottomEffectiveUrl, bottomRetryBuster)
    : landingSelectPlaceholder("PP15", "No image set yet");

  const immediatePreloadUrls = useMemo(() => {
    // Only preload the hero image for the fastest first paint.
    // Everything else should load later (when visible) to avoid competing for bandwidth.
    const urls = [heroEffectiveUrl].filter(Boolean) as string[];

    return urls.filter(
      (u) =>
        typeof u === "string" &&
        !!u &&
        !u.startsWith("data:") &&
        !u.startsWith("blob:"),
    );
  }, [heroEffectiveUrl]);

  const deferredPreloadUrls = useMemo(() => {
    const urls = [
      galleryImages[0],
      marketSectionImageUrl,
      mapImageUrl,
      islandsImageUrl,
      secondMarketImageUrl,
      walletImageUrl,
      landingSelectSecondMarketImageUrl,
      landingSelectWalletImageUrl,
    ].filter(Boolean) as string[];

    return urls.filter(
      (u) =>
        typeof u === "string" &&
        !!u &&
        !u.startsWith("data:") &&
        !u.startsWith("blob:"),
    );
  }, [
    galleryImages,
    marketSectionImageUrl,
    mapImageUrl,
    islandsImageUrl,
    secondMarketImageUrl,
    walletImageUrl,
    landingSelectSecondMarketImageUrl,
    landingSelectWalletImageUrl,
  ]);

  const preloadImages = useCallback((urls: string[]) => {
    if (typeof window === "undefined") return;
    urls.forEach((u) => {
      try {
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        try {
          // @ts-ignore
          img.fetchPriority = "high";
        } catch {}
        // Avoid noisy global "Load failed" errors for background preloads.
        img.onerror = () => {
          // swallow preload failures
        };
        img.onload = () => {
          // swallow preload successes
        };
        try {
          // Some CDNs/policies behave better without a referrer; safe default.
          (img as any).referrerPolicy = "no-referrer";
        } catch {}
        img.src = u;
      } catch {
        // ignore
      }
    });
  }, []);

  const preconnectOrigins = useCallback((urls: string[]) => {
    if (typeof window === "undefined") return;
    if (typeof document === "undefined") return;

    const origins = Array.from(
      new Set(
        urls
          .filter(Boolean)
          .map((u) => {
            try {
              return new URL(u).origin;
            } catch {
              return null;
            }
          })
          .filter(Boolean) as string[],
      ),
    );

    origins.forEach((origin) => {
      const key = `pp15-preconnect:${origin}`;
      const existing = document.head.querySelector(
        `link[data-pp15-preconnect="${key}"]`,
      );
      if (existing) return;

      const link1 = document.createElement("link");
      link1.rel = "preconnect";
      link1.href = origin;
      link1.setAttribute("data-pp15-preconnect", key);
      try {
        link1.crossOrigin = "anonymous";
      } catch {}

      const link2 = document.createElement("link");
      link2.rel = "dns-prefetch";
      link2.href = origin;
      link2.setAttribute("data-pp15-preconnect", key);

      try {
        document.head.appendChild(link2);
        document.head.appendChild(link1);
      } catch {
        // ignore
      }
    });
  }, []);

  React.useLayoutEffect(() => {
    // Reduce the first-image latency (DNS/TLS) before we request the actual images.
    preconnectOrigins(immediatePreloadUrls);
    // Stage 1: only preload what's needed immediately (hero + bottom).
    preloadImages(immediatePreloadUrls);
  }, [immediatePreloadUrls, preloadImages, preconnectOrigins]);

  React.useEffect(() => {
    // Warm up DNS/TLS for images that appear later, without downloading them immediately.
    // This keeps the hero image fast while still making later sections feel snappy.
    if (typeof window === "undefined") return;

    const run = () => preconnectOrigins(deferredPreloadUrls);

    try {
      // @ts-ignore
      if (typeof window.requestIdleCallback === "function") {
        // @ts-ignore
        const id = window.requestIdleCallback(run, { timeout: 2500 });
        return () => {
          try {
            // @ts-ignore
            window.cancelIdleCallback?.(id);
          } catch {}
        };
      }
    } catch {
      // ignore
    }

    const t = window.setTimeout(run, 1500);
    return () => window.clearTimeout(t);
  }, [deferredPreloadUrls, preconnectOrigins]);

  useEffect(() => {
    if (!heroIsSaving) setHeroPreviewUrl(null);
    setHeroError(null);
    setHeroImgFailed(false);
    setHeroLoaded(false);
    // Do not bust cache on every render; only when we actually retry after a failure.
    setHeroRetryBuster(0);
    setHeroRetryCount(0);
  }, [landingImageUrl, heroIsSaving]);

  useEffect(() => {
    if (!bottomIsSaving) setBottomPreviewUrl(null);
    setBottomError(null);
    setBottomImgFailed(false);
    // Do not bust cache on every render; only when we actually retry after a failure.
    setBottomRetryBuster(0);
    setBottomRetryCount(0);
  }, [bottomLandingImageUrl, bottomIsSaving]);

  const [selectSecondMarketImgFailed, setSelectSecondMarketImgFailed] =
    useState(false);
  const [selectWalletImgFailed, setSelectWalletImgFailed] = useState(false);

  useEffect(
    () => setSelectSecondMarketImgFailed(false),
    [landingSelectSecondMarketImageUrl],
  );
  useEffect(
    () => setSelectWalletImgFailed(false),
    [landingSelectWalletImageUrl],
  );

  const selectSecondMarketDisplayUrl = selectSecondMarketImgFailed
    ? landingSelectPlaceholder("2ND MARKET", "Loading image…")
    : (selectSecondMarketPreviewUrl ??
      landingSelectSecondMarketImageUrl ??
      landingSelectPlaceholder("2ND MARKET", "No image set yet"));
  const selectWalletDisplayUrl = selectWalletImgFailed
    ? landingSelectPlaceholder("WALLET", "Loading image…")
    : (selectWalletPreviewUrl ??
      landingSelectWalletImageUrl ??
      landingSelectPlaceholder("WALLET", "No image set yet"));

  const hasSecondMarketCustomImage = !!(
    selectSecondMarketPreviewUrl ?? landingSelectSecondMarketImageUrl
  );
  const hasWalletCustomImage = !!(
    selectWalletPreviewUrl ?? landingSelectWalletImageUrl
  );

  const openAdminImagePicker = useCallback(
    async (opts: {
      uploader?: (input: { base64: string; fileName?: string }) => Promise<{
        ok: true;
        url: string;
      }>;
      onPreview: (base64: string) => void;
      onStart: () => void;
      onSuccess: (url: string) => void;
      onError: (message: string) => void;
      onFinally: () => void;
    }) => {
      const MAX_AUTO_COMPRESS_BYTES = 6 * 1024 * 1024; // keep uploads safely small
      const MAX_PROCESS_BYTES = 300 * 1024 * 1024; // safety for in-browser processing

      // Keep the request body safely below platform limits.
      // (Base64 data URLs are large; this cap prevents requests from failing before the server even receives them.)
      // If the selected photo is bigger, we auto-shrink it until it fits.
      // Keep this conservative to avoid the platform returning a generic 500 before the API endpoint code even runs.
      // (Large JSON bodies can fail during request parsing.)
      const MAX_SEND_DATAURL_CHARS = 900_000;

      const reencodeToJpeg = async (
        file: File,
        opts: { maxDim: number; quality: number; force: boolean },
      ): Promise<File> => {
        const type = file.type || "";
        if (!type.startsWith("image/")) {
          throw new Error("Please choose an image file.");
        }

        if (file.size > MAX_PROCESS_BYTES) {
          throw new Error(
            `This image is too large (${Math.round(file.size / 1024 / 1024)}MB). Please choose a smaller image.`,
          );
        }

        const objectUrl = URL.createObjectURL(file);
        try {
          const img = new Image();
          img.src = objectUrl;

          await new Promise<void>((resolve, reject) => {
            img.onload = () => resolve();
            img.onerror = () => reject(new Error("Image could not be loaded."));
          });

          const w = img.naturalWidth || 0;
          const h = img.naturalHeight || 0;
          if (!w || !h) return file;

          const scale = Math.min(1, opts.maxDim / Math.max(w, h));
          const mustDownscale = scale < 1;
          const mustReencode =
            opts.force ||
            mustDownscale ||
            file.size > MAX_AUTO_COMPRESS_BYTES ||
            type === "image/png" ||
            type === "image/webp" ||
            type === "image/gif";

          if (!mustReencode) return file;

          const targetW = Math.max(1, Math.round(w * scale));
          const targetH = Math.max(1, Math.round(h * scale));

          const canvas = document.createElement("canvas");
          canvas.width = targetW;
          canvas.height = targetH;

          const ctx = canvas.getContext("2d");
          if (!ctx) return file;
          ctx.imageSmoothingEnabled = true;
          (ctx as any).imageSmoothingQuality = "high";
          ctx.drawImage(img, 0, 0, targetW, targetH);

          const blob = await new Promise<Blob | null>((resolve) =>
            canvas.toBlob(resolve, "image/jpeg", opts.quality),
          );
          if (!blob) return file;

          const baseName = (file.name || "image").replace(/\.[^.]+$/, "");
          const newName = `${baseName}-compressed.jpg`;
          return new File([blob], newName, { type: blob.type });
        } finally {
          URL.revokeObjectURL(objectUrl);
        }
      };
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async () => {
        const pickedFile = input.files?.[0];
        if (!pickedFile) return;

        opts.onStart();

        let fileToUpload: File = pickedFile;
        try {
          // First pass: basic safety compression if needed.
          fileToUpload = await reencodeToJpeg(pickedFile, {
            maxDim: 2200,
            quality: 0.9,
            force: false,
          });
        } catch (e: any) {
          opts.onError(
            e?.message ||
              "This image couldn't be processed. Please choose a smaller image.",
          );
          opts.onFinally();
          return;
        }

        // Keep best quality: first try encoding what we have.
        let base64: string | null =
          await encodeFileAsBase64DataURL(fileToUpload);

        if (base64) {
          console.log(
            "[pp-landing] image encoded (chars)",
            base64.length,
            "(original MB)",
            Math.round((pickedFile.size / 1024 / 1024) * 10) / 10,
          );
        }

        // If the browser can't encode it (memory/size), force-shrink it.
        if (!base64) {
          try {
            fileToUpload = await reencodeToJpeg(fileToUpload, {
              maxDim: 1400,
              quality: 0.78,
              force: true,
            });
            base64 = await encodeFileAsBase64DataURL(fileToUpload);
          } catch {
            // ignore
          }
        }

        // If it is still too big for saving, shrink step-by-step until it fits.
        if (base64 && base64.length > MAX_SEND_DATAURL_CHARS) {
          const attempts = [
            // Always move downward (never increase size again).
            { maxDim: 2000, quality: 0.88 },
            { maxDim: 1800, quality: 0.86 },
            { maxDim: 1600, quality: 0.84 },
            { maxDim: 1400, quality: 0.82 },
            { maxDim: 1200, quality: 0.8 },
            { maxDim: 1000, quality: 0.76 },
            { maxDim: 900, quality: 0.74 },
            { maxDim: 800, quality: 0.72 },
            { maxDim: 700, quality: 0.7 },
            { maxDim: 600, quality: 0.68 },
            { maxDim: 520, quality: 0.66 },
            { maxDim: 460, quality: 0.64 },
            { maxDim: 400, quality: 0.62 },
            { maxDim: 340, quality: 0.6 },
            { maxDim: 300, quality: 0.58 },
            { maxDim: 260, quality: 0.56 },
            { maxDim: 230, quality: 0.54 },
            { maxDim: 200, quality: 0.52 },
            { maxDim: 170, quality: 0.5 },
            { maxDim: 140, quality: 0.48 },
            { maxDim: 120, quality: 0.46 },
            { maxDim: 100, quality: 0.44 },
            { maxDim: 80, quality: 0.42 },
          ];

          for (const a of attempts) {
            try {
              fileToUpload = await reencodeToJpeg(fileToUpload, {
                maxDim: a.maxDim,
                quality: a.quality,
                force: true,
              });
            } catch {
              // Ignore and try with what we have.
            }

            base64 = await encodeFileAsBase64DataURL(fileToUpload);
            if (base64 && base64.length <= MAX_SEND_DATAURL_CHARS) break;
          }
        }

        if (!base64) {
          opts.onError(
            `This image couldn't be processed (it may be very large). Size: ${Math.round(pickedFile.size / 1024 / 1024)}MB. Tip: take a quick screenshot and select the screenshot instead.`,
          );
          opts.onFinally();
          return;
        }

        if (base64.length > MAX_SEND_DATAURL_CHARS) {
          opts.onError(
            "This image is still too large to save (even after resizing). Tip: select a screenshot or choose a smaller photo.",
          );
          opts.onFinally();
          return;
        }

        opts.onPreview(base64);
        // If no uploader is provided, we only keep a local preview.
        if (!opts.uploader) {
          opts.onSuccess(base64);
          opts.onFinally();
          return;
        }

        const isLikelySizeError = (msg: string) => {
          const m = String(msg || "").toLowerCase();
          return (
            m.includes("status: 413") ||
            m.includes("status 413") ||
            m.includes("payload too large") ||
            m.includes("request entity too large") ||
            m.includes("too large") ||
            m.includes("too large") ||
            m.includes("max_chars") ||
            m.includes("max chars") ||
            m.includes("max_ch") ||
            // The platform sometimes returns a generic 500 when the request body is too big.
            m.includes("status: 500") ||
            m.includes("status 500")
          );
        };

        const tryUpload = async (dataUrl: string) => {
          return await opts.uploader!({
            base64: dataUrl,
            fileName: fileToUpload.name || pickedFile.name,
          });
        };

        let finalUrl: string | null = null;
        try {
          const res = await tryUpload(base64);
          finalUrl = res.url;
        } catch (e: any) {
          const msg =
            e?.message ||
            "Upload failed. Please try again or choose a smaller image.";
          console.log("[pp-landing] upload failed:", msg);

          // Rescue attempts: if the server still thinks it's too large, shrink progressively and retry.
          if (isLikelySizeError(msg)) {
            const rescueAttempts = [
              { maxDim: 1200, quality: 0.78 },
              { maxDim: 1000, quality: 0.74 },
              { maxDim: 900, quality: 0.7 },
              { maxDim: 800, quality: 0.68 },
              { maxDim: 700, quality: 0.66 },
              { maxDim: 600, quality: 0.64 },
              { maxDim: 520, quality: 0.62 },
              { maxDim: 460, quality: 0.6 },
              { maxDim: 380, quality: 0.58 },
              { maxDim: 320, quality: 0.56 },
            ];

            for (const a of rescueAttempts) {
              try {
                fileToUpload = await reencodeToJpeg(fileToUpload, {
                  maxDim: a.maxDim,
                  quality: a.quality,
                  force: true,
                });
                const smaller = await encodeFileAsBase64DataURL(fileToUpload);
                if (!smaller) continue;
                if (smaller.length > MAX_SEND_DATAURL_CHARS) continue;
                opts.onPreview(smaller);
                const res2 = await tryUpload(smaller);
                finalUrl = res2.url;
                break;
              } catch {
                // keep trying smaller
              }
            }
          }

          if (!finalUrl) {
            if (isLikelySizeError(msg)) {
              opts.onError(
                "Save failed because the image is still too large after automatic resizing. Tip: take a screenshot (usually smaller) and try saving again.",
              );
            } else {
              const short = String(msg || "").slice(0, 220);
              opts.onError(
                `Save failed. Reason: ${short}${String(msg || "").length > 220 ? "…" : ""}`,
              );
            }
            opts.onFinally();
            return;
          }
        }

        opts.onSuccess(finalUrl);

        await Promise.all([
          queryClient.invalidateQueries(["market"]),
          queryClient.invalidateQueries(["market", "landingCoin"]),
          queryClient.invalidateQueries(["landingAssets"]),
        ]);

        opts.onFinally();
      };
      input.click();
    },
    [queryClient],
  );

  const adminDoubleTap = useCallback(
    (
      ref: React.MutableRefObject<number>,
      enabled: boolean,
      action: () => void,
    ): { onDoubleClick: () => void; onTouchEnd: () => void } => {
      return {
        onDoubleClick: () => {
          if (!enabled) return;
          action();
        },
        onTouchEnd: () => {
          if (!enabled) return;
          const now = Date.now();
          if (now - ref.current < 350) {
            ref.current = 0;
            action();
            return;
          }
          ref.current = now;
        },
      };
    },
    [],
  );

  return (
    <div className="min-h-screen bg-background text-foreground flex flex-col">
      {/* Login is disabled: no admin sign-in prompt */}

      {/* Hero section (mobile-first) */}
      <div className="flex-1 flex items-start md:items-center justify-center px-4 pt-[calc(env(safe-area-inset-top,0px)+1rem)] md:pt-20 pb-10 bg-background">
        <div className="w-full max-w-6xl flex flex-col md:flex-row items-start md:items-center justify-between gap-8 md:gap-10">
          {/* Right side on desktop, first on mobile: large hero image */}
          <div className="w-full flex-1 order-1 md:order-2">
            <div className="w-full">
              {isAdmin && (
                <div className="w-full flex justify-end mb-2">
                  <button
                    type="button"
                    onClick={() => {
                      void openAdminImagePicker({
                        uploader: async ({ base64, fileName }) => {
                          const res: any =
                            await apiClient.setLandingImageFromBase64({
                              base64,
                              fileName,
                            });
                          if (res?.ok === false) {
                            throw new Error(
                              res?.message || "Couldn't save the image.",
                            );
                          }
                          return {
                            ok: true as const,
                            url: res?.url ?? base64,
                          };
                        },
                        onPreview: (base64) => {
                          setHeroPreviewUrl(base64);
                        },
                        onStart: () => {
                          setHeroIsSaving(true);
                          setHeroError(null);
                          setHeroSavedAt(null);
                        },
                        onSuccess: (url) => {
                          setHeroPreviewUrl(url);
                          setHeroSavedAt(Date.now());
                          toast({ title: "Published for everyone" });
                        },
                        onError: (message) => {
                          setHeroError(message);
                        },
                        onFinally: () => {
                          setHeroIsSaving(false);
                        },
                      });
                    }}
                    className="rounded-full bg-background/80 px-3 py-1 text-xs font-semibold text-foreground shadow-sm hover:bg-background"
                  >
                    Change image
                  </button>{" "}
                </div>
              )}

              {/* Mobile: big, clear image directly under the iPhone top bar */}
              <div
                className={`md:hidden w-full overflow-hidden relative$\
{isAdmin ? " cursor-pointer" : ""}`}
                {...(isAdmin
                  ? adminDoubleTap(heroTapRef, true, () => {
                      void openAdminImagePicker({
                        uploader: async ({ base64, fileName }) => {
                          const res: any =
                            await apiClient.setLandingImageFromBase64({
                              base64,
                              fileName,
                            });
                          if (res?.ok === false) {
                            throw new Error(
                              res?.message || "Couldn't save the image.",
                            );
                          }
                          return {
                            ok: true as const,
                            url: res?.url ?? base64,
                          };
                        },
                        onPreview: (base64) => {
                          setHeroPreviewUrl(base64);
                        },
                        onStart: () => {
                          setHeroIsSaving(true);
                          setHeroError(null);
                          setHeroSavedAt(null);
                        },
                        onSuccess: (url) => {
                          setHeroPreviewUrl(url);
                          setHeroSavedAt(Date.now());
                          toast({ title: "Published for everyone" });
                        },
                        onError: (message) => {
                          setHeroError(message);
                        },
                        onFinally: () => {
                          setHeroIsSaving(false);
                        },
                      });
                    })
                  : {})}
              >
                <img
                  src={heroDisplayUrl}
                  alt="PP15 hero"
                  loading="eager"
                  decoding="async"
                  // @ts-ignore
                  fetchPriority={"high"}
                  onLoad={() => {
                    setHeroLoaded(true);
                    setHeroImgFailed(false);
                  }}
                  onError={() => setHeroImgFailed(true)}
                  className="w-full max-h-[44vh] object-contain pp15-image-sharp"
                  draggable={false}
                />

                {heroIsSaving && (
                  <div className="absolute inset-0 flex items-center justify-center bg-background/70">
                    <span className="text-sm font-semibold">Saving…</span>
                  </div>
                )}
              </div>

              {/* Desktop: phone mockup */}
              <div className="hidden md:flex w-full items-center justify-center">
                <div className="w-64 lg:w-80">
                  <div
                    className={`aspect-[9/19] rounded-[2rem] flex items-center justify-center relative$\
{isAdmin ? " cursor-pointer" : ""}`}
                    {...(isAdmin
                      ? adminDoubleTap(heroTapRef, true, () => {
                          void openAdminImagePicker({
                            uploader: async ({ base64, fileName }) => {
                              const res: any =
                                await apiClient.setLandingImageFromBase64({
                                  base64,
                                  fileName,
                                });
                              if (res?.ok === false) {
                                throw new Error(
                                  res?.message || "Couldn't save the image.",
                                );
                              }
                              return {
                                ok: true as const,
                                url: res?.url ?? base64,
                              };
                            },
                            onPreview: (base64) => {
                              setHeroPreviewUrl(base64);
                            },
                            onStart: () => {
                              setHeroIsSaving(true);
                              setHeroError(null);
                              setHeroSavedAt(null);
                            },
                            onSuccess: (url) => {
                              setHeroPreviewUrl(url);
                              setHeroSavedAt(Date.now());
                              toast({ title: "Published for everyone" });
                            },
                            onError: (message) => {
                              setHeroError(message);
                            },
                            onFinally: () => {
                              setHeroIsSaving(false);
                            },
                          });
                        })
                      : {})}
                  >
                    <img
                      src={heroDisplayUrl}
                      alt="PP15 app preview"
                      loading="eager"
                      decoding="async"
                      // @ts-ignore
                      fetchPriority={"high"}
                      onLoad={() => {
                        setHeroLoaded(true);
                        setHeroImgFailed(false);
                      }}
                      onError={() => setHeroImgFailed(true)}
                      className="max-w-full max-h-full w-auto h-auto object-contain pp15-image-sharp"
                      draggable={false}
                    />

                    {heroIsSaving && (
                      <div className="absolute inset-0 flex items-center justify-center bg-background/70">
                        <span className="text-sm font-semibold">Saving…</span>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {heroSavedAt && (
                <div className="mt-3 flex items-center justify-center">
                  <Badge variant="secondary" className="gap-1">
                    <Check className="h-3 w-3" />
                    <span>Saved</span>
                  </Badge>
                </div>
              )}

              {heroError && (
                <div className="mt-3 text-sm text-destructive text-center">
                  {heroError}
                </div>
              )}

              {isAdmin && (
                <div className="mt-2 text-xs text-muted-foreground text-center">
                  Tip: double-tap or “Change image” — it’s published for
                  everyone instantly. Large photos are resized automatically.
                </div>
              )}
            </div>
          </div>

          {/* Left side on desktop, second on mobile: headline + CTA */}
          <div className="flex-1 order-2 md:order-1 flex flex-col items-center md:items-start gap-6 md:gap-8">
            <div className="text-center md:text-left">
              <div className="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-extrabold tracking-wide leading-tight uppercase">
                <div>BUY, SELL, AND TRADE</div>
                <div>DIGITAL LAND ON PP15.ONE</div>
              </div>
            </div>

            <div className="flex flex-col items-center md:items-start gap-3 w-full">
              <button
                type="button"
                onClick={() => navigate("/quick-buy")}
                className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors w-full sm:w-auto"
              >
                Buy your first m²
              </button>

              <button
                type="button"
                onClick={() => {
                  if (
                    typeof window !== "undefined" &&
                    window.history.length > 2
                  ) {
                    navigate(-1);
                  } else {
                    navigate("/market");
                  }
                }}
                className="inline-flex items-center gap-2 text-xs text-muted-foreground pt-2 hover:text-foreground transition-colors"
              >
                <ArrowLeft className="h-4 w-4" />
                <span>{t("back")}</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Scroll-down gallery section with additional photos */}
      {galleryImages.length > 0 && (
        <div className="w-full bg-background text-foreground pt-24 md:pt-32">
          <div className="w-full flex items-center justify-center bg-background py-16">
            <div className="relative w-auto h-auto max-w-full md:max-w-5xl max-h-[55vh] md:max-h-[75vh]">
              {showSkeletonFor("gallery", galleryImages[0]) && (
                <Skeleton className="absolute inset-0 rounded-2xl" />
              )}
              <img
                src={galleryImages[0]}
                alt="PP15 gallery"
                loading="lazy"
                decoding="async"
                // @ts-ignore
                fetchPriority={"low"}
                onLoad={() => markLandingImgReady("gallery")}
                onError={() => markLandingImgReady("gallery")}
                className={`w-full h-full object-contain pp15-image-sharp transition-opacity duration-300 ${
                  landingImgReady["gallery"] ? "opacity-100" : "opacity-0"
                }`}
              />
            </div>
          </div>

          {/* Benefits cards (2x2) */}
          <div className="w-full px-4 pt-6 sm:pt-8 pb-10 sm:pb-14">
            <div className="max-w-5xl mx-auto">
              <div className="mb-3 sm:mb-4 text-xs sm:text-sm text-muted-foreground text-center">
                Tap a card (or +) to flip
              </div>

              <div className="relative isolate">
                {activeBenefitId && (
                  <button
                    type="button"
                    aria-label="Close"
                    onClick={() => {
                      setFlippedBenefits((prev) => {
                        if (!activeBenefitId) return prev;
                        return { ...prev, [activeBenefitId]: false };
                      });
                      setActiveBenefitId(null);
                    }}
                    className="fixed inset-0 z-40 bg-background/10 backdrop-blur-lg"
                  />
                )}

                <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 md:gap-8">
                  {benefitCards.map((b) => {
                    const isFlipped = !!flippedBenefits[b.id];
                    const isActive = activeBenefitId === b.id;
                    const gradientClass =
                      b.id === "b1"
                        ? "pp15-benefit-gradient-1"
                        : b.id === "b2"
                          ? "pp15-benefit-gradient-2"
                          : b.id === "b3"
                            ? "pp15-benefit-gradient-4"
                            : "pp15-benefit-gradient-3";

                    const toggleFlip = () => {
                      const nextFlipped = !isFlipped;

                      if (nextFlipped) {
                        setActiveBenefitId(b.id);
                      }

                      setFlippedBenefits((prev) => ({
                        ...prev,
                        [b.id]: nextFlipped,
                      }));

                      if (!nextFlipped) {
                        // Let the flip animation finish before removing blur/scale.
                        window.setTimeout(() => {
                          setActiveBenefitId((cur) =>
                            cur === b.id ? null : cur,
                          );
                        }, 700);
                      }
                    };

                    return (
                      <div
                        key={b.id}
                        className={`relative transition-transform duration-300 ease-out ${
                          isActive
                            ? "z-50 scale-[1.08] sm:scale-[1.10] md:scale-[1.12]"
                            : activeBenefitId
                              ? "z-0"
                              : "z-0"
                        }`}
                      >
                        <div
                          role="button"
                          tabIndex={0}
                          onClick={toggleFlip}
                          onKeyDown={(e) => {
                            if (e.key === "Enter" || e.key === " ") {
                              e.preventDefault();
                              toggleFlip();
                            }
                          }}
                          className={`pp15-flip ${isFlipped ? "is-flipped" : ""} w-full h-[220px] sm:h-[240px] md:h-[260px] focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background`}
                        >
                          <div className="pp15-flip-inner h-full">
                            <div
                              className={`pp15-flip-face pp15-flip-front h-full rounded-2xl overflow-hidden border border-border text-card-foreground p-7 sm:p-8 shadow-sm flex items-center ${gradientClass}`}
                            >
                              <div className="text-lg sm:text-xl md:text-2xl font-extrabold tracking-tight leading-snug pp15-clamp-2">
                                {b.title}
                              </div>
                            </div>
                            <div
                              className={`pp15-flip-face pp15-flip-back h-full rounded-2xl overflow-hidden border border-border p-7 sm:p-8 shadow-sm pp15-benefit-back`}
                            >
                              <div className="text-sm sm:text-base md:text-lg font-semibold mb-3 leading-snug pp15-clamp-2">
                                {b.title}
                              </div>
                              <ul className="list-disc list-inside space-y-2 text-sm sm:text-base md:text-lg leading-snug pp15-benefit-back-body">
                                {b.lines.map((line) => (
                                  <li key={line}>{line}</li>
                                ))}
                              </ul>
                            </div>
                          </div>
                        </div>

                        <button
                          type="button"
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleFlip();
                          }}
                          className={`absolute bottom-4 right-4 h-10 w-10 rounded-full border border-border bg-background/30 backdrop-blur-sm text-foreground shadow-sm transition-colors hover:bg-background/40 focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background ${
                            isActive ? "z-30" : "z-0"
                          }`}
                          aria-label={isFlipped ? "Flip back" : "Flip card"}
                        >
                          <span
                            className={`inline-flex h-full w-full items-center justify-center transition-transform ${
                              isFlipped ? "rotate-45" : "rotate-0"
                            }`}
                          >
                            <Plus className="h-5 w-5" />
                          </span>
                        </button>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>

          {galleryImages.map((url, idx) => (
            <React.Fragment key={url || idx}>
              {idx === 0 && (
                <section className="w-full min-h-screen flex items-center justify-center bg-background px-4">
                  <div className="w-full max-w-5xl flex flex-col items-center">
                    <div className="w-full mb-8">
                      <div className="flex flex-col sm:flex-row flex-wrap gap-3 sm:gap-4">
                        <button
                          type="button"
                          onClick={() => setActiveSection("market")}
                          className={`flex-1 min-w-[140px] inline-flex items-center justify-between rounded-full border border-border px-4 py-2 text-sm font-semibold shadow-sm transition-colors ${
                            activeSection === "market"
                              ? "bg-blue-600 text-white"
                              : "bg-card text-foreground hover:bg-accent"
                          }`}
                        >
                          <span className="flex items-center gap-2">
                            <Home className="h-4 w-4" />
                            <span>Market</span>
                          </span>
                          <ArrowRight
                            className="h-4 w-4 transition-transform"
                            style={{
                              transform:
                                activeSection === "market"
                                  ? "rotate(90deg)"
                                  : "rotate(0deg)",
                            }}
                          />
                        </button>
                        <button
                          type="button"
                          onClick={() => setActiveSection("map")}
                          className={`flex-1 min-w-[140px] inline-flex items-center justify-between rounded-full border border-border px-4 py-2 text-sm font-semibold shadow-sm transition-colors ${
                            activeSection === "map"
                              ? "bg-blue-600 text-white"
                              : "bg-card text-foreground hover:bg-accent"
                          }`}
                        >
                          <span className="flex items-center gap-2">
                            <Building2 className="h-4 w-4" />
                            <span>Map</span>
                          </span>
                          <ArrowRight
                            className="h-4 w-4 transition-transform"
                            style={{
                              transform:
                                activeSection === "map"
                                  ? "rotate(90deg)"
                                  : "rotate(0deg)",
                            }}
                          />
                        </button>
                        <button
                          type="button"
                          onClick={() => setActiveSection("islands")}
                          className={`flex-1 min-w-[140px] inline-flex items-center justify-between rounded-full border border-border px-4 py-2 text-sm font-semibold shadow-sm transition-colors ${
                            activeSection === "islands"
                              ? "bg-blue-600 text-white"
                              : "bg-card text-foreground hover:bg-accent"
                          }`}
                        >
                          <span className="flex items-center gap-2">
                            <Search className="h-4 w-4" />
                            <span>Islands</span>
                          </span>
                          <ArrowRight
                            className="h-4 w-4 transition-transform"
                            style={{
                              transform:
                                activeSection === "islands"
                                  ? "rotate(90deg)"
                                  : "rotate(0deg)",
                            }}
                          />
                        </button>
                        <button
                          type="button"
                          onClick={() => setActiveSection("secondMarket")}
                          className={`flex-1 min-w-[140px] inline-flex items-center justify-between rounded-full border border-border px-4 py-2 text-sm font-semibold shadow-sm transition-colors ${
                            activeSection === "secondMarket"
                              ? "bg-blue-600 text-white"
                              : "bg-card text-foreground hover:bg-accent"
                          }`}
                        >
                          <span className="flex items-center gap-2">
                            <ArrowLeftRight className="h-4 w-4" />
                            <span>2nd Market</span>
                          </span>
                          <ArrowRight
                            className="h-4 w-4 transition-transform"
                            style={{
                              transform:
                                activeSection === "secondMarket"
                                  ? "rotate(90deg)"
                                  : "rotate(0deg)",
                            }}
                          />
                        </button>
                        <button
                          type="button"
                          onClick={() => setActiveSection("wallet")}
                          className={`flex-1 min-w-[140px] inline-flex items-center justify-between rounded-full border border-border px-4 py-2 text-sm font-semibold shadow-sm transition-colors ${
                            activeSection === "wallet"
                              ? "bg-blue-600 text-white"
                              : "bg-card text-foreground hover:bg-accent"
                          }`}
                        >
                          <span className="flex items-center gap-2">
                            <Wallet2 className="h-4 w-4" />
                            <span>Wallet</span>
                          </span>
                          <ArrowRight
                            className="h-4 w-4 transition-transform"
                            style={{
                              transform:
                                activeSection === "wallet"
                                  ? "rotate(90deg)"
                                  : "rotate(0deg)",
                            }}
                          />
                        </button>
                      </div>
                    </div>

                    {activeSection === "market" && (
                      <div className="w-full flex flex-col items-center landing-slide-in-right">
                        <div className="w-full text-left mb-6">
                          <h2 className="text-3xl sm:text-4xl font-extrabold tracking-wide text-foreground">
                            MARKET
                          </h2>
                        </div>
                        <div
                          className={
                            marketSectionImageUrl
                              ? "w-full rounded-3xl aspect-[4/3] max-h-[90vh] flex items-center justify-center relative overflow-hidden"
                              : "w-full bg-muted rounded-3xl flex items-center justify-center aspect-[4/3] max-h-[90vh] relative overflow-hidden"
                          }
                        >
                          {marketSectionImageUrl ? (
                            <>
                              {showSkeletonFor(
                                "marketSection",
                                marketSectionImageUrl,
                              ) && (
                                <Skeleton className="absolute inset-0 rounded-3xl" />
                              )}
                              <img
                                src={marketSectionImageUrl}
                                alt="Market visual"
                                loading="lazy"
                                decoding="async"
                                // @ts-ignore
                                fetchPriority={"low"}
                                onLoad={() =>
                                  markLandingImgReady("marketSection")
                                }
                                onError={() =>
                                  markLandingImgReady("marketSection")
                                }
                                className={`max-w-full max-h-full w-auto h-auto object-contain pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                                  landingImgReady["marketSection"]
                                    ? "opacity-100"
                                    : "opacity-0"
                                }`}
                              />
                            </>
                          ) : (
                            <span className="text-base sm:text-xl text-foreground opacity-60">
                              Market image coming soon
                            </span>
                          )}
                        </div>
                        <div className="mt-8 flex flex-col sm:flex-row gap-4 justify-center">
                          <button
                            type="button"
                            onClick={() =>
                              setInfoSection((prev) =>
                                prev === "market" ? null : "market",
                              )
                            }
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Info
                          </button>
                          <button
                            type="button"
                            onClick={() => navigate("/market")}
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Go to Market
                          </button>
                        </div>

                        {infoSection === "market" && (
                          <div className="mt-6 w-full max-w-3xl bg-card text-card-foreground rounded-3xl shadow-md p-6 sm:p-8">
                            <h3 className="text-xl font-semibold mb-4 text-foreground">
                              Market – Info
                            </h3>
                            <ul className="list-disc list-inside space-y-2 text-sm sm:text-base text-foreground">
                              <li>
                                Always see the current price per m² (PPC/m²) and
                                how it changes with buys/sells.
                              </li>
                              <li>
                                Choose an amount of m² → see a clear cost
                                preview → then confirm.
                              </li>
                              <li>
                                After buying, your m² are added immediately
                                (ownership + unique IDs) and your PPc balance
                                updates.
                              </li>
                              <li>
                                You can sell m² back to the system later, or
                                list them on the 2nd Market to other users.
                              </li>
                              <li>
                                PPc are in-app credits (not redeemable). All
                                movements are shown transparently in Wallet.
                              </li>
                            </ul>
                          </div>
                        )}
                      </div>
                    )}

                    {activeSection === "map" && (
                      <div className="w-full flex flex-col items-center landing-slide-in-right">
                        <div className="w-full text-left mb-6">
                          <h2 className="text-3xl sm:text-4xl font-extrabold tracking-wide text-foreground">
                            MAP
                          </h2>
                        </div>
                        <div
                          className={
                            mapImageUrl
                              ? "w-full rounded-3xl aspect-[4/3] max-h-[90vh] flex items-center justify-center relative overflow-hidden"
                              : "w-full bg-muted rounded-3xl flex items-center justify-center aspect-[4/3] max-h-[90vh] relative overflow-hidden"
                          }
                        >
                          {mapImageUrl ? (
                            <>
                              {showSkeletonFor("map", mapImageUrl) && (
                                <Skeleton className="absolute inset-0 rounded-3xl" />
                              )}
                              <img
                                src={mapImageUrl}
                                alt="Map preview"
                                loading="lazy"
                                decoding="async"
                                // @ts-ignore
                                fetchPriority={"low"}
                                onLoad={() => markLandingImgReady("map")}
                                onError={() => markLandingImgReady("map")}
                                className={`max-w-full max-h-full w-auto h-auto object-contain pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                                  landingImgReady["map"]
                                    ? "opacity-100"
                                    : "opacity-0"
                                }`}
                              />
                            </>
                          ) : (
                            <span className="text-base sm:text-xl text-foreground opacity-60">
                              Map image coming soon
                            </span>
                          )}
                        </div>
                        <div className="mt-8 flex flex-col sm:flex-row gap-4 justify-center">
                          <button
                            type="button"
                            onClick={() =>
                              setInfoSection((prev) =>
                                prev === "map" ? null : "map",
                              )
                            }
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Info
                          </button>
                          <button
                            type="button"
                            onClick={() => navigate("/map")}
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Go to Map
                          </button>
                        </div>

                        {infoSection === "map" && (
                          <div className="mt-6 w-full max-w-3xl bg-card text-card-foreground rounded-3xl shadow-md p-6 sm:p-8">
                            <h3 className="text-xl font-semibold mb-4 text-foreground">
                              Map – Info
                            </h3>
                            <ul className="list-disc list-inside space-y-2 text-sm sm:text-base text-foreground">
                              <li>
                                Each cell represents 1 m². Colors show
                                instantly: free, owned by others, or owned by
                                you.
                              </li>
                              <li>
                                Buy: select m² → see the cost → confirm → the m²
                                are yours immediately.
                              </li>
                              <li>
                                Sell: select your m² → see proceeds → confirm →
                                ownership is removed and your PPc increases.
                              </li>
                              <li>
                                Search & navigation help you jump to specific
                                areas (coordinates, “My m²” shortcut).
                              </li>
                            </ul>
                          </div>
                        )}
                      </div>
                    )}

                    {activeSection === "islands" && (
                      <div className="w-full flex flex-col items-center landing-slide-in-right">
                        <div className="w-full text-left mb-6">
                          <h2 className="text-3xl sm:text-4xl font-extrabold tracking-wide text-foreground">
                            ISLANDS
                          </h2>
                        </div>
                        <div
                          className={
                            islandsImageUrl
                              ? "w-full rounded-3xl aspect-[4/3] max-h-[90vh] flex items-center justify-center relative overflow-hidden"
                              : "w-full bg-muted rounded-3xl flex items-center justify-center aspect-[4/3] max-h-[90vh] relative overflow-hidden"
                          }
                        >
                          {islandsImageUrl ? (
                            <>
                              {showSkeletonFor("islands", islandsImageUrl) && (
                                <Skeleton className="absolute inset-0 rounded-3xl" />
                              )}
                              <img
                                src={islandsImageUrl}
                                alt="Islands preview"
                                loading="lazy"
                                decoding="async"
                                // @ts-ignore
                                fetchPriority={"low"}
                                onLoad={() => markLandingImgReady("islands")}
                                onError={() => markLandingImgReady("islands")}
                                className={`max-w-full max-h-full w-auto h-auto object-contain pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                                  landingImgReady["islands"]
                                    ? "opacity-100"
                                    : "opacity-0"
                                }`}
                              />
                            </>
                          ) : (
                            <span className="text-base sm:text-xl text-foreground opacity-60">
                              Islands image coming soon
                            </span>
                          )}
                        </div>
                        <div className="mt-8 flex flex-col sm:flex-row gap-4 justify-center">
                          <button
                            type="button"
                            onClick={() =>
                              setInfoSection((prev) =>
                                prev === "islands" ? null : "islands",
                              )
                            }
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Info
                          </button>
                          <button
                            type="button"
                            onClick={() => navigate("/islands")}
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Go to Islands
                          </button>
                        </div>

                        {infoSection === "islands" && (
                          <div className="mt-6 w-full max-w-3xl bg-card text-card-foreground rounded-3xl shadow-md p-6 sm:p-8">
                            <h3 className="text-xl font-semibold mb-4 text-foreground">
                              Islands – Info
                            </h3>
                            <ul className="list-disc list-inside space-y-2 text-sm sm:text-base text-foreground">
                              <li>
                                Islands are separate areas with their own
                                dynamics (price, supply, demand).
                              </li>
                              <li>
                                You can compare islands and open an island page
                                to see all details at a glance.
                              </li>
                              <li>
                                When trading inside an island, the island’s own
                                price per m² applies (not a global average).
                              </li>
                              <li>
                                On an island you see transparently: top holders,
                                your holdings, and your results.
                              </li>
                            </ul>
                          </div>
                        )}
                      </div>
                    )}

                    {activeSection === "secondMarket" && (
                      <div className="w-full flex flex-col items-center landing-slide-in-right">
                        <div className="w-full text-left mb-6">
                          <h2 className="text-3xl sm:text-4xl font-extrabold tracking-wide text-foreground">
                            2ND MARKET
                          </h2>
                        </div>
                        {canEditSelectImages && (
                          <div className="w-full flex justify-end mb-2">
                            <button
                              type="button"
                              onClick={() => {
                                void openAdminImagePicker({
                                  uploader: async ({ base64 }) => {
                                    const res: any =
                                      await apiClient.setLandingSelectSecondMarketImageFromBase64(
                                        {
                                          base64,
                                        },
                                      );
                                    if (res?.ok === false) {
                                      throw new Error(
                                        res?.message ||
                                          "Couldn't save the image.",
                                      );
                                    }
                                    return {
                                      ok: true as const,
                                      url: res?.url ?? base64,
                                    };
                                  },
                                  onPreview: (base64) => {
                                    setSelectSecondMarketPreviewUrl(base64);
                                    setSelectSecondMarketNaturalSize(null);
                                  },
                                  onStart: () => {
                                    setSelectSecondMarketIsSaving(true);
                                    setSelectSecondMarketError(null);
                                    setSelectSecondMarketSavedAt(null);
                                  },
                                  onSuccess: (url) => {
                                    setSelectSecondMarketPreviewUrl(url);
                                    setSelectSecondMarketNaturalSize(null);
                                    setSelectSecondMarketSavedAt(Date.now());
                                    toast({ title: "Published for everyone" });
                                  },
                                  onError: (message) => {
                                    setSelectSecondMarketPreviewUrl(null);
                                    setSelectSecondMarketError(message);
                                    toast({
                                      title: "Save failed",
                                      description: message,
                                    });
                                  },
                                  onFinally: () => {
                                    setSelectSecondMarketIsSaving(false);
                                  },
                                });
                              }}
                              className="rounded-full bg-background/80 px-3 py-1 text-xs font-semibold text-foreground shadow-sm hover:bg-background"
                            >
                              Change image
                            </button>{" "}
                          </div>
                        )}
                        <div
                          className={
                            hasSecondMarketCustomImage
                              ? `w-full rounded-3xl relative flex items-center justify-center min-h-[46vh]${
                                  canEditSelectImages ? " cursor-pointer" : ""
                                }`
                              : `w-full bg-muted rounded-3xl flex items-center justify-center relative min-h-[46vh]${
                                  canEditSelectImages ? " cursor-pointer" : ""
                                }`
                          }
                          {...(canEditSelectImages
                            ? adminDoubleTap(secondMarketTapRef, true, () => {
                                void openAdminImagePicker({
                                  uploader: async ({ base64 }) => {
                                    const res: any =
                                      await apiClient.setLandingSelectSecondMarketImageFromBase64(
                                        {
                                          base64,
                                        },
                                      );
                                    if (res?.ok === false) {
                                      throw new Error(
                                        res?.message ||
                                          "Couldn't save the image.",
                                      );
                                    }
                                    return {
                                      ok: true as const,
                                      url: res?.url ?? base64,
                                    };
                                  },
                                  onPreview: (base64) => {
                                    setSelectSecondMarketPreviewUrl(base64);
                                    setSelectSecondMarketNaturalSize(null);
                                  },
                                  onStart: () => {
                                    setSelectSecondMarketIsSaving(true);
                                    setSelectSecondMarketError(null);
                                    setSelectSecondMarketSavedAt(null);
                                  },
                                  onSuccess: (url) => {
                                    setSelectSecondMarketPreviewUrl(url);
                                    setSelectSecondMarketNaturalSize(null);
                                    setSelectSecondMarketSavedAt(Date.now());
                                    toast({ title: "Published for everyone" });
                                  },
                                  onError: (message) => {
                                    setSelectSecondMarketPreviewUrl(null);
                                    setSelectSecondMarketError(message);
                                    toast({
                                      title: "Save failed",
                                      description: message,
                                    });
                                  },
                                  onFinally: () => {
                                    setSelectSecondMarketIsSaving(false);
                                  },
                                });
                              })
                            : {})}
                        >
                          {showSkeletonFor(
                            "selectSecondMarket",
                            selectSecondMarketDisplayUrl as string,
                          ) && (
                            <Skeleton className="absolute inset-0 rounded-3xl" />
                          )}
                          <img
                            src={selectSecondMarketDisplayUrl as string}
                            alt="2nd Market preview"
                            loading="lazy"
                            decoding="async"
                            // @ts-ignore
                            fetchPriority={"low"}
                            className={`w-full h-auto max-h-[92vh] object-contain pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                              landingImgReady["selectSecondMarket"]
                                ? "opacity-100"
                                : "opacity-0"
                            }`}
                            draggable={false}
                            onError={() => {
                              setSelectSecondMarketImgFailed(true);
                              markLandingImgReady("selectSecondMarket");
                            }}
                            onLoad={(e) => {
                              markLandingImgReady("selectSecondMarket");
                              setSelectSecondMarketImgFailed(false);
                              const img = e.currentTarget;
                              setSelectSecondMarketNaturalSize({
                                w: img.naturalWidth,
                                h: img.naturalHeight,
                              });
                            }}
                            style={{
                              imageRendering:
                                "-webkit-optimize-contrast" as any,
                            }}
                            sizes="(max-width: 768px) 100vw, 960px"
                          />

                          {selectSecondMarketIsSaving && (
                            <div className="absolute inset-0 flex items-center justify-center bg-background/70">
                              <span className="text-sm font-semibold">
                                Preparing photo…
                              </span>{" "}
                            </div>
                          )}
                        </div>
                        {selectSecondMarketSavedAt && (
                          <div className="mt-3 flex items-center justify-center">
                            <Badge variant="secondary" className="gap-1">
                              <Check className="h-3 w-3" />
                              <span>Saved</span>
                            </Badge>
                          </div>
                        )}
                        {selectSecondMarketError && (
                          <div className="mt-3 text-sm text-destructive text-center">
                            {selectSecondMarketError}
                            <div className="mt-1 text-xs text-muted-foreground">
                              Tip: if a photo is “too large”, take a quick
                              screenshot and select the screenshot instead.{" "}
                            </div>
                          </div>
                        )}
                        {canEditSelectImages && (
                          <div className="mt-2 text-xs text-muted-foreground text-center">
                            Tip: “Change image” — it’s published for everyone
                            instantly. Large photos are resized automatically
                            (this can take a few seconds).
                          </div>
                        )}
                        {!hasSecondMarketCustomImage && (
                          <div className="mt-2 text-xs text-muted-foreground text-center">
                            (No highlights / no image set yet)
                          </div>
                        )}{" "}
                        <div className="mt-8 flex flex-col sm:flex-row gap-4 justify-center">
                          <button
                            type="button"
                            onClick={() =>
                              setInfoSection((prev) =>
                                prev === "secondMarket" ? null : "secondMarket",
                              )
                            }
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Info
                          </button>
                          <button
                            type="button"
                            onClick={() => navigate("/secondary")}
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Go to 2nd Market
                          </button>
                        </div>
                        {infoSection === "secondMarket" && (
                          <div className="mt-6 w-full max-w-3xl bg-card text-card-foreground rounded-3xl shadow-md p-6 sm:p-8">
                            <h3 className="text-xl font-semibold mb-4 text-foreground">
                              2nd Market – Info
                            </h3>
                            <ul className="list-disc list-inside space-y-2 text-sm sm:text-base text-foreground">
                              <li>Buy/sell directly with other users (C2C).</li>
                              <li>
                                Each listing clearly shows: seller,
                                location/island, amount, price, and certificate
                                status.
                              </li>
                              <li>
                                Buying: you pay with PP coins and ownership is
                                transferred instantly.
                              </li>
                              <li>
                                Listing: select your m², set a price, and
                                publish in minutes.
                              </li>
                            </ul>
                          </div>
                        )}
                      </div>
                    )}

                    {activeSection === "wallet" && (
                      <div className="w-full flex flex-col items-center landing-slide-in-right">
                        <div className="w-full text-left mb-6">
                          <h2 className="text-3xl sm:text-4xl font-extrabold tracking-wide text-foreground">
                            WALLET
                          </h2>
                        </div>

                        {canEditSelectImages && (
                          <div className="w-full flex justify-end mb-2">
                            <button
                              type="button"
                              onClick={() => {
                                void openAdminImagePicker({
                                  uploader: async ({ base64 }) => {
                                    const res: any =
                                      await apiClient.setLandingSelectWalletImageFromBase64(
                                        {
                                          base64,
                                        },
                                      );
                                    if (res?.ok === false) {
                                      throw new Error(
                                        res?.message ||
                                          "Couldn't save the image.",
                                      );
                                    }
                                    return {
                                      ok: true as const,
                                      url: res?.url ?? base64,
                                    };
                                  },
                                  onPreview: (base64) => {
                                    setSelectWalletPreviewUrl(base64);
                                    setSelectWalletNaturalSize(null);
                                  },
                                  onStart: () => {
                                    setSelectWalletIsSaving(true);
                                    setSelectWalletError(null);
                                    setSelectWalletSavedAt(null);
                                  },
                                  onSuccess: (url) => {
                                    setSelectWalletPreviewUrl(url);
                                    setSelectWalletNaturalSize(null);
                                    setSelectWalletSavedAt(Date.now());
                                    toast({ title: "Published for everyone" });
                                  },
                                  onError: (message) => {
                                    setSelectWalletPreviewUrl(null);
                                    setSelectWalletError(message);
                                    toast({
                                      title: "Save failed",
                                      description: message,
                                    });
                                  },
                                  onFinally: () => {
                                    setSelectWalletIsSaving(false);
                                  },
                                });
                              }}
                              className="rounded-full bg-background/80 px-3 py-1 text-xs font-semibold text-foreground shadow-sm hover:bg-background"
                            >
                              Change image
                            </button>{" "}
                          </div>
                        )}

                        <div
                          className={
                            hasWalletCustomImage
                              ? `w-full rounded-3xl relative flex items-center justify-center min-h-[46vh]${
                                  canEditSelectImages ? " cursor-pointer" : ""
                                }`
                              : `w-full bg-muted rounded-3xl flex items-center justify-center relative min-h-[46vh]${
                                  canEditSelectImages ? " cursor-pointer" : ""
                                }`
                          }
                          {...(canEditSelectImages
                            ? adminDoubleTap(walletTapRef, true, () => {
                                void openAdminImagePicker({
                                  uploader: async ({ base64 }) => {
                                    const res: any =
                                      await apiClient.setLandingSelectWalletImageFromBase64(
                                        {
                                          base64,
                                        },
                                      );
                                    if (res?.ok === false) {
                                      throw new Error(
                                        res?.message ||
                                          "Couldn't save the image.",
                                      );
                                    }
                                    return {
                                      ok: true as const,
                                      url: res?.url ?? base64,
                                    };
                                  },
                                  onPreview: (base64) => {
                                    setSelectWalletPreviewUrl(base64);
                                    setSelectWalletNaturalSize(null);
                                  },
                                  onStart: () => {
                                    setSelectWalletIsSaving(true);
                                    setSelectWalletError(null);
                                    setSelectWalletSavedAt(null);
                                  },
                                  onSuccess: (url) => {
                                    setSelectWalletPreviewUrl(url);
                                    setSelectWalletNaturalSize(null);
                                    setSelectWalletSavedAt(Date.now());
                                    toast({ title: "Published for everyone" });
                                  },
                                  onError: (message) => {
                                    setSelectWalletPreviewUrl(null);
                                    setSelectWalletError(message);
                                    toast({
                                      title: "Save failed",
                                      description: message,
                                    });
                                  },
                                  onFinally: () => {
                                    setSelectWalletIsSaving(false);
                                  },
                                });
                              })
                            : {})}
                        >
                          {showSkeletonFor(
                            "selectWallet",
                            selectWalletDisplayUrl as string,
                          ) && (
                            <Skeleton className="absolute inset-0 rounded-3xl" />
                          )}
                          <img
                            src={selectWalletDisplayUrl as string}
                            alt="Wallet preview"
                            loading="lazy"
                            decoding="async"
                            // @ts-ignore
                            fetchPriority={"low"}
                            className={`w-full h-auto max-h-[92vh] object-contain pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                              landingImgReady["selectWallet"]
                                ? "opacity-100"
                                : "opacity-0"
                            }`}
                            draggable={false}
                            onError={() => {
                              setSelectWalletImgFailed(true);
                              markLandingImgReady("selectWallet");
                            }}
                            onLoad={(e) => {
                              markLandingImgReady("selectWallet");
                              setSelectWalletImgFailed(false);
                              const img = e.currentTarget;
                              setSelectWalletNaturalSize({
                                w: img.naturalWidth,
                                h: img.naturalHeight,
                              });
                            }}
                            style={{
                              imageRendering:
                                "-webkit-optimize-contrast" as any,
                            }}
                            sizes="(max-width: 768px) 100vw, 960px"
                          />

                          {selectWalletIsSaving && (
                            <div className="absolute inset-0 flex items-center justify-center bg-background/70">
                              <span className="text-sm font-semibold">
                                Preparing photo…
                              </span>{" "}
                            </div>
                          )}
                        </div>

                        {selectWalletSavedAt && (
                          <div className="mt-3 flex items-center justify-center">
                            <Badge variant="secondary" className="gap-1">
                              <Check className="h-3 w-3" />
                              <span>Saved</span>
                            </Badge>
                          </div>
                        )}

                        {selectWalletError && (
                          <div className="mt-3 text-sm text-destructive text-center">
                            {selectWalletError}
                            <div className="mt-1 text-xs text-muted-foreground">
                              Tip: if a photo is “too large”, take a quick
                              screenshot and select the screenshot instead.{" "}
                            </div>
                          </div>
                        )}

                        {canEditSelectImages && (
                          <div className="mt-2 text-xs text-muted-foreground text-center">
                            Tip: “Change image” — it’s published for everyone
                            instantly. Large photos are resized automatically
                            (this can take a few seconds).
                          </div>
                        )}

                        {!hasWalletCustomImage && (
                          <div className="mt-2 text-xs text-muted-foreground text-center">
                            (No highlights / no image set yet)
                          </div>
                        )}
                        <div className="mt-8 flex flex-col sm:flex-row gap-4 justify-center">
                          <button
                            type="button"
                            onClick={() =>
                              setInfoSection((prev) =>
                                prev === "wallet" ? null : "wallet",
                              )
                            }
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Info
                          </button>
                          <button
                            type="button"
                            onClick={() => navigate("/wallet")}
                            className="inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
                          >
                            Go to Wallet
                          </button>
                        </div>

                        {infoSection === "wallet" && (
                          <div className="mt-6 w-full max-w-3xl bg-card text-card-foreground rounded-3xl shadow-md p-6 sm:p-8">
                            <h3 className="text-xl font-semibold mb-4 text-foreground">
                              Wallet – Info
                            </h3>
                            <ul className="list-disc list-inside space-y-2 text-sm sm:text-base text-foreground">
                              <li>
                                See your current PPc balance instantly — and
                                every change (top-ups, buys, sells).
                              </li>
                              <li>
                                All buys/sells are traceable: when, how many m²,
                                and at what price.
                              </li>
                              <li>
                                Your proof of ownership (certificates) is linked
                                directly.
                              </li>
                              <li>
                                Messages/updates are collected in the Message
                                Center.
                              </li>
                            </ul>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                </section>
              )}
            </React.Fragment>
          ))}
        </div>
      )}

      {/* Wallet info section above About PP15 */}
      <section className="w-full bg-background text-foreground pt-24 pb-16 px-4 border-t border-border">
        <div className="max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-10 md:gap-16 items-center">
          {/* Left: text */}
          <div>
            <h2 className="text-3xl sm:text-4xl lg:text-5xl font-extrabold tracking-wide mb-4">
              Your balance. In Wallet.
            </h2>
            <p className="text-sm sm:text-base leading-relaxed text-muted-foreground">
              When you top up PPC, your balance shows up instantly in Wallet.
              Every m² purchase subtracts PPC, and every sale adds PPC. This way
              you can always see your current balance, your history, and exactly
              what PPC was used for.
            </p>
          </div>

          {/* Right: static iPhone-style image area (admin-controlled) */}
          <div className="flex items-center justify-center">
            <div className="w-full">
              {canEditSelectImages && (
                <div className="w-full flex justify-end mb-2">
                  <button
                    type="button"
                    onClick={() => {
                      void openAdminImagePicker({
                        uploader: async ({ base64, fileName }) => {
                          const res: any =
                            await apiClient.setLandingImage4FromBase64({
                              base64,
                              fileName,
                            });
                          if (res?.ok === false) {
                            throw new Error(
                              res?.message || "Couldn't save the image.",
                            );
                          }
                          return {
                            ok: true as const,
                            url: res?.url ?? base64,
                          };
                        },
                        onPreview: (base64) => {
                          setWalletCardPreviewUrl(base64);
                        },
                        onStart: () => {
                          setWalletCardIsSaving(true);
                          setWalletCardError(null);
                          setWalletCardSavedAt(null);
                        },
                        onSuccess: (url) => {
                          setWalletCardPreviewUrl(url);
                          setWalletCardSavedAt(Date.now());
                          toast({ title: "Published for everyone" });
                        },
                        onError: (message) => {
                          setWalletCardError(message);
                        },
                        onFinally: () => {
                          setWalletCardIsSaving(false);
                        },
                      });
                    }}
                    className="rounded-full bg-background/80 px-3 py-1 text-xs font-semibold text-foreground shadow-sm hover:bg-background"
                  >
                    Change image
                  </button>
                </div>
              )}

              <div
                className={`w-44 sm:w-56 md:w-64 lg:w-80 aspect-[9/19] rounded-[2rem] flex items-center justify-center select-none relative${
                  canEditSelectImages ? " cursor-pointer" : ""
                }`}
                {...(canEditSelectImages
                  ? adminDoubleTap(walletCardTapRef, true, () => {
                      void openAdminImagePicker({
                        uploader: async ({ base64, fileName }) => {
                          const res: any =
                            await apiClient.setLandingImage4FromBase64({
                              base64,
                              fileName,
                            });
                          if (res?.ok === false) {
                            throw new Error(
                              res?.message || "Couldn't save the image.",
                            );
                          }
                          return {
                            ok: true as const,
                            url: res?.url ?? base64,
                          };
                        },
                        onPreview: (base64) => {
                          setWalletCardPreviewUrl(base64);
                        },
                        onStart: () => {
                          setWalletCardIsSaving(true);
                          setWalletCardError(null);
                          setWalletCardSavedAt(null);
                        },
                        onSuccess: (url) => {
                          setWalletCardPreviewUrl(url);
                          setWalletCardSavedAt(Date.now());
                          toast({ title: "Published for everyone" });
                        },
                        onError: (message) => {
                          setWalletCardError(message);
                        },
                        onFinally: () => {
                          setWalletCardIsSaving(false);
                        },
                      });
                    })
                  : {})}
              >
                {showSkeletonFor(
                  "walletCard",
                  walletCardPreviewUrl ?? walletImageUrl ?? null,
                ) && <Skeleton className="absolute inset-0 rounded-[2rem]" />}

                {(walletCardPreviewUrl ?? walletImageUrl) ? (
                  <img
                    src={walletCardPreviewUrl ?? walletImageUrl!}
                    alt="Wallet iPhone preview"
                    loading="lazy"
                    decoding="async"
                    // @ts-ignore
                    fetchPriority={"low"}
                    onLoad={() => markLandingImgReady("walletCard")}
                    onError={() => markLandingImgReady("walletCard")}
                    className={`max-w-full max-h-full w-auto h-auto object-contain select-none pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                      canEditSelectImages
                        ? "pointer-events-auto"
                        : "pointer-events-none"
                    } ${landingImgReady["walletCard"] ? "opacity-100" : "opacity-0"}`}
                    draggable={false}
                  />
                ) : (
                  <img
                    src={landingSelectPlaceholder("WALLET", "No image set yet")}
                    alt="Wallet placeholder"
                    loading="lazy"
                    decoding="async"
                    // @ts-ignore
                    fetchPriority={"low"}
                    className={`max-w-full max-h-full w-auto h-auto object-contain select-none pp15-image-sharp ${
                      canEditSelectImages
                        ? "pointer-events-auto"
                        : "pointer-events-none"
                    }`}
                    draggable={false}
                  />
                )}

                {walletCardIsSaving && (
                  <div className="absolute inset-0 flex items-center justify-center bg-background/70">
                    <span className="text-sm font-semibold">Saving…</span>
                  </div>
                )}
              </div>

              {walletCardSavedAt && (
                <div className="mt-3 flex items-center justify-center">
                  <Badge variant="secondary" className="gap-1">
                    <Check className="h-3 w-3" />
                    <span>Saved</span>
                  </Badge>
                </div>
              )}

              {walletCardError && (
                <div className="mt-3 text-sm text-destructive text-center">
                  {walletCardError}
                </div>
              )}

              {canEditSelectImages && (
                <div className="mt-2 text-xs text-muted-foreground text-center">
                  Tip: double-tap (or “Change image”) to publish for everyone.
                </div>
              )}
            </div>
          </div>
        </div>
      </section>

      {/* Ready to sell section */}
      <section className="w-full bg-background text-foreground py-16 px-4">
        <div className="max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-10 md:gap-16 items-center">
          {/* Left: image placeholder (admin-controlled) */}
          <div className="flex items-center justify-center">
            <div className="w-full">
              {canEditSelectImages && (
                <div className="w-full flex justify-start md:justify-end mb-2">
                  <button
                    type="button"
                    onClick={() => {
                      void openAdminImagePicker({
                        uploader: async ({ base64, fileName }) => {
                          const res: any =
                            await apiClient.setLandingImage3FromBase64({
                              base64,
                              fileName,
                            });
                          if (res?.ok === false) {
                            throw new Error(
                              res?.message || "Couldn't save the image.",
                            );
                          }
                          return {
                            ok: true as const,
                            url: res?.url ?? base64,
                          };
                        },
                        onPreview: (base64) => {
                          setSecondMarketCardPreviewUrl(base64);
                        },
                        onStart: () => {
                          setSecondMarketCardIsSaving(true);
                          setSecondMarketCardError(null);
                          setSecondMarketCardSavedAt(null);
                        },
                        onSuccess: (url) => {
                          setSecondMarketCardPreviewUrl(url);
                          setSecondMarketCardSavedAt(Date.now());
                          toast({ title: "Published for everyone" });
                        },
                        onError: (message) => {
                          setSecondMarketCardError(message);
                        },
                        onFinally: () => {
                          setSecondMarketCardIsSaving(false);
                        },
                      });
                    }}
                    className="rounded-full bg-background/80 px-3 py-1 text-xs font-semibold text-foreground shadow-sm hover:bg-background"
                  >
                    Change image
                  </button>
                </div>
              )}

              <div
                className={`w-44 sm:w-56 md:w-64 lg:w-80 aspect-[9/19] rounded-[2rem] flex items-center justify-center select-none relative${
                  canEditSelectImages ? " cursor-pointer" : ""
                }`}
                {...(canEditSelectImages
                  ? adminDoubleTap(secondMarketCardTapRef, true, () => {
                      void openAdminImagePicker({
                        uploader: async ({ base64, fileName }) => {
                          const res: any =
                            await apiClient.setLandingImage3FromBase64({
                              base64,
                              fileName,
                            });
                          if (res?.ok === false) {
                            throw new Error(
                              res?.message || "Couldn't save the image.",
                            );
                          }
                          return {
                            ok: true as const,
                            url: res?.url ?? base64,
                          };
                        },
                        onPreview: (base64) => {
                          setSecondMarketCardPreviewUrl(base64);
                        },
                        onStart: () => {
                          setSecondMarketCardIsSaving(true);
                          setSecondMarketCardError(null);
                          setSecondMarketCardSavedAt(null);
                        },
                        onSuccess: (url) => {
                          setSecondMarketCardPreviewUrl(url);
                          setSecondMarketCardSavedAt(Date.now());
                          toast({ title: "Published for everyone" });
                        },
                        onError: (message) => {
                          setSecondMarketCardError(message);
                        },
                        onFinally: () => {
                          setSecondMarketCardIsSaving(false);
                        },
                      });
                    })
                  : {})}
              >
                {showSkeletonFor(
                  "secondMarketCard",
                  secondMarketCardPreviewUrl ?? secondMarketImageUrl ?? null,
                ) && <Skeleton className="absolute inset-0 rounded-[2rem]" />}

                {(secondMarketCardPreviewUrl ?? secondMarketImageUrl) ? (
                  <img
                    src={secondMarketCardPreviewUrl ?? secondMarketImageUrl!}
                    alt="2nd Market iPhone preview"
                    loading="lazy"
                    decoding="async"
                    // @ts-ignore
                    fetchPriority={"low"}
                    onLoad={() => markLandingImgReady("secondMarketCard")}
                    onError={() => markLandingImgReady("secondMarketCard")}
                    className={`max-w-full max-h-full w-auto h-auto object-contain select-none pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                      canEditSelectImages
                        ? "pointer-events-auto"
                        : "pointer-events-none"
                    } ${
                      landingImgReady["secondMarketCard"]
                        ? "opacity-100"
                        : "opacity-0"
                    }`}
                    draggable={false}
                  />
                ) : (
                  <img
                    src={landingSelectPlaceholder(
                      "2ND MARKET",
                      "No image set yet",
                    )}
                    alt="2nd Market placeholder"
                    loading="lazy"
                    decoding="async"
                    // @ts-ignore
                    fetchPriority={"low"}
                    className={`max-w-full max-h-full w-auto h-auto object-contain select-none pp15-image-sharp ${
                      canEditSelectImages
                        ? "pointer-events-auto"
                        : "pointer-events-none"
                    }`}
                    draggable={false}
                  />
                )}

                {secondMarketCardIsSaving && (
                  <div className="absolute inset-0 flex items-center justify-center bg-background/70">
                    <span className="text-sm font-semibold">Saving…</span>
                  </div>
                )}
              </div>

              {secondMarketCardSavedAt && (
                <div className="mt-3 flex items-center justify-center">
                  <Badge variant="secondary" className="gap-1">
                    <Check className="h-3 w-3" />
                    <span>Saved</span>
                  </Badge>
                </div>
              )}

              {secondMarketCardError && (
                <div className="mt-3 text-sm text-destructive text-center">
                  {secondMarketCardError}
                </div>
              )}

              {canEditSelectImages && (
                <div className="mt-2 text-xs text-muted-foreground text-center">
                  Tip: double-tap (or “Change image”) to publish for everyone.
                </div>
              )}
            </div>
          </div>
          {/* Right: text */}
          <div>
            <h2 className="text-3xl sm:text-4xl lg:text-5xl font-extrabold tracking-wide mb-4">
              Ready to sell? List it.
            </h2>
            <p className="text-sm sm:text-base leading-relaxed text-muted-foreground">
              List your virtual m² on the 2nd Market anytime. It’s fast and easy
              to sell directly to other users — trades use PP coins only (no
              real money), and ownership is transferred instantly inside PP15.
            </p>
          </div>
        </div>
      </section>

      <section className="w-full bg-background text-foreground py-16 px-4">
        <div className="max-w-4xl mx-auto">
          <h2 className="text-2xl sm:text-3xl font-extrabold tracking-wide text-center mb-6">
            About PP15
          </h2>
          <Accordion type="single" collapsible className="w-full">
            <AccordionItem value="what-is-pp15">
              <AccordionTrigger>What is PP15?</AccordionTrigger>
              <AccordionContent>
                PP15 is a marketplace for certified virtual square meters (m²).
                You can buy, own, trade (2nd Market), and organize m² into
                islands.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="what-are-certified-m2">
              <AccordionTrigger>
                What are certified virtual square meters?
              </AccordionTrigger>
              <AccordionContent>
                Certified virtual m² are unique digital collectibles with a
                fixed ID. When you buy, ownership is assigned to your account
                instantly and stored for verification.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="what-is-market">
              <AccordionTrigger>What is the Market?</AccordionTrigger>
              <AccordionContent>
                In Market you see the price per m² (PPC/m²), choose an amount,
                preview the cost clearly, then confirm. After purchase, the m²
                are yours immediately.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="what-is-2nd-market">
              <AccordionTrigger>What is the 2nd Market?</AccordionTrigger>
              <AccordionContent>
                In the 2nd Market you trade directly with other users. You can
                list your own m² or buy listings. Payments are made with PP
                coins only (no real money), and ownership is transferred
                instantly inside PP15.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="what-are-islands">
              <AccordionTrigger>What are Islands?</AccordionTrigger>
              <AccordionContent>
                Islands are areas with their own price per m² and their own
                dynamics. This lets you compare values and trade within a
                specific island.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="how-is-ownership-verified">
              <AccordionTrigger>How is ownership verified?</AccordionTrigger>
              <AccordionContent>
                Every m² has a unique ID. Your ownership is linked directly to
                your account — including proof/status — so it’s always clear who
                owns which m².
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="what-is-ppc">
              <AccordionTrigger>What is PPC?</AccordionTrigger>
              <AccordionContent>
                PPC are in-app credits. You use PPC to buy m². PPC is not
                redeemable for cash and not tradeable outside PP15.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="is-ppc-transferable">
              <AccordionTrigger>
                Is PPC transferable or redeemable?
              </AccordionTrigger>
              <AccordionContent>
                No. PPC is in-app only, not transferable, and not redeemable.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="how-to-start">
              <AccordionTrigger>How do I get started?</AccordionTrigger>
              <AccordionContent>
                1) Create an account → 2) Top up PPC (optional) → 3) Choose an
                m² amount → 4) Review cost → 5) Confirm purchase.
              </AccordionContent>
            </AccordionItem>
          </Accordion>
        </div>
      </section>

      <section className="w-full bg-background text-foreground py-16 px-4">
        <div className="max-w-5xl mx-auto flex flex-col items-center">
          {isAdmin && (
            <div className="w-full flex justify-end mb-2">
              <button
                type="button"
                onClick={() => {
                  void openAdminImagePicker({
                    uploader: async ({ base64, fileName }) => {
                      const res: any =
                        await apiClient.setBottomLandingImageFromBase64({
                          base64,
                          fileName,
                        });
                      if (res?.ok === false) {
                        throw new Error(
                          res?.message || "Couldn't save the image.",
                        );
                      }
                      return {
                        ok: true as const,
                        url: res?.url ?? base64,
                      };
                    },
                    onPreview: (base64) => {
                      setBottomPreviewUrl(base64);
                    },
                    onStart: () => {
                      setBottomIsSaving(true);
                      setBottomError(null);
                      setBottomSavedAt(null);
                    },
                    onSuccess: (url) => {
                      setBottomPreviewUrl(url);
                      setBottomSavedAt(Date.now());
                      toast({ title: "Published for everyone" });
                    },
                    onError: (message) => {
                      setBottomError(message);
                    },
                    onFinally: () => {
                      setBottomIsSaving(false);
                    },
                  });
                }}
                className="rounded-full bg-background/80 px-3 py-1 text-xs font-semibold text-foreground shadow-sm hover:bg-background"
              >
                Change image{" "}
              </button>
            </div>
          )}

          <div
            className={
              bottomLandingImageUrl
                ? `w-full rounded-3xl aspect-[4/3] max-h-[90vh] relative flex items-center justify-center$\
{isAdmin ? " cursor-pointer" : ""}`
                : `w-full bg-muted rounded-3xl flex items-center justify-center aspect-[4/3] max-h-[90vh] relative$\
{isAdmin ? " cursor-pointer" : ""}`
            }
            {...(isAdmin
              ? adminDoubleTap(bottomTapRef, true, () => {
                  void openAdminImagePicker({
                    uploader: async ({ base64, fileName }) => {
                      const res: any =
                        await apiClient.setBottomLandingImageFromBase64({
                          base64,
                          fileName,
                        });
                      if (res?.ok === false) {
                        throw new Error(
                          res?.message || "Couldn't save the image.",
                        );
                      }
                      return {
                        ok: true as const,
                        url: res?.url ?? base64,
                      };
                    },
                    onPreview: (base64) => {
                      setBottomPreviewUrl(base64);
                    },
                    onStart: () => {
                      setBottomIsSaving(true);
                      setBottomError(null);
                      setBottomSavedAt(null);
                    },
                    onSuccess: (url) => {
                      setBottomPreviewUrl(url);
                      setBottomSavedAt(Date.now());
                      toast({ title: "Published for everyone" });
                    },
                    onError: (message) => {
                      setBottomError(message);
                    },
                    onFinally: () => {
                      setBottomIsSaving(false);
                    },
                  });
                })
              : {})}
          >
            {showSkeletonFor("bottom", bottomEffectiveUrl) && (
              <Skeleton className="absolute inset-0 rounded-3xl" />
            )}
            <img
              src={bottomDisplayUrl}
              alt="Additional landing section"
              loading="lazy"
              decoding="async"
              // @ts-ignore
              fetchPriority={"low"}
              onLoad={() => markLandingImgReady("bottom")}
              onError={() => {
                setBottomImgFailed(true);
                markLandingImgReady("bottom");
              }}
              className={`max-w-full max-h-full w-auto h-auto object-contain pp15-image-sharp transition-opacity duration-300 relative z-10 ${
                isInstantSrc(bottomDisplayUrl)
                  ? "opacity-100"
                  : landingImgReady["bottom"]
                    ? "opacity-100"
                    : "opacity-0"
              }`}
              draggable={false}
            />

            {bottomIsSaving && (
              <div className="absolute inset-0 flex items-center justify-center bg-background/70">
                <span className="text-sm font-semibold">Saving…</span>
              </div>
            )}
          </div>

          {bottomSavedAt && (
            <div className="mt-3 flex items-center justify-center">
              <Badge variant="secondary" className="gap-1">
                <Check className="h-3 w-3" />
                <span>Saved</span>
              </Badge>
            </div>
          )}

          {bottomError && (
            <div className="mt-3 text-sm text-destructive text-center">
              {bottomError}
            </div>
          )}

          {isAdmin && (
            <div className="mt-2 text-xs text-muted-foreground text-center">
              Tip: double-tap or “Change image” — it’s published for everyone
              instantly.
            </div>
          )}
        </div>
      </section>

      <div ref={footerRef as any} className="w-full">
        <PP15Footer />
      </div>

      {showFloatingCta && (
        <div
          className="fixed inset-x-0 z-40 flex justify-center pointer-events-none"
          style={{
            bottom: "calc(env(safe-area-inset-bottom, 0px) + 1.5rem)",
          }}
        >
          <button
            type="button"
            onClick={() => navigate("/quick-buy")}
            className="pointer-events-auto inline-flex items-center justify-center px-8 py-3 rounded-full bg-blue-600 text-white font-semibold text-sm sm:text-base shadow-lg hover:bg-blue-500 transition-colors"
          >
            Buy your first m²
          </button>{" "}
        </div>
      )}
    </div>
  );
}
function SecondaryMarketScreen() {
  const { t } = useLang();
  const auth = useAuth();

  const formatPPC = (value: number | null | undefined) =>
    `${(value ?? 0).toLocaleString("en-US", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })} PPC`;
  const isGuest = useIsGuest();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  void navigate;

  const [myListDrawerOpen, setMyListDrawerOpen] = React.useState(false);
  const [myPlotSelection, setMyPlotSelection] = React.useState<
    Record<string, boolean>
  >({});
  const [myPlotPrices, setMyPlotPrices] = React.useState<
    Record<string, string>
  >({});
  const [searchParams, setSearchParams] = useSearchParams();
  const islandFilterId = searchParams.get("islandId");
  const coordParam = searchParams.get("coord") ?? "";
  const {
    data: islandFilter,
    isInitialLoading: islandFilterLoading,
    error: islandFilterError,
  } = useQuery<any>(
    ["islandFilter", islandFilterId],
    () => apiClient.getIsland({ id: islandFilterId as string }),
    { enabled: !!islandFilterId },
  );

  // Realtime updates
  const [secondaryRT] = useRealtimeStore("secondary", { ts: 0 });
  const {
    data: listings,
    refetch,
    isFetching,
    isInitialLoading: listingsInitialLoading,
    error: listingsError,
  } = useQuery<inferRPCOutputType<"listSecondaryListings">>(
    ["secondaryListings"],
    () => apiClient.listSecondaryListings(),
    {
      // Realtime updates handle “live” changes; keep polling lightweight.
      staleTime: 0,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchInterval: 3_000,
      refetchIntervalInBackground: true,
      retry: 0,
    },
  );
  const previousCountRef = React.useRef<number>(0);

  useEffect(() => {
    if (!listings) return;

    if (
      previousCountRef.current !== 0 &&
      listings.length > previousCountRef.current
    ) {
      console.log("🔥 NEW LISTING DETECTED");
    }

    previousCountRef.current = listings.length;
  }, [listings]);

  useEffect(() => {
    if (secondaryRT?.ts) void refetch();
  }, [secondaryRT?.ts]);

  const buyListing = useMutation(apiClient.buySecondaryListing, {
    onSuccess: async (res: any) => {
      try {
        await Promise.all([
          queryClient.invalidateQueries(["secondaryListings"]),
          queryClient.invalidateQueries(["activeListings"]),
          // Update wallet + messages quickly for the current user after a trade.
          queryClient.invalidateQueries(["profile"]),
          queryClient.invalidateQueries(["portfolio"]),
          queryClient.invalidateQueries(["holdingsBreakdown", "auth"]),
          queryClient.invalidateQueries(["walletSummary"]),
          queryClient.invalidateQueries(["walletRangeSummary"]),
          queryClient.invalidateQueries(["certificates"]),
          // Also refresh owned plots so the bought m² can be listed again immediately.
          queryClient.invalidateQueries(["myPlots"]),
          queryClient.invalidateQueries(["myPlots_2nd"]),
          queryClient.invalidateQueries(["messageCenter"]),
          queryClient.invalidateQueries(["messageCenterUnreadCount"]),
          queryClient.invalidateQueries(["islands_list"]),
          islandFilterId
            ? queryClient.invalidateQueries(["islandFilter", islandFilterId])
            : Promise.resolve(),
          accessToken
            ? queryClient.invalidateQueries([
                "islandHoldingsValuation",
                accessToken ?? null,
              ])
            : Promise.resolve(),
        ]);
        setBuyInfo(null);
        setBuyConfirm(null);
        const px = (res?.certificate?.plot?.x ?? res?.plot?.x) as
          | number
          | undefined;
        const py = (res?.certificate?.plot?.y ?? res?.plot?.y) as
          | number
          | undefined;
        setReceipt({
          x: (typeof px === "number" ? px : 0) as any,
          y: (typeof py === "number" ? py : 0) as any,
          price: res?.priceEUR,
          date: (res?.certificate?.purchasedAt ?? res?.purchasedAt) as any,
        });
        window.setTimeout(() => triggerSuccess(), 50);
      } catch (error) {
        console.error("buySecondaryListing onSuccess failed", error);
      }
    },
    onError: (e: any) => toast({ title: t("buy"), description: e?.message }),
  });

  const cancelListing = useMutation(apiClient.cancelSecondaryListing, {
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries(["secondaryListings"]),
        queryClient.invalidateQueries(["activeListings"]),
        // Update wallet + activity immediately after a successful trade
        queryClient.invalidateQueries(["portfolio"]),
        queryClient.invalidateQueries(["profile"]),
        queryClient.invalidateQueries(["holdingsBreakdown", "auth"]),
        queryClient.invalidateQueries(["walletSummary"]),
        queryClient.invalidateQueries(["messageCenter"]),
        queryClient.invalidateQueries(["messageCenterUnreadCount"]),
        queryClient.invalidateQueries(["certificates"]),
        queryClient.invalidateQueries(["islands_list"]),
        islandFilterId
          ? queryClient.invalidateQueries(["islandFilter", islandFilterId])
          : Promise.resolve(),
        accessToken
          ? queryClient.invalidateQueries([
              "islandHoldingsValuation",
              accessToken ?? null,
            ])
          : Promise.resolve(),
      ]);
      try {
        setInfoOpen(false);
        setViewFilter("MINE");
        triggerSuccess();
      } catch (error) {
        console.error("cancelSecondaryListing onSuccess failed", error);
      }
    },
    onError: (e: any) => toast({ title: "Cancel", description: e?.message }),
  });

  const [receipt, setReceipt] = useState<{
    x: number;
    y: number;
    price: number;
    date: string;
  } | null>(null);
  const [showSuccessOverlay, setShowSuccessOverlay] = useState(false);
  const triggerSuccess = () => {
    setShowSuccessOverlay(true);
    window.setTimeout(() => setShowSuccessOverlay(false), 3000);
  };
  // Swipe + animation state for the focused listing card
  const [dragX, setDragX] = useState(0);
  const [dragY, setDragY] = useState(0);
  const [isDraggingCard, setIsDraggingCard] = useState(false);
  const swipeStartXRef2 = React.useRef<number | null>(null);
  const swipeStartYRef2 = React.useRef<number | null>(null);
  const listingsLenRef = React.useRef(0);
  const animLockRef = React.useRef(false);
  const stackedAnimRef = React.useRef(false);
  const inputSourceRef = React.useRef<"none" | "touch" | "pointer">("none");
  const inputReleaseTimerRef = React.useRef<number | null>(null);

  const SIDE = 140; // side card horizontal offset used in transforms
  // Pointer swipe helpers for iOS Safari reliability
  const pointerStartRef = React.useRef<{
    x: number;
    y: number;
    t: number;
  } | null>(null);
  const lastMoveRef = React.useRef<{ x: number; t: number } | null>(null);
  const [cardAnimDir, setCardAnimDir] = React.useState<"left" | "right" | null>(
    null,
  );
  const [cardAnimT, setCardAnimT] = React.useState(0);
  const [cardAnimAxis, setCardAnimAxis] = React.useState<"x" | "y">("x");
  const doSlide = React.useCallback(
    (dir: -1 | 1) => {
      if (listingsLenRef.current === 0) return;
      if (animLockRef.current) return; // prevent double trigger from touch+pointer
      animLockRef.current = true;
      // Prepare animation: horizontal axis
      setCardAnimAxis("x");
      setCardAnimDir(dir === 1 ? "right" : "left");
      stackedAnimRef.current = true;
      setCardAnimT(0);
      requestAnimationFrame(() => requestAnimationFrame(() => setCardAnimT(1)));
    },
    [cardAnimDir],
  );

  // Vertical & horizontal two-finger swipe on trackpads → navigate listings
  const doSlideVertical = React.useCallback((dir: -1 | 1) => {
    if (listingsLenRef.current === 0) return;
    if (animLockRef.current) return;
    animLockRef.current = true;
    setCardAnimAxis("y");
    setCardAnimDir(dir === 1 ? "right" : "left"); // reuse forward/back semantics
    stackedAnimRef.current = true;
    setCardAnimT(0);
    requestAnimationFrame(() => requestAnimationFrame(() => setCardAnimT(1)));
  }, []);

  const wheelCooldownRef = React.useRef(false);
  const onWheelNavigate = React.useCallback(
    (e: React.WheelEvent<HTMLDivElement>) => {
      if (animLockRef.current || cardAnimDir) return;
      const rawDx =
        Math.abs(e.deltaX) > 2 ? e.deltaX : e.shiftKey ? e.deltaY : 0;
      const rawDy = Math.abs(e.deltaY) > 2 ? e.deltaY : 0;
      if (wheelCooldownRef.current) return;
      // decide axis by larger movement
      const absDx = Math.abs(rawDx);
      const absDy = Math.abs(rawDy);
      if (absDx < 15 && absDy < 15) return;
      e.preventDefault();
      wheelCooldownRef.current = true;
      if (absDy > absDx) {
        // vertical: scrolling down -> next
        doSlideVertical(rawDy > 0 ? 1 : -1);
      } else {
        doSlide(rawDx < 0 ? 1 : -1);
      }
      window.setTimeout(() => (wheelCooldownRef.current = false), 450);
    },
    [doSlide, doSlideVertical, cardAnimDir],
  );

  const lockScroll = () => {
    try {
      document.body.style.overflow = "hidden";
      (document.documentElement || document.body).style.overscrollBehavior =
        "contain";
    } catch {}
  };
  const unlockScroll = () => {
    try {
      document.body.style.overflow = "";
      (document.documentElement || document.body).style.overscrollBehavior =
        "auto";
    } catch {}
  };

  const onCardTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {
    if (!filteredListings || filteredListings.length === 0) return;
    inputSourceRef.current = "touch";
    swipeStartXRef2.current = e.touches?.[0]?.clientX ?? null;
    swipeStartYRef2.current = e.touches?.[0]?.clientY ?? null;
    setIsDraggingCard(true);
    lockScroll();
    setDragX(0);
    setDragY(0);
    e.stopPropagation();
  };
  const onCardTouchMove = (e: React.TouchEvent<HTMLDivElement>) => {
    try {
      e.preventDefault();
    } catch {}
    if (swipeStartXRef2.current == null || swipeStartYRef2.current == null)
      return;
    const cx = e.touches?.[0]?.clientX ?? swipeStartXRef2.current;
    const cy = e.touches?.[0]?.clientY ?? swipeStartYRef2.current;
    const dx = cx - swipeStartXRef2.current;
    const dy = cy - swipeStartYRef2.current;
    setDragX(dx);
    setDragY(dy);
    e.preventDefault();
  };
  const onCardTouchEnd = () => {
    if (!isDraggingCard) return;
    const threshold = 60;
    const dx = dragX;
    const dy = dragY;
    setIsDraggingCard(false);
    setDragX(0);
    setDragY(0);
    swipeStartYRef2.current = null;
    unlockScroll();
    if (Math.abs(dy) > threshold && Math.abs(dy) > Math.abs(dx)) {
      doSlideVertical(dy > 0 ? 1 : -1); // swipe down -> next, up -> prev
    } else if (Math.abs(dx) > threshold) {
      doSlide(dx < 0 ? 1 : -1); // swipe left -> next (dir 1), right -> prev (dir -1)
    }
    if (inputReleaseTimerRef.current)
      window.clearTimeout(inputReleaseTimerRef.current);
    inputReleaseTimerRef.current = window.setTimeout(() => {
      inputSourceRef.current = "none";
    }, 200);
  };

  // Pointer event handlers (more reliable on iPhone/iPad)
  const onPointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!filteredListings || filteredListings.length === 0) return;
    if (inputSourceRef.current === "touch" || animLockRef.current) return; // ignore if touch gesture is active
    inputSourceRef.current = "pointer";
    pointerStartRef.current = { x: e.clientX, y: e.clientY, t: Date.now() };
    lastMoveRef.current = { x: e.clientX, t: Date.now() };
    try {
      (e.currentTarget as any).setPointerCapture?.((e as any).pointerId);
    } catch {}
    setIsDraggingCard(true);
    lockScroll();
    setDragX(0);
  };
  const onPointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!pointerStartRef.current) return;
    const dx = e.clientX - pointerStartRef.current.x;
    setDragX(dx);
    lastMoveRef.current = { x: e.clientX, t: Date.now() };
  };
  const onPointerUp = (e: React.PointerEvent<HTMLDivElement>) => {
    if (inputSourceRef.current === "touch") {
      unlockScroll();
      return;
    } // ignore pointer end if it was a touch gesture
    const start = pointerStartRef.current;
    if (!start) return;
    const last = lastMoveRef.current ?? { x: e.clientX, t: Date.now() };
    const dx = e.clientX - start.x;
    const dy = e.clientY - start.y;
    const dt = Math.max(1, last.t - start.t);
    const vx = (last.x - start.x) / dt; // px/ms
    const vy = (e.clientY - start.y) / dt;
    const threshold = 56;
    const velocityThresh = 0.6 / 1000; // ~0.6 px per ms
    setIsDraggingCard(false);
    setDragX(0);
    setDragY(0);
    pointerStartRef.current = null;
    lastMoveRef.current = null;
    unlockScroll();
    if (
      (Math.abs(dy) > threshold && Math.abs(dy) > Math.abs(dx)) ||
      Math.abs(vy) > velocityThresh
    ) {
      doSlideVertical(dy > 0 ? 1 : -1);
    } else if (Math.abs(dx) > threshold || Math.abs(vx) > velocityThresh) {
      doSlide(dx < 0 ? 1 : -1);
    }
    if (inputReleaseTimerRef.current)
      window.clearTimeout(inputReleaseTimerRef.current);
    inputReleaseTimerRef.current = window.setTimeout(() => {
      inputSourceRef.current = "none";
    }, 120);
  };

  const [previewCert, setPreviewCert] = useState<{
    id: string;
    x: number;
    y: number;
    date?: string;
  } | null>(null);
  const [infoOpen, setInfoOpen] = useState(false);

  const [buyInfo, setBuyInfo] = useState<{
    x: number;
    y: number;
    price: number;
  } | null>(null);
  const [buyConfirm, setBuyConfirm] = useState<{
    x: number;
    y: number;
    price: number;
  } | null>(null);

  const supa = useSupabase();
  const accessToken =
    supa.accessToken ?? (window as any).__supaAccessToken ?? undefined;

  // IMPORTANT: 2nd Market listings are tied to the "actor id" used when listing.
  // If the user is logged in via Supabase, we must use supa.user.id (matches sellerId).
  // Otherwise, fall back to the platform auth userId.
  const myId =
    ((supa as any)?.user?.id as string | undefined) ?? auth.userId ?? null;

  // Island filter: quick-buy multiple listings (cheapest first)
  const [islandBulkQty, setIslandBulkQty] = useState<string>("1");
  const [islandBulkOpen, setIslandBulkOpen] = useState<boolean>(false);
  const [islandBulkBuying, setIslandBulkBuying] = useState<boolean>(false);
  const [islandBulkBought, setIslandBulkBought] = useState<number>(0);
  const [islandBulkResult, setIslandBulkResult] = useState<{
    requested: number;
    bought: number;
    totalSpent: number;
    islandId: string;
  } | null>(null);

  const islandBulkQtyNum = Math.max(0, Math.floor(Number(islandBulkQty || 0)));

  const islandBulkPreview = React.useMemo(() => {
    if (!islandFilterId) return [] as any[];
    const arr = (listings ?? [])
      .filter((l: any) => l?.islandId === islandFilterId)
      .filter((l: any) => (myId ? l?.sellerId !== myId : true))
      .sort((a: any, b: any) => (a?.priceEUR ?? 0) - (b?.priceEUR ?? 0));
    if (islandBulkQtyNum <= 0) return [] as any[];
    return arr.slice(0, islandBulkQtyNum);
  }, [listings, islandFilterId, myId, islandBulkQtyNum]);

  const islandBulkPreviewTotal = React.useMemo(() => {
    return (islandBulkPreview as any[]).reduce(
      (acc: number, l: any) => acc + (Number(l?.priceEUR ?? 0) || 0),
      0,
    );
  }, [islandBulkPreview]);

  const runIslandBulkBuy = React.useCallback(async () => {
    if (isGuest) {
      toast({
        title: "Sign in required",
        description: "Please sign in to buy listings.",
      });
      return;
    }
    if (!islandFilterId) return;
    if (islandBulkBuying) return;

    const target = Math.max(0, islandBulkQtyNum);
    if (!target) {
      toast({
        title: "Enter an amount",
        description: "Enter how many m² you want to buy (e.g. 1, 5, 10).",
      });
      return;
    }

    setIslandBulkResult(null);
    setIslandBulkBought(0);

    // For a single buy, use the existing flow so users still get the receipt UI.
    if (target === 1) {
      try {
        const all = (await apiClient.listSecondaryListings()) as any[];
        const candidates = all
          .filter((l: any) => l?.islandId === islandFilterId)
          .filter((l: any) => (myId ? l?.sellerId !== myId : true))
          .sort((a: any, b: any) => (a?.priceEUR ?? 0) - (b?.priceEUR ?? 0));
        const next = candidates[0];
        if (!next) {
          toast({
            title: "No listings available",
            description: "Try again in a moment.",
          });
          return;
        }
        buyListing.mutate({ x: next.x, y: next.y, accessToken } as any);
        setIslandBulkOpen(false);
        return;
      } catch (e: any) {
        toast({ title: "Error", description: e?.message || "Purchase failed" });
        return;
      }
    }

    setIslandBulkBuying(true);

    let bought = 0;
    let totalSpent = 0;
    let attempts = 0;
    const maxAttempts = Math.max(10, target * 8);

    try {
      while (bought < target && attempts < maxAttempts) {
        attempts++;

        const all = (await apiClient.listSecondaryListings()) as any[];
        const candidates = all
          .filter((l: any) => l?.islandId === islandFilterId)
          .filter((l: any) => (myId ? l?.sellerId !== myId : true))
          .sort((a: any, b: any) => (a?.priceEUR ?? 0) - (b?.priceEUR ?? 0));

        const next = candidates[0];
        if (!next) break;

        try {
          const res = await apiClient.buySecondaryListing({
            x: next.x,
            y: next.y,
            accessToken,
          } as any);
          bought++;
          totalSpent =
            Math.round(
              (totalSpent +
                (Number((res as any)?.priceEUR ?? next?.priceEUR ?? 0) || 0)) *
                100,
            ) / 100;
          setIslandBulkBought(bought);
          if (bought % 2 === 0) {
            try {
              queryClient.invalidateQueries(["secondaryListings"]);
            } catch {}
          }
        } catch (err: any) {
          const msg = String(err?.message ?? "").toLowerCase();
          const isGone =
            msg.includes("not listed") ||
            msg.includes("no longer valid") ||
            msg.includes("already been") ||
            msg.includes("already sold");
          const isBalance = msg.includes("insufficient balance");

          if (isBalance) throw err;
          if (isGone) {
            try {
              queryClient.invalidateQueries(["secondaryListings"]);
            } catch {}
            continue;
          }
          throw err;
        }
      }

      if (bought <= 0) {
        toast({
          title: "Purchase failed",
          description: "Listings changed too fast. Please try again.",
        });
      } else {
        setIslandBulkResult({
          requested: target,
          bought,
          totalSpent,
          islandId: islandFilterId,
        });

        if (bought < target) {
          toast({
            title: "Partially completed",
            description: `Bought ${bought}/${target} m² (some listings were no longer available).`,
          });
        } else {
          toast({
            title: "Purchase successful",
            description: `Bought ${bought} m².`,
          });
        }
      }

      await Promise.all([
        queryClient.invalidateQueries(["secondaryListings"]),
        queryClient.invalidateQueries(["activeListings"]),
        queryClient.invalidateQueries(["profile"]),
        queryClient.invalidateQueries(["portfolio"]),
        queryClient.invalidateQueries(["holdingsBreakdown", "auth"]),
        queryClient.invalidateQueries(["walletSummary"]),
        queryClient.invalidateQueries(["walletRangeSummary"]),
        queryClient.invalidateQueries(["certificates"]),
        queryClient.invalidateQueries(["myPlots"]),
        queryClient.invalidateQueries(["myPlots_2nd"]),
        queryClient.invalidateQueries(["messageCenter"]),
        queryClient.invalidateQueries(["messageCenterUnreadCount"]),
        queryClient.invalidateQueries(["islands_list"]),
        islandFilterId
          ? queryClient.invalidateQueries(["islandFilter", islandFilterId])
          : Promise.resolve(),
        accessToken
          ? queryClient.invalidateQueries([
              "islandHoldingsValuation",
              accessToken ?? null,
            ])
          : Promise.resolve(),
      ]);
    } catch (err: any) {
      toast({ title: "Error", description: err?.message || "Purchase failed" });
      try {
        queryClient.invalidateQueries(["secondaryListings"]);
      } catch {}
    } finally {
      setIslandBulkBuying(false);
      setIslandBulkOpen(false);
    }
  }, [
    isGuest,
    toast,
    islandFilterId,
    islandBulkBuying,
    islandBulkQtyNum,
    apiClient,
    myId,
    buyListing,
    accessToken,
    queryClient,
  ]);

  const handleBuyClick = (l: any) => {
    if (!l) return;
    setBuyInfo({ x: l.x, y: l.y, price: l.priceEUR });
  };

  // Arrow navigation helpers (use same animation path)
  const goPrev = React.useCallback(() => doSlide(-1), [doSlide]);
  const goNext = React.useCallback(() => doSlide(1), [doSlide]);

  const myListedKeys = React.useMemo(() => {
    const s = new Set<string>();
    (listings ?? []).forEach((l: any) => {
      if (myId && l?.sellerId === myId) s.add(`${l?.x}:${l?.y}`);
    });
    return s;
  }, [listings, myId]);

  const { data: profile, isInitialLoading: profileInitialLoading } =
    useQuery<GetProfileOutput>(["profile"], () => apiClient.getProfile(), {
      enabled: !isGuest,
    });
  const { data: payoutProfile, isInitialLoading: payoutProfileInitialLoading } =
    useQuery<GetPayoutProfileOutput>(
      ["payoutProfile_2nd"],
      () => apiClient.getPayoutProfile(),
      { enabled: !isGuest },
    );

  const { data: myPlots, isInitialLoading: myPlotsInitialLoading } = useQuery<
    inferRPCOutputType<"listMyPlots">
  >(["myPlots_2nd"], () => apiClient.listMyPlots(), {
    enabled: auth.status === "authenticated" && !isGuest,
    staleTime: 15_000,
    refetchOnWindowFocus: false,
  });
  const [withdrawOpen, setWithdrawOpen] = useState(false);
  const [withdrawAmount, setWithdrawAmount] = useState<string>("");
  const [withdrawNote, setWithdrawNote] = useState<string>("");
  const withdrawMutation = useMutation(apiClient.submitWithdrawalRequest, {
    onSuccess: async () => {
      setWithdrawOpen(false);
      setWithdrawAmount("");
      setWithdrawNote("");
      await queryClient.invalidateQueries(["profile"]);
      toast({ title: t("requestPayoutBtn"), description: "✓" });
    },
    onError: (e: any) =>
      toast({ title: "Cash out failed", description: e?.message }),
  });

  const { data: marketForPreview } = useQuery<MarketOutput>(
    ["market", "certificateTemplate", !!previewCert],
    () => apiClient.getMarket(),
    { enabled: !!previewCert },
  );
  const previewTemplateUrl = marketForPreview?.certificateTemplateUrl ?? null;
  // Load market to get optional coin image
  const {
    data: marketCoin,
    isInitialLoading: marketCoinInitialLoading,
    error: marketCoinError,
  } = useQuery<MarketOutput>(["market", "coin"], () => apiClient.getMarket(), {
    // Used for coin image + reference price (default listing price).
    staleTime: 15_000,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
    refetchInterval: 30_000,
    refetchIntervalInBackground: false,
    retry: 0,
  });
  const templateUrl = marketCoin?.certificateTemplateUrl ?? null;
  const coinUrl = marketCoin?.coinImageUrl ?? null;

  // Create a transparent-background version of the coin image (removes white box)
  const [coinNoBgUrl, setCoinNoBgUrl] = React.useState<string | null>(null);
  React.useEffect(() => {
    let cancelled = false;
    setCoinNoBgUrl(null);
    if (!coinUrl) return;

    const img = new Image();
    try {
      // Needed to allow pixel access if CDN sends proper CORS headers
      (img as any).crossOrigin = "anonymous";
    } catch {}

    img.onload = () => {
      try {
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth || (img as any).width || 0;
        canvas.height = img.naturalHeight || (img as any).height || 0;
        if (!canvas.width || !canvas.height) return;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        // Remove near-white pixels by turning them transparent
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i] ?? 0;
          const g = data[i + 1] ?? 0;
          const b = data[i + 2] ?? 0;
          const a = data[i + 3] ?? 0;
          if (a === 0) continue;
          const min = Math.min(r, g, b);
          const max = Math.max(r, g, b);
          const isNearWhite = min > 235 && max - min < 25;
          if (isNearWhite) {
            data[i + 3] = 0;
          }
        }
        ctx.putImageData(imageData, 0, 0);
        const out = canvas.toDataURL("image/png");
        if (!cancelled) setCoinNoBgUrl(out);
      } catch {
        // If the browser blocks pixel access (CORS), keep original image
        if (!cancelled) setCoinNoBgUrl(null);
      }
    };

    img.onerror = () => {
      if (!cancelled) setCoinNoBgUrl(null);
    };

    try {
      img.src = coinUrl;
    } catch {
      setCoinNoBgUrl(null);
    }

    return () => {
      cancelled = true;
    };
  }, [coinUrl]);

  // Sorting controls for listings
  const [sortBy, setSortBy] = React.useState<
    "PRICE_DESC" | "PRICE_ASC" | "DATE_DESC" | "DATE_ASC"
  >("PRICE_ASC");
  const sortedListings = React.useMemo(() => {
    const arr = (listings ?? []).slice();
    if (sortBy === "PRICE_DESC")
      arr.sort((a: any, b: any) => (b.priceEUR ?? 0) - (a.priceEUR ?? 0));
    else if (sortBy === "PRICE_ASC")
      arr.sort((a: any, b: any) => (a.priceEUR ?? 0) - (b.priceEUR ?? 0));
    else if (sortBy === "DATE_DESC")
      arr.sort(
        (a: any, b: any) =>
          new Date(b.listedAt ?? 0).getTime() -
          new Date(a.listedAt ?? 0).getTime(),
      );
    else
      arr.sort(
        (a: any, b: any) =>
          new Date(a.listedAt ?? 0).getTime() -
          new Date(b.listedAt ?? 0).getTime(),
      );
    return arr;
  }, [listings, sortBy]);

  // Filters: coordinate search and registered selector
  const [coordQuery, setCoordQuery] = React.useState(coordParam);
  const initialViewFilter = (
    searchParams.get("viewFilter") === "MINE" ? "MINE" : "ALL"
  ) as "ALL" | "MINE";
  const [viewFilter, setViewFilterState] = React.useState<"ALL" | "MINE">(
    initialViewFilter,
  );
  const setViewFilter = (val: "ALL" | "MINE") => {
    setViewFilterState(val);
    try {
      const next = new URLSearchParams(searchParams as any);
      if (val === "MINE") next.set("viewFilter", "MINE");
      else next.delete("viewFilter");
      setSearchParams(next);
    } catch {
      setViewFilterState(val);
    }
  };

  React.useEffect(() => {
    if (viewFilter === "MINE") {
      setInfoOpen(false);
      // If we can't confidently identify the current user, don't show other people's listings here.
      if (!myId || isGuest) {
        setViewFilter("ALL");
      }
    }
  }, [viewFilter, myId, isGuest]);

  const filteredListings = React.useMemo(() => {
    let arr = sortedListings;
    // Coordinate filter: expects "x,y"
    const raw = (coordQuery || "").trim();
    const m = raw.match(/(-?\d+)\s*[,;\s]\s*(-?\d+)/);
    if (m) {
      const x = Number(m[1]);
      const y = Number(m[2]);
      if (Number.isFinite(x) && Number.isFinite(y)) {
        arr = arr.filter((l: any) => l.x === x && l.y === y);
      }
    }
    if (viewFilter === "MINE") {
      // My listings: ONLY my own.
      // If we don't have a user id yet, show nothing (never show other people's listings here).
      if (myId) arr = arr.filter((l: any) => l?.sellerId === myId);
      else arr = [];
    }

    // Official: only show listings from other people
    if (viewFilter === "ALL" && myId) {
      arr = arr.filter((l: any) => l?.sellerId !== myId);
    }

    // Island filter (only show matching island m² when available)
    if (islandFilterId) {
      // Listings include islandId (when provided on listing). Without islandId, it won't be filtered.
      arr = arr.filter((l: any) => l?.islandId === islandFilterId);
    }

    return arr;
  }, [sortedListings, coordQuery, viewFilter, myId, islandFilterId]);

  // keep current count for animations without depending on variable order
  React.useEffect(() => {
    listingsLenRef.current = filteredListings?.length ?? 0;
  }, [filteredListings?.length]);

  React.useEffect(() => {
    const raw = coordParam.trim();
    if (!raw) return;
    if (!filteredListings || filteredListings.length === 0) return;

    let targetIndex = 0;
    const m = raw.match(/(-?\d+)\s*[,;\s]\s*(-?\d+)/);
    if (m) {
      const x = Number(m[1]);
      const y = Number(m[2]);
      if (Number.isFinite(x) && Number.isFinite(y)) {
        const found = filteredListings.findIndex(
          (l: any) => l.x === x && l.y === y,
        );
        if (found >= 0) targetIndex = found;
      }
    }

    setListingIndex(targetIndex);
    setInfoOpen(true);
  }, [coordParam, filteredListings]);

  // Page is locked by default and unlocks via the info chevron — only in Official view
  React.useEffect(() => {
    const docEl = (document.documentElement ||
      (document.body as HTMLElement)) as HTMLElement;
    const prevOverflow = document.body.style.overflow;
    const prevObs = (docEl.style as any).overscrollBehavior;

    // Seite nur in der Official-Ansicht locken; My listings bleibt frei scrollbar
    if (!infoOpen && viewFilter === "ALL") {
      document.body.style.overflow = "hidden";
      (docEl.style as any).overscrollBehavior = "contain";
      try {
        window.scrollTo(0, 0);
      } catch {}
    } else {
      document.body.style.overflow = prevOverflow || "";
      (docEl.style as any).overscrollBehavior = prevObs || "auto";
    }

    return () => {
      document.body.style.overflow = prevOverflow;
      (docEl.style as any).overscrollBehavior = prevObs || "auto";
    };
  }, [infoOpen, viewFilter]);

  // Show one listing at a time with swipe navigation
  const [listingIndex, setListingIndex] = React.useState(0);

  const openInfoAtIndex = React.useCallback(
    (idx: number) => {
      setListingIndex(idx);
      setInfoOpen(true);
      try {
        document.getElementById("listing-info")?.scrollIntoView({
          behavior: "smooth",
          block: "start",
        });
      } catch {}
    },
    [setListingIndex],
  );
  React.useEffect(() => {
    const len = filteredListings?.length ?? 0;
    if (len === 0) {
      if (listingIndex !== 0) setListingIndex(0);
      return;
    }
    if (listingIndex > len - 1) setListingIndex(Math.max(0, len - 1));
  }, [filteredListings?.length]);

  const uiLocked =
    listingsInitialLoading ||
    marketCoinInitialLoading ||
    (!!islandFilterId && islandFilterLoading) ||
    (!isGuest && (profileInitialLoading || payoutProfileInitialLoading));

  const rawLoadError =
    (listingsError as any)?.message ??
    (marketCoinError as any)?.message ??
    ((islandFilterId ? (islandFilterError as any)?.message : null) as any) ??
    null;

  // If we can't load the essentials, show a clear inline error with a retry.
  if (rawLoadError && (!marketCoin || !listings)) {
    const pretty = /script error/i.test(String(rawLoadError))
      ? "Browser blocked error details (Script error). Please reload / try another browser."
      : String(rawLoadError);

    return (
      <ScreenContainer title={t("secondMarket")}>
        <div className="mt-4 mx-auto w-full max-w-[720px] px-4 grid gap-3">
          <div className="rounded-xl border border-destructive/40 bg-destructive/10 p-3 text-sm">
            <div className="font-semibold">2nd Market could not be loaded</div>
            <div className="text-muted-foreground mt-1 break-words">
              {pretty}
            </div>
          </div>
          <Button
            onClick={() => {
              try {
                queryClient.invalidateQueries(["secondaryListings"]);
                queryClient.invalidateQueries(["market", "coin"]);
                if (islandFilterId)
                  queryClient.invalidateQueries([
                    "islandFilter",
                    islandFilterId,
                  ]);
              } catch {}
              void refetch();
            }}
          >
            Retry
          </Button>
        </div>
      </ScreenContainer>
    );
  }

  if (uiLocked) {
    return <AppSpinner label="Loading..." />;
  }

  return (
    <ScreenContainer title={t("secondMarket")}>
      <div className="mt-4 relative">
        <div className="mx-auto w-full max-w-[960px] px-4 sm:px-6 grid gap-3 justify-items-center">
          {/* Active island filter hint */}
          {islandFilterId && (
            <div className="w-full rounded-xl border bg-card p-3 grid gap-3">
              <div className="flex items-center justify-between gap-2">
                <div className="text-sm">
                  Showing listings for island:{" "}
                  <span className="font-medium">
                    {(islandFilter as any)?.island?.name ?? islandFilterId}
                  </span>
                </div>
                <Button
                  size="sm"
                  variant="secondary"
                  onClick={() => {
                    const p = new URLSearchParams(searchParams as any);
                    p.delete("islandId");

                    setSearchParams(p);
                  }}
                >
                  Reset filter
                </Button>
              </div>

              {/* Quick buy for island listings */}
              {viewFilter === "ALL" && (
                <div className="flex flex-col sm:flex-row gap-2 sm:items-center">
                  <Input
                    className="h-9 sm:w-[160px]"
                    inputMode="numeric"
                    placeholder="Quantity"
                    value={islandBulkQty}
                    onChange={(e) =>
                      setIslandBulkQty(e.target.value.replace(/[^0-9]/g, ""))
                    }
                    disabled={islandBulkBuying}
                  />
                  <AlertDialog
                    open={islandBulkOpen}
                    onOpenChange={setIslandBulkOpen}
                  >
                    <AlertDialogTrigger asChild>
                      <Button
                        size="sm"
                        className="h-9"
                        disabled={
                          islandBulkBuying ||
                          islandBulkQtyNum <= 0 ||
                          (islandBulkQtyNum > 0 &&
                            islandBulkPreview.length === 0)
                        }
                        onClick={(e) => {
                          if (isGuest) {
                            e.preventDefault();
                            e.stopPropagation();
                            toast({
                              title: "Sign in required",
                              description: "Please sign in to buy listings.",
                            });
                          }
                        }}
                      >
                        {isGuest
                          ? "Sign in to buy"
                          : islandBulkBuying
                            ? `Buying ${islandBulkBought}/${Math.max(1, islandBulkQtyNum)}…`
                            : islandBulkQtyNum <= 0
                              ? "Buy"
                              : `Buy ${Math.min(islandBulkQtyNum, islandBulkPreview.length || islandBulkQtyNum)} m²`}
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>
                          {`Buy ${Math.max(1, islandBulkQtyNum)} m² from island listings?`}
                        </AlertDialogTitle>
                        <AlertDialogDescription>
                          This buys the cheapest listings first.
                          <div className="mt-2 text-sm">
                            <div>
                              <span className="font-medium">Preview:</span>{" "}
                              {islandBulkPreview.length} listing(s) currently
                              available for this amount.
                            </div>
                            <div>
                              <span className="font-medium">
                                Estimated total:
                              </span>{" "}
                              {formatPPC(islandBulkPreviewTotal)}
                            </div>
                          </div>
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel disabled={islandBulkBuying}>
                          Cancel
                        </AlertDialogCancel>
                        <AlertDialogAction
                          onClick={(e) => {
                            e.preventDefault();
                            void runIslandBulkBuy();
                          }}
                          disabled={islandBulkBuying}
                        >
                          {islandBulkBuying ? "Buying…" : "Yes, buy"}
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>

                  <div className="text-[11px] text-muted-foreground">
                    Tip: enter <span className="font-medium">1</span> to buy a
                    single m².
                  </div>
                </div>
              )}
            </div>
          )}
          {/* View toggle (Official / My listings) */}
          <div className="w-full flex justify-center">
            <div className="inline-flex rounded-full border p-1 bg-secondary/60 shadow-sm">
              <Button
                size="sm"
                className={`rounded-full px-4 py-2 ${viewFilter === "ALL" ? "" : "text-muted-foreground"}`}
                variant={viewFilter === "ALL" ? "default" : "secondary"}
                onClick={() => setViewFilter("ALL")}
                aria-pressed={viewFilter === "ALL"}
              >
                Official
              </Button>
              <Button
                size="sm"
                className={`rounded-full px-4 py-2 ${viewFilter === "MINE" ? "" : "text-muted-foreground"}`}
                variant={viewFilter === "MINE" ? "default" : "secondary"}
                onClick={() => {
                  if (isGuest) {
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                    return;
                  }
                  setViewFilter("MINE");
                }}
                title={isGuest ? "Sign in to view your listings" : undefined}
                aria-pressed={viewFilter === "MINE"}
              >
                My listings
              </Button>
            </div>
          </div>
          <div
            className="w-full relative flex flex-col items-center justify-center gap-4"
            style={{ display: viewFilter === "MINE" ? "none" : undefined }}
          >
            <div className="relative w-full max-w-[380px] md:w-[420px] min-h-[560px] mx-auto overflow-visible">
              {/* Single centered card with swipe animation */}{" "}
              {false &&
                (() => {
                  const __len = filteredListings?.length ?? 0;
                  if (__len === 0 || !filteredListings) return null;
                  const __prevIdx = __len
                    ? (listingIndex - 1 + __len) % __len
                    : 0;
                  const __nextIdx = __len ? (listingIndex + 1) % __len : 0;
                  // Per-card positioning to keep the 3-card cluster centered; only roles morph
                  const animT = cardAnimDir ? cardAnimT : 0;
                  const posX = (role: "left" | "center" | "right") => {
                    // Right swipe: right → center, center → left; left stays anchored
                    if (cardAnimDir === "right") {
                      if (role === "center") return -SIDE * animT;
                      if (role === "right") return SIDE * (1 - animT);
                      return -SIDE; // left anchored
                    }
                    // Left swipe: left → center, center → right; right stays anchored
                    if (cardAnimDir === "left") {
                      if (role === "center") return SIDE * animT;
                      if (role === "left") return -SIDE * (1 - animT);
                      return SIDE; // right anchored
                    }
                    // idle positions
                    if (role === "left") return -SIDE;
                    if (role === "right") return SIDE;
                    return 0;
                  };

                  // Smooth rotation so that only side cards are angled; center is straight
                  const rot = (role: "left" | "center" | "right") => {
                    // Center is always straight (0°). Only side cards are angled; the active side
                    // smoothly straightens to 0° while moving into the center.
                    if (!cardAnimDir)
                      return role === "center" ? 0 : role === "left" ? -10 : 10;
                    if (cardAnimDir === "right") {
                      if (role === "center") return 0; // keep center straight
                      if (role === "right") return 10 * (1 - animT); // straighten to 0
                      return -10; // left remains angled
                    }
                    if (cardAnimDir === "left") {
                      if (role === "center") return 0; // keep center straight
                      if (role === "left") return -10 * (1 - animT); // straighten to 0
                      return 10; // right remains angled
                    }
                    return 0;
                  };

                  // Subtle scale: center 1, sides 0.96 with smooth cross‑fade on move
                  const scaleV = (role: "left" | "center" | "right") => {
                    // Center keeps 1.0 scale; sides are 0.96. Active side grows to 1.0 when entering.
                    if (!cardAnimDir) return role === "center" ? 1 : 0.96;
                    if (cardAnimDir === "right") {
                      if (role === "center") return 1; // fixed
                      if (role === "right") return 0.96 + 0.04 * animT; // to 1.0
                      return 0.96;
                    }
                    if (cardAnimDir === "left") {
                      if (role === "center") return 1; // fixed
                      if (role === "left") return 0.96 + 0.04 * animT; // to 1.0
                      return 0.96;
                    }
                    return 1;
                  };
                  const __transition = isDraggingCard
                    ? "none"
                    : cardAnimDir
                      ? "transform 420ms cubic-bezier(0.22, 0.61, 0.36, 1)"
                      : "transform 0ms";

                  const __renderSide = (
                    l: any,
                    role: "left" | "right",
                    key: string,
                  ) => {
                    const zSide =
                      (cardAnimDir === "right" && role === "right") ||
                      (cardAnimDir === "left" && role === "left")
                        ? 60 // active sliding card should be above the center
                        : 10; // idle side cards stay under the center

                    return (
                      <div
                        key={key}
                        onClick={() => doSlide(role === "left" ? -1 : 1)}
                        className="pointer-events-auto absolute inset-0 flex items-start justify-center cursor-pointer"
                        style={{
                          zIndex: zSide,
                          transform: `translateX(${posX(role)}px) rotate(${rot(role)}deg) scale(${scaleV(role)})`,
                          transition: __transition,
                          willChange: "transform",
                        }}
                      >
                        <div
                          className="rounded-[28px] border bg-card shadow-xl overflow-hidden touch-none overscroll-contain mx-auto w-[min(86vw,340px)]"
                          style={{ minHeight: 540 }}
                        >
                          <div className="p-4 sm:p-5">
                            <div className="flex items-start justify-between gap-3">
                              {coinUrl ? (
                                <img
                                  src={coinNoBgUrl ?? coinUrl}
                                  alt="PP15 coin"
                                  className="w-12 h-12 object-contain select-none"
                                />
                              ) : (
                                <CoinIcon className="w-12 h-12" />
                              )}
                              <div className="text-sm sm:text-base grid gap-1">
                                <div className="text-muted-foreground">
                                  {t("quantity")}:
                                </div>
                                <div className="font-semibold">1 m²</div>
                                <div className="text-muted-foreground mt-1">
                                  {t("certificate")}:
                                </div>
                                {!!l?.certificateId ? (
                                  <div className="text-orange-500 font-semibold">
                                    Yes
                                  </div>
                                ) : (
                                  <div className="text-muted-foreground">
                                    No
                                  </div>
                                )}
                              </div>
                            </div>
                            <div className="mt-1 flex items-center justify-end">
                              <div className="text-3xl sm:text-4xl font-extrabold text-orange-500 leading-none">
                                {currencyUSD(
                                  (filteredListings[listingIndex] as any)
                                    ?.priceEUR ?? 0,
                                )}
                              </div>
                            </div>
                            <div className="mt-3 flex items-center gap-2 min-w-0">
                              {" "}
                              <Avatar className="h-7 w-7">
                                <AvatarImage
                                  src={l?.sellerAvatarUrl ?? undefined}
                                />
                                <AvatarFallback
                                  className="text-transparent"
                                  style={_avatarGradientStyle(
                                    (l?.sellerId ||
                                      l?.sellerName ||
                                      "user") as string,
                                  )}
                                >
                                  <span className="sr-only">
                                    {l?.sellerName ?? "User"}
                                  </span>
                                </AvatarFallback>
                              </Avatar>
                              <div className="text-sm font-medium truncate">
                                {l?.sellerName ?? "User"}
                              </div>
                            </div>
                            <div className="mt-2 text-xs text-muted-foreground">
                              ({l?.x},{l?.y})
                            </div>
                            {l?.certificateId && (
                              <div className="mt-2 text-xs text-muted-foreground">
                                View certificate
                              </div>
                            )}
                            <div className="mt-4">
                              <div className="w-full px-10 py-6 text-xl rounded-xl bg-primary text-primary-foreground text-center select-none">
                                {t("buy")}
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    );
                  };

                  return (
                    <>
                      {__renderSide(
                        filteredListings[__prevIdx] as any,
                        "left",
                        "side-left",
                      )}
                      <div
                        key="center"
                        className="absolute inset-0 flex items-start justify-center"
                        style={{
                          zIndex: 30, // center stays under the incoming side card during slide
                          transform: `translateX(${posX("center")}px) rotate(${rot("center")}deg) scale(${scaleV("center")})`,
                          transition: __transition,
                          pointerEvents: "auto",
                          willChange: "transform",
                        }}
                      >
                        <div
                          className="rounded-[28px] border bg-card shadow-xl overflow-hidden touch-none overscroll-contain mx-auto w-[min(86vw,340px)]"
                          style={{ minHeight: 540, touchAction: "pan-y" }}
                          onTouchStart={onCardTouchStart}
                          onTouchMove={(e) => {
                            onCardTouchMove(e);
                            try {
                              e.preventDefault();
                            } catch {}
                          }}
                          onTouchEnd={onCardTouchEnd}
                          onPointerDown={onPointerDown}
                          onPointerMove={onPointerMove}
                          onPointerUp={onPointerUp}
                          onWheel={(e) => {
                            if (isDraggingCard || cardAnimDir) {
                              e.preventDefault();
                            }
                          }}
                          onTransitionEnd={() => {
                            // Skip if the stacked dual-card animation is driving the transition
                            if (stackedAnimRef.current) return;
                            if (!cardAnimDir) return;
                            const len = filteredListings?.length ?? 0;
                            if (len > 0) {
                              if (cardAnimDir === "right") {
                                setListingIndex((i) => (i + 1) % len);
                              } else {
                                setListingIndex((i) => (i - 1 + len) % len);
                              }
                            }
                            setCardAnimDir(null);
                            setCardAnimT(0);
                            animLockRef.current = false;
                          }}
                        >
                          <div className="p-4 sm:p-5">
                            <div className="flex items-start justify-between gap-3">
                              {coinUrl ? (
                                <img
                                  src={coinNoBgUrl ?? coinUrl}
                                  alt="PP15 coin"
                                  className="w-12 h-12 object-contain select-none"
                                />
                              ) : (
                                <CoinIcon className="w-12 h-12" />
                              )}
                              <div className="text-sm sm:text-base grid gap-1">
                                <div className="text-muted-foreground">
                                  {t("quantity")}:
                                </div>
                                <div className="font-semibold">1 m²</div>
                                <div className="text-muted-foreground mt-1">
                                  {t("certificate")}:
                                </div>
                                {!!(filteredListings[listingIndex] as any)
                                  ?.certificateId ? (
                                  <div className="text-orange-500 font-semibold">
                                    Yes
                                  </div>
                                ) : (
                                  <div className="text-muted-foreground">
                                    No
                                  </div>
                                )}
                              </div>
                            </div>
                            <div className="mt-3 flex items-center gap-2 min-w-0">
                              <Avatar className="h-7 w-7">
                                <AvatarImage
                                  src={
                                    (filteredListings[listingIndex] as any)
                                      ?.sellerAvatarUrl ?? undefined
                                  }
                                />
                                <AvatarFallback
                                  className="text-transparent"
                                  style={_avatarGradientStyle(
                                    (((filteredListings[listingIndex] as any)
                                      ?.sellerId ||
                                      (filteredListings[listingIndex] as any)
                                        ?.sellerName ||
                                      "user") as string) ?? "user",
                                  )}
                                >
                                  <span className="sr-only">
                                    {(filteredListings[listingIndex] as any)
                                      ?.sellerName ?? "User"}
                                  </span>
                                </AvatarFallback>
                              </Avatar>
                              <div className="text-sm font-medium truncate">
                                {(filteredListings[listingIndex] as any)
                                  ?.sellerName ?? "User"}
                              </div>
                            </div>
                            <div className="mt-2 text-xs text-muted-foreground">
                              ({(filteredListings[listingIndex] as any)?.x},
                              {(filteredListings[listingIndex] as any)?.y})
                            </div>
                            {(filteredListings[listingIndex] as any)
                              ?.certificateId && (
                              <div className="mt-2">
                                <Button
                                  variant="link"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setPreviewCert({
                                      id: (
                                        filteredListings[listingIndex] as any
                                      ).certificateId,
                                      x: (filteredListings[listingIndex] as any)
                                        .x,
                                      y: (filteredListings[listingIndex] as any)
                                        .y,
                                      date: (
                                        filteredListings[listingIndex] as any
                                      ).purchasedAt,
                                    });
                                  }}
                                >
                                  View certificate
                                </Button>
                              </div>
                            )}
                            <div className="mt-4">
                              {myId &&
                              (filteredListings[listingIndex] as any)
                                ?.sellerId === myId ? (
                                <Button
                                  size="sm"
                                  variant="default"
                                  className="w-full"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    cancelListing.mutate({
                                      x: (filteredListings[listingIndex] as any)
                                        .x,
                                      y: (filteredListings[listingIndex] as any)
                                        .y,
                                    });
                                  }}
                                >
                                  Cancel listing
                                </Button>
                              ) : (
                                <Button
                                  size="lg"
                                  className="w-full px-10 py-6 text-xl rounded-xl"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    if (isGuest) {
                                      try {
                                        window.dispatchEvent(
                                          new Event("openSignIn"),
                                        );
                                      } catch {}
                                      return;
                                    }
                                    setBuyInfo({
                                      x: (filteredListings[listingIndex] as any)
                                        .x,
                                      y: (filteredListings[listingIndex] as any)
                                        .y,
                                      price: (
                                        filteredListings[listingIndex] as any
                                      ).priceEUR,
                                    });
                                  }}
                                >
                                  {t("buy")}
                                </Button>
                              )}
                            </div>
                          </div>
                        </div>
                      </div>
                      {__renderSide(
                        filteredListings[__nextIdx] as any,
                        "right",
                        "side-right",
                      )}
                    </>
                  );
                })()}{" "}
              {/* Ghost cards disabled for single-card view */}
              {false &&
                (() => {
                  const __len = filteredListings?.length ?? 0;
                  if (__len === 0 || !filteredListings) return null;
                  const __prevIdx = __len
                    ? (listingIndex - 1 + __len) % __len
                    : 0;
                  const __nextIdx = __len ? (listingIndex + 1) % __len : 0;
                  const __shift =
                    (cardAnimDir
                      ? cardAnimDir === "right"
                        ? -SIDE * cardAnimT
                        : SIDE * cardAnimT
                      : 0) + (isDraggingCard ? dragX : 0);
                  return (
                    <>
                      <div
                        className="pointer-events-none absolute left-[-6%] right-[20%] top-3 rounded-[24px] border bg-card/80 backdrop-blur-sm shadow-md opacity-60"
                        style={{
                          transform: `translateX(${Math.max(-24, Math.min(0, __shift))}px)`,
                          transition:
                            "transform 320ms cubic-bezier(0.22, 0.61, 0.36, 1)",
                        }}
                      >
                        <div className="p-4 flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            {coinUrl ? (
                              <img
                                src={coinNoBgUrl ?? coinUrl}
                                alt="PP15 coin"
                                className="w-8 h-8 object-contain select-none"
                              />
                            ) : (
                              <CoinIcon className="w-8 h-8" />
                            )}
                            <div className="text-xs text-muted-foreground">
                              Prev
                            </div>
                          </div>
                          <div className="text-2xl font-extrabold text-orange-500">
                            {currencyUSD(
                              (filteredListings?.[__prevIdx] as any)
                                ?.priceEUR ?? 0,
                            )}
                          </div>
                        </div>
                      </div>
                      <div
                        className="pointer-events-none absolute right-[-6%] left-[20%] top-6 rounded-[24px] border bg-card/80 backdrop-blur-sm shadow-md opacity-60"
                        style={{
                          transform: `translateX(${Math.min(24, Math.max(0, __shift))}px)`,
                          transition:
                            "transform 320ms cubic-bezier(0.22, 0.61, 0.36, 1)",
                        }}
                      >
                        <div className="p-4 flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            {coinUrl ? (
                              <img
                                src={coinNoBgUrl ?? coinUrl}
                                alt="PP15 coin"
                                className="w-8 h-8 object-contain select-none"
                              />
                            ) : (
                              <CoinIcon className="w-8 h-8" />
                            )}
                            <div className="text-xs text-muted-foreground">
                              Next
                            </div>
                          </div>
                          <div className="text-2xl font-extrabold text-orange-500">
                            {currencyUSD(
                              (filteredListings?.[__nextIdx] as any)
                                ?.priceEUR ?? 0,
                            )}
                          </div>
                        </div>
                      </div>
                    </>
                  );
                })()}
              {filteredListings && filteredListings.length > 0 ? (
                (() => {
                  const len = filteredListings.length;
                  // Guard against stale indices during rapid refetches / filter changes.
                  const safeListingIndex = Math.max(
                    0,
                    Math.min(listingIndex, len - 1),
                  );
                  const current =
                    (filteredListings[safeListingIndex] as any) ?? null;
                  const nextIdx = cardAnimDir
                    ? cardAnimDir === "right"
                      ? (safeListingIndex + 1) % len
                      : (safeListingIndex - 1 + len) % len
                    : safeListingIndex;
                  const incoming = (filteredListings[nextIdx] as any) ?? null;

                  const baseCard = (
                    l: any,
                    isMine: boolean,
                    idxForInfo: number,
                  ) => {
                    const s = (l ?? {}) as any;
                    const lx = Number.isFinite(s?.x) ? s.x : 0;
                    const ly = Number.isFinite(s?.y) ? s.y : 0;
                    const listedAt = s?.listedAt as any;

                    return (
                      <div className="p-4 sm:p-5">
                        <div className="flex items-start justify-between gap-3">
                          <div className="flex items-center gap-3">
                            {coinUrl ? (
                              <img
                                src={coinUrl}
                                alt="PP15 coin"
                                className="w-12 h-12 object-contain select-none"
                              />
                            ) : (
                              <CoinIcon className="w-12 h-12" />
                            )}
                          </div>
                          <div className="flex items-center gap-2">
                            <Button
                              variant="secondary"
                              size="icon"
                              aria-label="Info"
                              disabled={!len}
                              onClick={(e) => {
                                e.stopPropagation();
                                openInfoAtIndex(idxForInfo);
                              }}
                            >
                              <Info className="h-4 w-4" />
                            </Button>
                            {filteredListings.length > 1 && (
                              <div className="hidden md:flex items-center gap-2">
                                <Button
                                  variant="secondary"
                                  size="icon"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    goPrev();
                                  }}
                                  aria-label="Prev"
                                >
                                  ‹
                                </Button>
                                <Button
                                  variant="secondary"
                                  size="icon"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    goNext();
                                  }}
                                  aria-label="Next"
                                >
                                  ›
                                </Button>
                              </div>
                            )}
                          </div>
                        </div>{" "}
                        <div className="mt-3 grid grid-cols-2 gap-2 text-sm min-h-[260px]">
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              Seller
                            </div>
                            <div className="flex items-center gap-2 font-semibold">
                              <Avatar className="h-5 w-5">
                                <AvatarImage
                                  src={s?.sellerAvatarUrl ?? undefined}
                                />
                                <AvatarFallback
                                  className="text-transparent"
                                  style={_avatarGradientStyle(
                                    (s?.sellerId ||
                                      s?.sellerName ||
                                      "user") as string,
                                  )}
                                >
                                  <span className="sr-only">
                                    {s?.sellerName ?? "User"}
                                  </span>
                                </AvatarFallback>
                              </Avatar>
                              <span className="truncate">
                                {s?.sellerName ?? "User"}
                              </span>
                            </div>
                          </div>
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              Location
                            </div>
                            <div className="font-semibold">
                              ({lx},{ly})
                            </div>
                          </div>
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              {t("quantity")}
                            </div>
                            <div className="font-semibold">1 m²</div>
                          </div>
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              {t("certificate")}
                            </div>
                            <div className="font-semibold">
                              {s?.certificateId ? "Yes" : "No"}
                            </div>
                          </div>
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              Listed
                            </div>
                            <div className="font-semibold">
                              {listedAt ? formatDateDDMMYY(listedAt) : "—"}
                            </div>
                          </div>
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              Status
                            </div>
                            <div className="font-semibold">
                              {s?.certificateId ? t("registered") : "—"}
                            </div>
                          </div>
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              Age
                            </div>
                            <div className="font-semibold">
                              {listedAt
                                ? `${Math.max(
                                    1,
                                    Math.floor(
                                      (Date.now() -
                                        new Date(listedAt as any).getTime()) /
                                        86400000,
                                    ),
                                  )} d`
                                : "—"}
                            </div>
                          </div>
                          <div className="rounded-lg border p-2">
                            <div className="text-xs text-muted-foreground">
                              Listing
                            </div>
                            <div className="font-semibold">
                              {lx},{ly}
                            </div>
                          </div>
                        </div>
                        <div className="mt-4">
                          <div className="mb-2 text-3xl sm:text-4xl font-extrabold text-orange-500 text-center">
                            {formatPPC(s?.priceEUR)}
                          </div>
                          {isMine ? (
                            <Button
                              size="sm"
                              variant="secondary"
                              className="w-full"
                              disabled={
                                !Number.isFinite(lx) || !Number.isFinite(ly)
                              }
                              onClick={() =>
                                cancelListing.mutate({ x: lx, y: ly })
                              }
                            >
                              Cancel listing
                            </Button>
                          ) : (
                            <Button
                              size="lg"
                              className="w-full px-10 py-6 text-xl rounded-xl"
                              disabled={
                                isGuest ||
                                !Number.isFinite(lx) ||
                                !Number.isFinite(ly)
                              }
                              onClick={() => handleBuyClick(s)}
                            >
                              Buy Collectible
                            </Button>
                          )}
                        </div>
                      </div>
                    );
                  };

                  if (!cardAnimDir) {
                    const isMine =
                      !!myId && !!current && current?.sellerId === myId;
                    return (
                      <div
                        className="rounded-[28px] border bg-card shadow-xl overflow-visible mx-auto select-none"
                        style={{ minHeight: 540 }}
                        onClick={() => {
                          if (isDraggingCard || cardAnimDir) return;
                          setInfoOpen(true);
                          try {
                            document
                              .getElementById("listing-info")
                              ?.scrollIntoView({
                                behavior: "smooth",
                                block: "start",
                              });
                          } catch {}
                        }}
                        onTouchStart={onCardTouchStart}
                        onTouchMove={(e) => {
                          onCardTouchMove(e);
                          try {
                            e.preventDefault();
                          } catch {}
                        }}
                        onTouchEnd={onCardTouchEnd}
                        onWheel={onWheelNavigate}
                      >
                        {baseCard(current, !!isMine, safeListingIndex)}
                        {filteredListings.length > 1 && (
                          <>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                goPrev();
                              }}
                              aria-label="Prev"
                              className="absolute left-2 top-1/2 -translate-y-1/2 bg-background/70 rounded-full p-2 border shadow sm:hidden"
                            >
                              ‹
                            </button>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                goNext();
                              }}
                              aria-label="Next"
                              className="absolute right-2 top-1/2 -translate-y-1/2 bg-background/70 rounded-full p-2 border shadow sm:hidden"
                            >
                              ›
                            </button>
                          </>
                        )}
                      </div>
                    );
                  }

                  // Animation: stacked with axis awareness (x or y)
                  const isForward = cardAnimDir === "right";
                  const offset = SIDE;
                  let outTransform = `translate3d(0,0,0) scale(1)`;
                  let inTransform = `translate3d(0,0,0) scale(1)`;
                  if (cardAnimAxis === "x") {
                    const inTx =
                      (isForward ? 1 : -1) * offset * (1 - cardAnimT);
                    outTransform = `translate3d(0px,0,0) scale(1)`;
                    inTransform = `translate3d(${inTx}px,0,0) scale(1)`;
                  } else {
                    const inTy =
                      (isForward ? 1 : -1) * offset * (1 - cardAnimT);
                    outTransform = `translate3d(0,0px,0) scale(1)`;
                    inTransform = `translate3d(0,${inTy}px,0) scale(1)`;
                  }
                  const outOpacity = Math.max(0, 1 - cardAnimT);

                  const transition =
                    "transform 520ms cubic-bezier(0.22, 0.61, 0.36, 1), opacity 520ms ease";
                  const isMineOut =
                    !!myId && !!current && current?.sellerId === myId;
                  const isMineIn =
                    !!myId && !!incoming && incoming?.sellerId === myId;

                  return (
                    <div
                      className="relative w-full"
                      style={{ minHeight: 540, pointerEvents: "none" }}
                    >
                      {/* Outgoing card: fixed in center, behind incoming */}
                      <div
                        className="absolute inset-0 rounded-[28px] border bg-card shadow-xl overflow-visible mx-auto select-none"
                        style={{
                          transform: outTransform,
                          opacity: outOpacity,
                          transition,
                          zIndex: 40, // always behind incoming
                          willChange: "transform, opacity",
                          backfaceVisibility: "hidden",
                          WebkitBackfaceVisibility: "hidden",
                        }}
                      >
                        {baseCard(current, !!isMineOut, safeListingIndex)}
                      </div>

                      {/* Incoming card: slides in on selected axis above */}
                      <div
                        className="absolute inset-0 rounded-[28px] border bg-card shadow-xl overflow-visible mx-auto select-none"
                        style={{
                          transform: inTransform,
                          transition,
                          zIndex: 60, // always above outgoing
                          willChange: "transform, opacity",
                          backfaceVisibility: "hidden",
                          WebkitBackfaceVisibility: "hidden",
                        }}
                        onTransitionEnd={(e) => {
                          if ((e as any)?.propertyName !== "transform") return;
                          const lenLocal = filteredListings?.length ?? 0;
                          if (lenLocal > 0) {
                            if (isForward)
                              setListingIndex((i) => (i + 1) % lenLocal);
                            else
                              setListingIndex(
                                (i) => (i - 1 + lenLocal) % lenLocal,
                              );
                          }
                          setCardAnimDir(null);
                          setCardAnimT(0);
                          animLockRef.current = false;
                          stackedAnimRef.current = false;
                        }}
                      >
                        {baseCard(incoming, !!isMineIn, nextIdx)}
                      </div>
                    </div>
                  );
                })()
              ) : (
                <div className="text-center text-sm text-muted-foreground py-6">
                  {t("noListings")}
                </div>
              )}
            </div>
            {/* Action button: centered under the card */}
            <div className="flex items-center justify-center w-full">
              <Button
                size="lg"
                className="rounded-2xl shadow-lg w-full max-w-[420px]"
                onClick={() => {
                  if (isGuest) {
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                    return;
                  }
                  navigate("/map?list=1");
                }}
                title={isGuest ? "Sign in to list your m²" : undefined}
              >
                List my m2 collectible
              </Button>
            </div>
          </div>

          {/* Info panel anchor: always in DOM so scrollIntoView works; expands when infoOpen */}
          <div
            id="listing-info"
            className="w-full max-w-[960px] mx-auto scroll-mt-[calc(5rem+var(--safe-top))]"
          >
            {/* Right of the card: action button to sell own m² (desktop only) */}
            <div className="hidden">
              <Button
                size="lg"
                className="rounded-2xl shadow-lg"
                onClick={() => {
                  if (isGuest) {
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                    return;
                  }
                  navigate("/map?list=1");
                }}
                title={isGuest ? "Sign in to list your m²" : undefined}
              >
                List my m2 collectible
              </Button>
            </div>
            <div
              className={`${infoOpen ? "block" : "h-[1px] overflow-hidden"}`}
            >
              {infoOpen && (
                <Card className="overflow-hidden">
                  <CardHeader className="pb-2 flex items-center justify-between">
                    <Button
                      variant="secondary"
                      className="px-3 py-2 rounded-xl inline-flex items-center gap-2"
                      aria-label="Listings"
                      onClick={() => {
                        setInfoOpen(false);
                        try {
                          document
                            .getElementById("listing-info")
                            ?.scrollIntoView({
                              behavior: "smooth",
                              block: "start",
                            });
                        } catch {}
                      }}
                    >
                      <ArrowLeft className="h-4 w-4" />
                      <span>Listings</span>
                    </Button>
                    <CardTitle className="text-base">Offer details</CardTitle>
                    <div />
                  </CardHeader>
                  <CardContent>
                    {filteredListings && filteredListings.length > 0 ? (
                      (() => {
                        const l: any = filteredListings[listingIndex];
                        return (
                          <div className="grid gap-4 md:grid-cols-2 text-sm">
                            {/* Left: simple bullet points as before */}{" "}
                            <div className="space-y-3">
                              <ul className="list-disc pl-4 space-y-1">
                                <li>
                                  <span className="font-medium">Price:</span>{" "}
                                  {formatPPC(l?.priceEUR ?? 0)}
                                </li>
                                <li>
                                  <span className="font-medium">Location:</span>{" "}
                                  ({l?.x},{l?.y})
                                </li>
                                <li>
                                  <span className="font-medium">Quantity:</span>{" "}
                                  1 m² collectible
                                </li>
                                <li>
                                  <span className="font-medium">
                                    Certificate:
                                  </span>{" "}
                                  {l?.certificateId ? "Yes" : "No"}
                                </li>
                                <li>
                                  <span className="font-medium">Status:</span>{" "}
                                  {l?.certificateId ? t("registered") : "—"}
                                </li>
                                <li>
                                  <span className="font-medium">Seller:</span>{" "}
                                  {l?.sellerName ?? "User"}
                                </li>
                                <li>
                                  <span className="font-medium">Listed:</span>{" "}
                                  {l?.listedAt
                                    ? formatDateDDMMYY(l.listedAt as any)
                                    : "—"}
                                </li>
                                <li>
                                  <span className="font-medium">Age:</span>{" "}
                                  {l?.listedAt
                                    ? `${Math.max(
                                        1,
                                        Math.floor(
                                          (Date.now() -
                                            new Date(
                                              l.listedAt as any,
                                            ).getTime()) /
                                            86400000,
                                        ),
                                      )} d`
                                    : "—"}
                                </li>
                                <li>
                                  <span className="font-medium">Listing:</span>{" "}
                                  {l?.x},{l?.y}
                                </li>
                              </ul>
                              <div className="flex flex-wrap gap-2 pt-1">
                                {l?.certificateId && (
                                  <Button
                                    variant="default"
                                    className="px-5 py-3 text-sm sm:text-base rounded-xl"
                                    onClick={() =>
                                      setPreviewCert({
                                        id: l.certificateId,
                                        x: l.x,
                                        y: l.y,
                                        date: l.purchasedAt,
                                      })
                                    }
                                  >
                                    View collectible certificate
                                  </Button>
                                )}
                                {myId && l?.sellerId === myId ? (
                                  <AlertDialog>
                                    <AlertDialogTrigger asChild>
                                      <Button
                                        variant="default"
                                        className="px-5 py-3 text-sm sm:text-base rounded-xl"
                                      >
                                        Cancel listing
                                      </Button>
                                    </AlertDialogTrigger>
                                    <AlertDialogContent>
                                      <AlertDialogHeader>
                                        <AlertDialogTitle>
                                          Remove listing?
                                        </AlertDialogTitle>
                                        <AlertDialogDescription>
                                          Your m² will be removed from the 2nd
                                          Market. Afterwards, the m² belongs to
                                          you again and is no longer listed for
                                          sale.
                                        </AlertDialogDescription>
                                      </AlertDialogHeader>
                                      <AlertDialogFooter>
                                        <AlertDialogCancel>
                                          Cancel
                                        </AlertDialogCancel>
                                        <AlertDialogAction
                                          onClick={() =>
                                            cancelListing.mutate({
                                              x: l.x,
                                              y: l.y,
                                            })
                                          }
                                        >
                                          Yes, delete listing
                                        </AlertDialogAction>
                                      </AlertDialogFooter>
                                    </AlertDialogContent>
                                  </AlertDialog>
                                ) : (
                                  <Button
                                    className="px-5 py-3 text-sm sm:text-base rounded-xl"
                                    onClick={() => {
                                      if (isGuest) {
                                        try {
                                          window.dispatchEvent(
                                            new Event("openSignIn"),
                                          );
                                        } catch {}
                                        return;
                                      }
                                      handleBuyClick(l);
                                    }}
                                  >
                                    Buy Collectible
                                  </Button>
                                )}
                              </div>
                            </div>
                            {/* Right: certificate preview as before */}{" "}
                            <div>
                              <div className="rounded-xl border p-3 flex items-center justify-center bg-card">
                                {previewTemplateUrl || templateUrl ? (
                                  <div className="w-full max-w-[320px] mx-auto">
                                    <AspectRatio ratio={210 / 297}>
                                      <div className="absolute inset-0 rounded-xl overflow-hidden border bg-card">
                                        <img
                                          src={
                                            (previewTemplateUrl ??
                                              templateUrl) as any
                                          }
                                          alt="Certificate"
                                          className="w-full h-full object-contain select-none pointer-events-none"
                                          onError={(e: any) => {
                                            try {
                                              e.currentTarget.style.display =
                                                "none";
                                            } catch {}
                                          }}
                                        />
                                      </div>
                                    </AspectRatio>
                                  </div>
                                ) : (
                                  <div className="text-sm text-muted-foreground">
                                    No template available.
                                  </div>
                                )}
                              </div>
                            </div>
                          </div>
                        );
                      })()
                    ) : (
                      <div className="text-sm text-muted-foreground">
                        No offer selected.
                      </div>
                    )}
                  </CardContent>
                </Card>
              )}
            </div>
          </div>

          <Card
            className="w-full max-w-[820px] mx-auto"
            style={{ display: infoOpen ? "none" : undefined }}
          >
            <CardHeader className="pb-2 flex flex-col items-center justify-center gap-2 text-center">
              <CardTitle className="text-base">{t("listPlot")}</CardTitle>

              <div className="flex justify-center w-full">
                <Button
                  size="sm"
                  className="w-full sm:w-auto px-6"
                  onClick={() => {
                    if (isGuest) {
                      try {
                        window.dispatchEvent(new Event("openSignIn"));
                      } catch {}
                      return;
                    }
                    setMyListDrawerOpen(true);
                  }}
                >
                  List my m²
                </Button>{" "}
              </div>
            </CardHeader>
            <CardContent className="grid gap-3">
              <div className="text-xs text-muted-foreground">
                Tip: Use the button above to open the map, select your plot, and
                set the price there. The matching certificate will be assigned
                automatically.
              </div>
            </CardContent>
          </Card>

          <div className="mt-1 text-[11px] text-muted-foreground flex items-center gap-2 justify-center text-center">
            <span>Auto refresh ~every 1 second.</span>
            <button
              type="button"
              aria-label="Refresh now"
              className="inline-flex items-center justify-center rounded-full p-1 hover:bg-secondary focus:outline-none"
              onClick={() => {
                try {
                  queryClient.invalidateQueries(["secondaryListings"]);
                } catch {}
              }}
              title="Refresh now"
            >
              <RefreshCcw className="h-3.5 w-3.5" />
            </button>
          </div>
          <div className="text-[11px] text-muted-foreground text-center">
            Secure processing via Wallet & payouts.
          </div>

          <Card
            className="overflow-visible w-full max-w-[960px] mx-auto"
            style={{
              display: viewFilter === "MINE" && !infoOpen ? undefined : "none",
            }}
          >
            <CardHeader className="pb-2 flex items-center justify-between gap-2">
              <div className="flex flex-col gap-1">
                <CardTitle className="text-base">{t("listings")}</CardTitle>
              </div>
              <div className="flex flex-wrap gap-2 items-center justify-end">
                {/* Coord search */}
                {viewFilter === "ALL" && (
                  <Input
                    className="w-[160px] sm:w-[200px]"
                    placeholder="x,y"
                    value={coordQuery}
                    onChange={(e) => setCoordQuery(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Escape") setCoordQuery("");
                    }}
                  />
                )}
                {/* View filter: All vs My listings */}
                <div className="flex gap-1">
                  <Button
                    size="sm"
                    variant={viewFilter === "ALL" ? "default" : "secondary"}
                    onClick={() => setViewFilter("ALL")}
                  >
                    All
                  </Button>
                  <Button
                    size="sm"
                    variant={viewFilter === "MINE" ? "default" : "secondary"}
                    onClick={() => {
                      if (isGuest) {
                        try {
                          window.dispatchEvent(new Event("openSignIn"));
                        } catch {}
                        return;
                      }
                      setViewFilter("MINE");
                    }}
                    title={
                      isGuest ? "Sign in to view your listings" : undefined
                    }
                  >
                    My listings
                  </Button>
                </div>
                {/* Sort menu (hidden in My listings) */}
                {viewFilter === "ALL" && (
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="secondary" size="sm">
                        {sortBy === "PRICE_DESC"
                          ? "Price: high → low"
                          : sortBy === "PRICE_ASC"
                            ? "Price: low → high"
                            : sortBy === "DATE_DESC"
                              ? "Date: newest → oldest"
                              : "Date: oldest → newest"}
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem
                        onSelect={(e) => {
                          e.preventDefault();
                          setSortBy("PRICE_DESC");
                        }}
                      >
                        Price: high → low
                      </DropdownMenuItem>
                      <DropdownMenuItem
                        onSelect={(e) => {
                          e.preventDefault();
                          setSortBy("PRICE_ASC");
                        }}
                      >
                        Price: low → high
                      </DropdownMenuItem>
                      <DropdownMenuSeparator />
                      <DropdownMenuItem
                        onSelect={(e) => {
                          e.preventDefault();
                          setSortBy("DATE_DESC");
                        }}
                      >
                        Date: newest → oldest
                      </DropdownMenuItem>
                      <DropdownMenuItem
                        onSelect={(e) => {
                          e.preventDefault();
                          setSortBy("DATE_ASC");
                        }}
                      >
                        Date: oldest → newest
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                )}
                {viewFilter === "MINE" && (
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="secondary" size="sm">
                        {sortBy === "DATE_DESC"
                          ? "Date: newest → oldest"
                          : "Date: oldest → newest"}
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem
                        onSelect={(e) => {
                          e.preventDefault();
                          setSortBy("DATE_DESC");
                        }}
                      >
                        Date: newest → oldest
                      </DropdownMenuItem>
                      <DropdownMenuItem
                        onSelect={(e) => {
                          e.preventDefault();
                          setSortBy("DATE_ASC");
                        }}
                      >
                        Date: oldest → newest
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                )}
                {viewFilter === "ALL" && (
                  <Button
                    size="sm"
                    variant="secondary"
                    onClick={() => {
                      setCoordQuery("");
                      setViewFilter("ALL");
                    }}
                  >
                    Reset
                  </Button>
                )}
              </div>
            </CardHeader>
            <CardContent className="grid gap-3 text-sm">
              {isFetching && (
                <div className="text-muted-foreground">{t("updating")}</div>
              )}
              {(!filteredListings || filteredListings.length === 0) &&
                !isFetching && (
                  <div className="text-muted-foreground">{t("noListings")}</div>
                )}
              <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3">
                {filteredListings?.map((l: any, idx: number) => {
                  const hasCert = !!l.certificateId;
                  return (
                    <div
                      key={`${l.x}:${l.y}:${idx}`}
                      role="button"
                      tabIndex={0}
                      className="rounded-2xl border bg-card/80 overflow-hidden text-left group focus:outline-none focus:ring-2 focus:ring-ring shadow-sm hover:shadow-md transition-shadow hover:border-primary/40"
                      onClick={() => openInfoAtIndex(idx)}
                      onKeyDown={(e) => {
                        if (e.key === "Enter") {
                          e.preventDefault();
                          openInfoAtIndex(idx);
                        }
                      }}
                    >
                      <AspectRatio ratio={4 / 3}>
                        <div className="absolute inset-0 p-3 flex flex-col">
                          <div className="flex items-start justify-between gap-2">
                            {coinUrl ? (
                              <img
                                src={coinNoBgUrl ?? coinUrl}
                                alt="PP15 coin"
                                className="w-8 h-8 object-contain select-none"
                              />
                            ) : (
                              <CoinIcon className="w-8 h-8" />
                            )}

                            <div className="flex items-center gap-1">
                              {hasCert && (
                                <span className="text-[10px] px-2 py-0.5 rounded-full bg-emerald-500/15 text-emerald-600 border border-emerald-500/30">
                                  Cert
                                </span>
                              )}
                              <button
                                type="button"
                                aria-label="Info"
                                className="rounded-full p-1 border bg-background/70 hover:bg-secondary active:scale-95 transition-transform"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  openInfoAtIndex(idx);
                                }}
                              >
                                <Info className="h-4 w-4" />
                              </button>
                            </div>
                          </div>
                          <div className="mt-auto">
                            <div className="text-xs text-muted-foreground">
                              ({l.x},{l.y})
                            </div>
                            <div className="text-2xl font-extrabold text-orange-500 leading-none">
                              {formatPPC(l.priceEUR)}
                            </div>
                          </div>
                        </div>
                      </AspectRatio>
                    </div>
                  );
                })}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>

      <Drawer
        open={!!receipt || !!islandBulkResult}
        onOpenChange={(v) => {
          if (!v) {
            setReceipt(null);
            setIslandBulkResult(null);
          }
        }}
      >
        <DrawerContent>
          <DrawerHeader className="text-left">
            <DrawerTitle>{t("certificateTitle")}</DrawerTitle>
            <DrawerDescription>
              {receipt ? (
                t(
                  "certificateText",
                  receipt.x,
                  receipt.y,
                  formatPPC(receipt.price),
                  formatDateTime(receipt.date),
                )
              ) : islandBulkResult ? (
                <div className="space-y-2">
                  <div className="text-sm text-muted-foreground">
                    Island purchase summary
                  </div>
                  <div>
                    Bought{" "}
                    <span className="font-medium">
                      {islandBulkResult.bought}
                    </span>
                    {islandBulkResult.bought !== islandBulkResult.requested
                      ? ` / ${islandBulkResult.requested}`
                      : ""}{" "}
                    m²
                  </div>
                  <div>
                    Total paid:{" "}
                    <span className="font-medium">
                      {formatPPC(islandBulkResult.totalSpent)}
                    </span>
                  </div>
                </div>
              ) : null}
            </DrawerDescription>
          </DrawerHeader>
          <DrawerFooter>
            <Button
              variant="secondary"
              onClick={() => {
                setReceipt(null);
                setIslandBulkResult(null);
              }}
            >
              {t("close")}
            </Button>
          </DrawerFooter>
        </DrawerContent>
      </Drawer>

      {/* Small certificate preview for listings */}
      <Drawer
        open={!!previewCert}
        onOpenChange={(v) => !v && setPreviewCert(null)}
      >
        <DrawerContent>
          <DrawerHeader className="text-left relative">
            <DrawerTitle>{t("certificateTitle")}</DrawerTitle>
            <DrawerDescription>
              {previewCert
                ? `(${previewCert.x},${previewCert.y}) • ${formatDateTime(previewCert.date)}`
                : ""}
            </DrawerDescription>
            <DrawerClose asChild>
              <button
                aria-label={t("close")}
                className="absolute right-2 top-2 rounded-full p-1 hover:bg-secondary active:scale-95 transition-transform"
                onClick={() => setPreviewCert(null)}
              >
                <X className="h-4 w-4" />
              </button>
            </DrawerClose>
          </DrawerHeader>
          <div className="px-4 pb-4 flex items-center justify-center">
            <div className="relative w-full max-w-[300px] sm:max-w-[340px]">
              <AspectRatio ratio={210 / 297}>
                <div className="absolute inset-0 border rounded-lg overflow-hidden bg-card">
                  {previewTemplateUrl ? (
                    <img
                      src={previewTemplateUrl}
                      alt="Certificate"
                      className="w-full h-full object-contain select-none pointer-events-none"
                      onError={(e: any) => {
                        try {
                          e.currentTarget.style.display = "none";
                        } catch {}
                      }}
                    />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center text-xs text-muted-foreground">
                      No template
                    </div>
                  )}
                  {previewCert && (
                    <div className="absolute left-2 bottom-2 text-[10px] px-1.5 py-0.5 rounded bg-background/80">
                      {formatDateTime(previewCert.date)} • ({previewCert.x},
                      {previewCert.y})
                    </div>
                  )}
                </div>
              </AspectRatio>
            </div>
          </div>
          <DrawerFooter className="pt-2 flex gap-2">
            {previewCert?.x !== undefined && previewCert?.y !== undefined && (
              <Button
                size="sm"
                className="px-2 py-1 text-xs"
                onClick={() => {
                  const x = previewCert!.x as number;
                  const y = previewCert!.y as number;
                  setPreviewCert(null);
                  navigate(`/map?focusX=${x}&focusY=${y}`);
                }}
              >
                Show on map
              </Button>
            )}
            <Button
              size="sm"
              variant="secondary"
              className="px-2 py-1 text-xs"
              onClick={() => setPreviewCert(null)}
            >
              {t("close")}
            </Button>
          </DrawerFooter>
        </DrawerContent>
      </Drawer>

      {/* My plots: quick listing flow for mobile Second Market */}
      <Drawer open={myListDrawerOpen} onOpenChange={setMyListDrawerOpen}>
        <DrawerContent>
          <DrawerHeader className="text-left">
            <DrawerTitle>My m²</DrawerTitle>
            <DrawerDescription>
              Select your m², set a price, and create listings right here.
            </DrawerDescription>
          </DrawerHeader>
          <div className="px-4 pb-4 grid gap-3 max-h-[60vh] overflow-y-auto">
            {isGuest ? (
              <div className="grid gap-2">
                <div className="text-sm text-muted-foreground">
                  Not available without login.
                </div>
              </div>
            ) : myPlotsInitialLoading ? (
              <AppSpinner label="Loading..." />
            ) : !myPlots || (myPlots as any[]).length === 0 ? (
              <div className="text-sm text-muted-foreground">
                You don't own any m² yet.
              </div>
            ) : (
              <div className="grid gap-2">
                {(myPlots as any[]).map((p: any, idx: number) => {
                  const key = `${p.x}:${p.y}`;
                  const isListedMine = myListedKeys.has(key);
                  const checked = !!myPlotSelection[key];
                  const defaultPrice = String(
                    Math.round(
                      ((marketCoin as any)?.pricePerM2CHF ?? 0) * 100,
                    ) / 100,
                  );
                  const priceVal = myPlotPrices[key] ?? defaultPrice;

                  return (
                    <div
                      key={`${key}:${idx}`}
                      className="rounded-xl border bg-card p-3"
                    >
                      <div className="flex items-start justify-between gap-3">
                        <div className="min-w-0">
                          <div className="font-medium">
                            ({p.x},{p.y})
                          </div>
                          <div className="text-xs text-muted-foreground">
                            {p.createdAt ? formatDateTime(p.createdAt) : ""}
                          </div>
                        </div>
                        {isListedMine ? (
                          <Badge variant="secondary">Already listed</Badge>
                        ) : (
                          <div className="flex items-center gap-2">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const next = !!v;
                                setMyPlotSelection((prev) => ({
                                  ...prev,
                                  [key]: next,
                                }));
                                if (next) {
                                  setMyPlotPrices((prev) => ({
                                    ...prev,
                                    [key]: prev[key] ?? defaultPrice,
                                  }));
                                }
                              }}
                            />
                            <span className="text-xs text-muted-foreground">
                              select
                            </span>
                          </div>
                        )}
                      </div>

                      {isListedMine ? (
                        <div className="mt-3">
                          <Button
                            size="sm"
                            variant="secondary"
                            className="w-full"
                            onClick={() =>
                              cancelListing.mutate({
                                x: Number(p.x),
                                y: Number(p.y),
                              })
                            }
                          >
                            Remove listing
                          </Button>
                        </div>
                      ) : (
                        <div className="mt-3 grid grid-cols-3 items-center gap-2">
                          <Label className="col-span-1">{t("price")}</Label>
                          <Input
                            className="col-span-2"
                            type="tel"
                            inputMode="decimal"
                            value={priceVal}
                            onChange={(e) =>
                              setMyPlotPrices((prev) => ({
                                ...prev,
                                [key]: e.target.value
                                  .replace(/[^0-9.,]/g, "")
                                  .replace(",", "."),
                              }))
                            }
                            placeholder={defaultPrice}
                            disabled={!checked}
                          />
                        </div>
                      )}

                      <div className="mt-2 flex gap-2">
                        <Button
                          size="sm"
                          variant="secondary"
                          className="flex-1"
                          onClick={() =>
                            navigate(`/map?list=1&focusX=${p.x}&focusY=${p.y}`)
                          }
                        >
                          On map
                        </Button>
                        {!isListedMine && (
                          <Button
                            size="sm"
                            className="flex-1"
                            variant="default"
                            disabled={!checked}
                            onClick={() => {
                              const price = Number(priceVal || 0);
                              if (!Number.isFinite(price) || price <= 0) return;
                              (async () => {
                                try {
                                  await apiClient.createSecondaryListing({
                                    x: Number(p.x),
                                    y: Number(p.y),
                                    priceEUR: Math.round(price * 100) / 100,
                                    accessToken:
                                      (window as any).__supaAccessToken ??
                                      undefined,
                                  } as any);
                                  await Promise.all([
                                    queryClient.invalidateQueries([
                                      "secondaryListings",
                                    ]),
                                    queryClient.invalidateQueries([
                                      "activeListings",
                                    ]),
                                    queryClient.invalidateQueries([
                                      "islands_list",
                                    ]),
                                    islandFilterId
                                      ? queryClient.invalidateQueries([
                                          "islandFilter",
                                          islandFilterId,
                                        ])
                                      : Promise.resolve(),
                                  ]);
                                  setMyPlotSelection((prev) => ({
                                    ...prev,
                                    [key]: false,
                                  }));
                                  toast({
                                    title: "Listing created",
                                    description: `(${p.x},${p.y})`,
                                  });
                                  triggerSuccess();
                                } catch (e: any) {
                                  toast({
                                    title: "Listing failed",
                                    description: e?.message ?? "Unknown error",
                                  });
                                }
                              })();
                            }}
                          >
                            List now
                          </Button>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          {!isGuest && myPlots && (myPlots as any[]).length > 0 && (
            <DrawerFooter className="pt-2">
              <div className="w-full grid gap-2">
                <Button
                  variant="secondary"
                  onClick={() => {
                    setMyPlotSelection({});
                    setMyPlotPrices({});
                  }}
                >
                  Reset selection
                </Button>
                <Button
                  disabled={
                    Object.keys(myPlotSelection).filter(
                      (k) => myPlotSelection[k],
                    ).length === 0
                  }
                  onClick={async () => {
                    try {
                      const plots = myPlots as any[];
                      const items = plots
                        .filter((p) => {
                          const k = `${p.x}:${p.y}`;
                          return !!myPlotSelection[k] && !myListedKeys.has(k);
                        })
                        .map((p) => {
                          const k = `${p.x}:${p.y}`;
                          const price = Number(myPlotPrices[k] ?? 0);
                          return {
                            x: Number(p.x),
                            y: Number(p.y),
                            priceEUR: Math.round(price * 100) / 100,
                          };
                        })
                        .filter(
                          (it) =>
                            Number.isFinite(it.priceEUR) && it.priceEUR > 0,
                        );

                      if (!items.length) return;

                      await Promise.all(
                        items.map((it) =>
                          apiClient.createSecondaryListing({
                            x: it.x,
                            y: it.y,
                            priceEUR: it.priceEUR,
                            accessToken:
                              (window as any).__supaAccessToken ?? undefined,
                          } as any),
                        ),
                      );

                      await Promise.all([
                        queryClient.invalidateQueries(["secondaryListings"]),
                        queryClient.invalidateQueries(["activeListings"]),
                        queryClient.invalidateQueries(["myPlots_2nd"]),
                        queryClient.invalidateQueries(["islands_list"]),
                        islandFilterId
                          ? queryClient.invalidateQueries([
                              "islandFilter",
                              islandFilterId,
                            ])
                          : Promise.resolve(),
                      ]);

                      setMyListDrawerOpen(false);
                      setMyPlotSelection({});
                      setMyPlotPrices({});
                      toast({ title: "Listings created" });
                      triggerSuccess();
                    } catch (e: any) {
                      toast({
                        title: "Listing failed",
                        description: e?.message ?? "Unknown error",
                      });
                    }
                  }}
                >
                  Create listings{" "}
                </Button>
              </div>
            </DrawerFooter>
          )}
        </DrawerContent>
      </Drawer>

      <Drawer open={withdrawOpen} onOpenChange={setWithdrawOpen}>
        <DrawerContent>
          <DrawerHeader className="text-left">
            <DrawerTitle>Cash Out</DrawerTitle>
            <DrawerDescription>
              Transfer part of your balance to your saved payout profile.
            </DrawerDescription>
          </DrawerHeader>
          <div className="px-4 pb-4 grid gap-3">
            <div className="text-xs text-white">
              Balance:{" "}
              <span className="font-medium">
                {currencyUSD(profile?.balance)}
              </span>
            </div>
            <div className="grid grid-cols-3 items-center gap-3">
              <Label className="col-span-1">{t("amountLabel")}</Label>
              <Input
                className="col-span-2"
                type="tel"
                inputMode="decimal"
                value={withdrawAmount}
                placeholder="100"
                onChange={(e) =>
                  setWithdrawAmount(
                    e.target.value.replace(/[^0-9.,]/g, "").replace(",", "."),
                  )
                }
              />
            </div>
            <div className="grid grid-cols-3 items-center gap-3">
              <Label className="col-span-1">{t("noteLabel")}</Label>
              <Input
                className="col-span-2"
                value={withdrawNote}
                onChange={(e) => setWithdrawNote(e.target.value)}
                placeholder="—"
              />
            </div>
            {!payoutProfile && (
              <div className="text-xs text-destructive">
                {t("payoutMethodMissing")}
              </div>
            )}
            <Button
              onClick={() => {
                const amt = Number(withdrawAmount || 0);
                if (!amt || amt <= 0) return;
                withdrawMutation.mutate({
                  amountCHF: amt,
                  note: withdrawNote || undefined,
                });
              }}
              disabled={
                withdrawMutation.isLoading || !withdrawAmount || !payoutProfile
              }
            >
              {withdrawMutation.isLoading ? "Sending…" : "Cash out"}
            </Button>
          </div>
          <DrawerFooter className="pt-2">
            <Button variant="secondary" onClick={() => setWithdrawOpen(false)}>
              {t("close")}
            </Button>
          </DrawerFooter>
        </DrawerContent>
      </Drawer>

      {/* 2nd Market buy flow: Info popup → Buy confirmation popup */}
      <AlertDialog
        open={!!buyInfo}
        onOpenChange={(v) => !v && setBuyInfo(null)}
      >
        <AlertDialogContent className="max-w-[520px]">
          <AlertDialogHeader>
            <AlertDialogTitle>
              <span className="text-2xl font-semibold">2nd Market m²</span>
            </AlertDialogTitle>
            <AlertDialogDescription>
              <div className="space-y-3 text-base">
                <div className="rounded-lg border bg-muted/30 p-3 text-sm">
                  <ul className="list-disc pl-5 space-y-2">
                    <li>
                      Only m² bought on the 2nd Market is affected by these
                      rules.
                    </li>
                    <li>
                      {islandFilterId
                        ? "Islands: no holding period (you can list/sell again immediately)."
                        : "5-day holding period: after buying a 2nd Market m², you must hold it for at least 5 days before you can list or sell it on the 2nd Market again."}
                    </li>{" "}
                    <li>
                      No island building with 2nd Market m²: 2nd Market m² never
                      counts for island creation.
                    </li>
                    <li>
                      Island creation is only possible with{" "}
                      <span className="font-medium">2 new m²</span> bought
                      directly from the Main Market.
                    </li>
                  </ul>
                </div>
                <div className="text-sm text-muted-foreground">
                  After purchase, your m² collectible will appear in your
                  Wallet.
                </div>
              </div>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="flex flex-wrap gap-2">
            <AlertDialogCancel onClick={() => setBuyInfo(null)}>
              <span className="text-base">Cancel</span>
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                const bi = buyInfo;
                if (!bi) return;
                setBuyConfirm({ ...bi });
                setBuyInfo(null);
              }}
            >
              <span className="text-base">Continue</span>
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog
        open={!!buyConfirm}
        onOpenChange={(v) => !v && setBuyConfirm(null)}
      >
        <AlertDialogContent className="max-w-[520px]">
          <AlertDialogHeader>
            <AlertDialogTitle>
              <span className="text-2xl font-semibold">Confirm purchase</span>
            </AlertDialogTitle>
            <AlertDialogDescription>
              <div className="space-y-3 text-base">
                <div>
                  You are about to buy <span className="font-medium">1 m²</span>
                  .
                </div>
                <div>
                  Price:{" "}
                  <span className="font-medium">
                    {buyConfirm ? formatPPC(buyConfirm.price) : ""}
                  </span>
                </div>
                <div className="text-sm text-muted-foreground">
                  ({buyConfirm?.x},{buyConfirm?.y})
                </div>
              </div>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="flex flex-wrap gap-2">
            <Button
              variant="secondary"
              onClick={() => {
                const bc = buyConfirm;
                if (!bc) return;
                setBuyInfo({ ...bc });
                setBuyConfirm(null);
              }}
            >
              Back
            </Button>
            <AlertDialogCancel onClick={() => setBuyConfirm(null)}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                const bc = buyConfirm;
                if (!bc) return;
                buyListing.mutate({
                  x: bc.x,
                  y: bc.y,
                  accessToken,
                } as any);
                setBuyConfirm(null);
              }}
            >
              <span className="text-base">Buy collectible</span>
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {showSuccessOverlay && (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/40 backdrop-blur-sm">
          <div className="success-pop rounded-full w-28 h-28 bg-background border-4 border-green-500 flex items-center justify-center shadow-xl">
            <CheckCircle2 className="h-16 w-16 text-green-500" />
          </div>
        </div>
      )}
    </ScreenContainer>
  );
}

// (InfoHint removed: not used in current UI)

function WalletRefreshButton({
  onLoadingChange,
}: {
  onLoadingChange?: (loading: boolean) => void;
}) {
  const queryClient = useQueryClient();
  const [refreshing, setRefreshing] = useState(false);
  return (
    <Button
      type="button"
      size="sm"
      variant="secondary"
      className="px-2 relative z-10"
      disabled={refreshing}
      onClick={async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (refreshing) return;
        setRefreshing(true);
        try {
          onLoadingChange?.(true);
        } catch {}
        try {
          await Promise.all([
            queryClient.refetchQueries({
              queryKey: ["walletSummary"],
              exact: false,
              type: "active",
            }),
            queryClient.refetchQueries({
              queryKey: ["walletRangeSummary"],
              exact: false,
              type: "active",
            }),
            queryClient.refetchQueries({
              queryKey: ["portfolio"],
              exact: false,
              type: "active",
            }),
            queryClient.refetchQueries({
              queryKey: ["certificates"],
              exact: false,
              type: "active",
            }),
          ]);
        } finally {
          setRefreshing(false);
          try {
            onLoadingChange?.(false);
          } catch {}
        }
      }}
      aria-label="Refresh wallet"
      title="Refresh wallet"
    >
      <RefreshCcw
        className={`h-3.5 w-3.5 ${refreshing ? "animate-spin" : ""}`}
      />
    </Button>
  );
}

function WalletScreen() {
  const [overlayOpen, setOverlayOpen] = useState(false);
  const [overlayPct, setOverlayPct] = useState(0);
  const overlayTimerRef = useRef<number | null>(null);

  const [topupOpen, setTopupOpen] = useState(false);
  const [authOpen, setAuthOpen] = useState(false);
  const [pendingTopup, setPendingTopup] = useState(false);

  const promptSignIn = () => {
    try {
      window.dispatchEvent(new Event("openSignIn"));
    } catch {}
  };

  const [walletMessagesOpen, setWalletMessagesOpen] = useState(false);

  const startOverlay = () => {
    if (overlayTimerRef.current) {
      window.clearInterval(overlayTimerRef.current);
      overlayTimerRef.current = null;
    }
    setOverlayPct(0);
    setOverlayOpen(true);
    const startedAt = Date.now();
    overlayTimerRef.current = window.setInterval(() => {
      const elapsed = Date.now() - startedAt;
      // Ease towards 90% while waiting; final 10% happens on completion.
      const p = Math.min(90, Math.max(0, Math.floor((elapsed / 4500) * 90)));
      setOverlayPct((prev) => (p > prev ? p : prev));
    }, 120);
  };

  const stopOverlay = () => {
    if (overlayTimerRef.current) {
      window.clearInterval(overlayTimerRef.current);
      overlayTimerRef.current = null;
    }
    setOverlayPct(100);
    window.setTimeout(() => setOverlayOpen(false), 250);
  };

  useEffect(() => {
    return () => {
      if (overlayTimerRef.current) {
        window.clearInterval(overlayTimerRef.current);
        overlayTimerRef.current = null;
      }
    };
  }, []);

  const { t } = useLang();
  const supa = useSupabase();
  const guestMode = useIsGuest();
  const accessToken =
    supa.accessToken ?? (window as any).__supaAccessToken ?? undefined;
  const hasSupabaseSession = !!supa.user && !!supa.accessToken;
  // Wallet uses Supabase session as the source of truth for “signed in”.
  // If there is no Supabase session, we treat the user as guest/preview here (even if AC1 auth exists).
  const walletIsGuest = guestMode || !hasSupabaseSession;
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const deviceId = React.useContext(DeviceIdContext);

  const [signInEmail, setSignInEmail] = useState("");
  const [signInSent, setSignInSent] = useState(false);
  const [signInError, setSignInError] = useState<string | null>(null);

  useEffect(() => {
    if (!hasSupabaseSession) return;
    // If the user is signed in, ensure we don't keep "guest mode" enabled.
    try {
      localStorage.setItem("guestMode", "0");
      window.dispatchEvent(new Event("guestModeChanged"));
    } catch {}
  }, [hasSupabaseSession]);

  useEffect(() => {
    if (!hasSupabaseSession) return;
    if (!pendingTopup) return;
    setAuthOpen(false);
    setPendingTopup(false);
    setTopupOpen(true);
  }, [hasSupabaseSession, pendingTopup]);

  // Realtime updates: when a 2nd Market trade happens, refresh wallet-related data.
  const [secondaryRT] = useRealtimeStore("secondary", { ts: 0 });
  useEffect(() => {
    if (!hasSupabaseSession) return;
    if (!secondaryRT?.ts) return;
    void Promise.all([
      queryClient.invalidateQueries(["portfolio"]),
      queryClient.invalidateQueries(["profile"]),
      queryClient.invalidateQueries(["holdingsBreakdown", "auth"]),
      queryClient.invalidateQueries([
        "islandHoldingsValuation",
        accessToken ?? null,
      ]),
      queryClient.invalidateQueries(["walletSummary"]),
      queryClient.invalidateQueries(["walletRangeSummary"]),
      queryClient.invalidateQueries(["certificates"]),
      queryClient.invalidateQueries(["messageCenter"]),
      queryClient.invalidateQueries(["messageCenterUnreadCount"]),
      queryClient.invalidateQueries(["islands_list"]),
    ]);
  }, [secondaryRT?.ts, hasSupabaseSession]);

  const { data: portfolio, isInitialLoading: isPortfolioInitialLoading } =
    useQuery<any>(
      ["portfolio", walletIsGuest ? "guest" : "auth"],
      () =>
        walletIsGuest
          ? apiClient.getGuestPortfolio({ deviceId })
          : apiClient.getPortfolio({
              accessToken,
            }),
      {
        keepPreviousData: true,
        refetchOnWindowFocus: false,
        enabled: !!deviceId && (walletIsGuest || hasSupabaseSession),
      },
    );
  const { data: market } = useQuery<MarketOutput>(["market"], () =>
    apiClient.getMarket(),
  );
  const { data: fxCHF } = useQuery<any>(
    ["fxRates", "CHF"],
    () => apiClient.getFxRates({ base: "CHF" }),
    { keepPreviousData: true, refetchOnWindowFocus: false },
  );
  const { data: certs, isInitialLoading: isCertsInitialLoading } =
    useQuery<any>(
      ["certificates", walletIsGuest ? "guest" : "auth"],
      () =>
        walletIsGuest
          ? apiClient.listGuestCertificates({ deviceId })
          : apiClient.listCertificates({ accessToken }),

      {
        keepPreviousData: true,
        refetchOnWindowFocus: false,
        enabled: walletIsGuest ? !!deviceId : !!accessToken,
      },
    );

  type HoldingsBreakdownOutput = inferRPCOutputType<"getHoldingsBreakdown">;
  const { data: holdings } = useQuery<HoldingsBreakdownOutput>(
    ["holdingsBreakdown", walletIsGuest ? "guest" : "auth"],
    () =>
      walletIsGuest
        ? apiClient.getHoldingsBreakdown({ deviceId })
        : apiClient.getHoldingsBreakdown({ accessToken }),
    {
      keepPreviousData: true,
      refetchOnWindowFocus: false,
      enabled: !!deviceId && (walletIsGuest || hasSupabaseSession),
    },
  );

  const { data: islandValuation } = useQuery<any>(
    ["islandHoldingsValuation", accessToken ?? null],
    () => apiClient.getIslandHoldingsValuation({ accessToken } as any),
    {
      enabled: !!accessToken && hasSupabaseSession,
      keepPreviousData: true,
      // Keep islands value live-ish in the background so the wallet stays up to date.
      staleTime: 5_000,
      refetchInterval: 15_000,
      refetchIntervalInBackground: true,
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      retry: 1,
      placeholderData: () =>
        (queryClient.getQueryData<any>([
          "islandHoldingsValuation",
          accessToken ?? null,
        ]) ?? null) as any,
    },
  );
  type WalletMessagesOutput = inferRPCOutputType<"listMessageCenter">;
  const { data: walletMsgs, isFetching: isWalletMsgsFetching } =
    useQuery<WalletMessagesOutput>(
      ["walletMessages"],
      () => apiClient.listMessageCenter({ accessToken, limit: 50 }),
      {
        enabled: !!accessToken && hasSupabaseSession,
        keepPreviousData: true,
        refetchOnWindowFocus: false,
      },
    );
  const { data: walletMsgsUnread } = useQuery<{ unreadCount: number }>(
    ["walletMessagesUnread"],
    () => apiClient.getMessageCenterUnreadCount({ accessToken }),
    {
      enabled: !!accessToken && hasSupabaseSession,
      keepPreviousData: true,
      refetchOnWindowFocus: false,
    },
  );

  const markWalletMsgsSeen = useMutation(
    (vars: { accessToken?: string }) => apiClient.markMessageCenterSeen(vars),
    {
      onSuccess: () => {
        void queryClient.invalidateQueries(["walletMessagesUnread"]);
      },
    },
  );

  // Houses removed: no house counts (wallet summary no longer used here)
  const templateUrl = market?.certificateTemplateUrl ?? null;
  const [previewCert, setPreviewCert] = useState<{
    id: string;
    x?: number;
    y?: number;
    date?: string;
  } | null>(null);

  // Message Center was removed from the wallet screen to match the old wallet layout.

  // Top KPIs

  // removed unused toast

  const shouldInitialOverlay =
    isPortfolioInitialLoading || isCertsInitialLoading;

  useEffect(() => {
    if (shouldInitialOverlay) startOverlay();
    else if (overlayOpen) stopOverlay();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [shouldInitialOverlay]);

  return (
    <ScreenContainer title={"Wallet"}>
      {overlayOpen ? (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-background/90 backdrop-blur">
          <div className="flex flex-col items-center gap-3">
            <CoinIcon className="h-20 w-20 animate-spin" />
            <div className="text-sm font-semibold text-foreground">
              {overlayPct}%
            </div>
          </div>
        </div>
      ) : null}
      <div className="mt-4 grid gap-3 sm:gap-4">
        {walletIsGuest ? (
          <div className="max-w-2xl mx-auto w-full">
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-base">
                  Wallet is in preview
                </CardTitle>
              </CardHeader>
              <CardContent className="grid gap-3 text-sm">
                <div className="text-muted-foreground">
                  As a guest, you can browse the app, but adding PP coins and
                  trading requires sign-in.
                </div>
                <div className="grid gap-2">
                  <Button className="w-full" onClick={promptSignIn}>
                    Sign in to use Wallet
                  </Button>
                  <Button
                    variant="secondary"
                    className="w-full"
                    onClick={() => navigate("/market")}
                  >
                    Back to Market
                  </Button>
                </div>
                <div className="text-xs text-muted-foreground">
                  Your profile and settings are still available — sign in when
                  you want to take actions.
                </div>
              </CardContent>
            </Card>
          </div>
        ) : hasSupabaseSession ? (
          <>
            {" "}
            {/* Big centered balance header (old layout: buttons under balance) */}
            <div className="rounded-2xl border bg-card shadow-sm p-4 sm:p-6 overflow-hidden">
              <div className="text-[11px] font-semibold text-muted-foreground">
                PP coins ≈ 1 USD (reference only, not redeemable)
              </div>

              <div className="mt-5 text-center">
                <div className="text-[11px] uppercase tracking-wide text-muted-foreground">
                  Current balance
                </div>
                <div className="mt-1 text-4xl sm:text-5xl font-extrabold">
                  {`${Number(portfolio?.balance ?? 0).toLocaleString("de-CH", {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                  })} PPc`}
                </div>
                <div className="mt-1 text-xs text-muted-foreground">
                  ≈ {currencyUSD(Number(portfolio?.balance ?? 0))}
                </div>

                {/* Mobile: big primary button + small actions row; Desktop: single centered row */}
                <div className="mt-4 grid gap-2 sm:flex sm:items-center sm:justify-center sm:gap-2">
                  <Button
                    type="button"
                    size="sm"
                    className="px-6 w-full sm:w-auto sm:min-w-[180px]"
                    onClick={() => {
                      if (walletIsGuest) {
                        setPendingTopup(true);
                        promptSignIn();
                        return;
                      }
                      setTopupOpen(true);
                    }}
                    title="Add PP coins"
                  >
                    Add PP coins
                  </Button>

                  <div className="flex items-center justify-center gap-2 sm:contents">
                    <Button
                      type="button"
                      size="sm"
                      variant="secondary"
                      className="px-5"
                      onClick={() => {
                        try {
                          (window as any).__openSupport?.();
                        } catch {}
                      }}
                      title="Support"
                    >
                      Support
                    </Button>

                    <WalletRefreshButton
                      onLoadingChange={(loading) => {
                        if (loading) startOverlay();
                        else stopOverlay();
                      }}
                    />
                  </div>
                </div>
              </div>
            </div>
            {/* KPIs row under balance (old wallet: 2 columns) */}
            <div className="grid gap-3 sm:gap-4 sm:grid-cols-2">
              {" "}
              <div className="rounded-2xl border bg-card shadow-sm p-4 sm:p-6">
                <div className="text-[11px] uppercase tracking-wide text-muted-foreground">
                  Main m² / Collectibles
                </div>
                <div className="mt-2 text-3xl sm:text-4xl font-extrabold tracking-tight text-center">
                  {Number(holdings?.mainM2 ?? 0).toLocaleString("en-US", {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0,
                  })}
                </div>
                <div className="mt-1 text-xs text-muted-foreground text-center">
                  Total m²:{" "}
                  {Number(holdings?.totalM2 ?? 0).toLocaleString("en-US")} ·
                  Collectibles:{" "}
                  {Number(certs?.length ?? 0).toLocaleString("en-US")}
                </div>
              </div>
              <div className="rounded-2xl border bg-card shadow-sm p-4 sm:p-6">
                <div className="text-[11px] uppercase tracking-wide text-muted-foreground">
                  Estimated Portfolio Worth
                </div>
                <div className="mt-2 text-3xl sm:text-4xl font-extrabold tracking-tight text-center">
                  {(() => {
                    const totalM2 = Number(holdings?.totalM2 ?? 0);
                    const islandM2 = Math.max(
                      0,
                      Math.floor(Number(islandValuation?.totalIslandM2 ?? 0)),
                    );
                    const mapM2 = Math.max(0, Math.floor(totalM2) - islandM2);

                    const priceCHF = Number(market?.pricePerM2CHF ?? 0);
                    const feePct = Number(market?.sellFeePct ?? 0);
                    const grossCHF = Math.max(0, mapM2 * priceCHF);
                    const feeCHF = (feePct / 100) * grossCHF;
                    const netCHF = grossCHF - feeCHF;
                    const chfToUsd = Number(fxCHF?.rates?.USD ?? 1);
                    const mapValuePPC = Math.max(0, netCHF * chfToUsd);

                    const islandValuePPC = Math.max(
                      0,
                      Number(islandValuation?.estimatedValueUSD ?? 0),
                    );

                    const totalValue = mapValuePPC + islandValuePPC;
                    if (!totalValue || totalValue <= 0) return "—";

                    return `${totalValue.toLocaleString("de-CH", {
                      minimumFractionDigits: 2,
                      maximumFractionDigits: 2,
                    })} PPc`;
                  })()}
                </div>
                <div className="mt-1 text-xs text-muted-foreground text-center">
                  {(() => {
                    const totalM2 = Number(holdings?.totalM2 ?? 0);
                    const islandM2 = Math.max(
                      0,
                      Math.floor(Number(islandValuation?.totalIslandM2 ?? 0)),
                    );
                    const mapM2 = Math.max(0, Math.floor(totalM2) - islandM2);

                    const priceCHF = Number(market?.pricePerM2CHF ?? 0);
                    const feePct = Number(market?.sellFeePct ?? 0);
                    const grossCHF = Math.max(0, mapM2 * priceCHF);
                    const feeCHF = (feePct / 100) * grossCHF;
                    const netCHF = grossCHF - feeCHF;
                    const chfToUsd = Number(fxCHF?.rates?.USD ?? 1);
                    const mapValuePPC = Math.max(0, netCHF * chfToUsd);

                    const islandValuePPC = Math.max(
                      0,
                      Number(islandValuation?.estimatedValueUSD ?? 0),
                    );

                    const totalValue = mapValuePPC + islandValuePPC;
                    if (!totalValue || totalValue <= 0) {
                      return "Buy m² to see an estimate.";
                    }

                    // Map + Islands, without PPc cash balance
                    const parts: string[] = [];
                    if (mapValuePPC > 0) {
                      parts.push(
                        `Map: ${mapValuePPC.toLocaleString("de-CH", {
                          minimumFractionDigits: 0,
                          maximumFractionDigits: 0,
                        })} PPc`,
                      );
                    }
                    if (islandValuePPC > 0) {
                      parts.push(
                        `Islands: ${islandValuePPC.toLocaleString("de-CH", {
                          minimumFractionDigits: 0,
                          maximumFractionDigits: 0,
                        })} PPc`,
                      );
                    }

                    const suffix = "(PPc balance not included).";
                    return `${parts.join(" • ")} ${suffix}`.trim();
                  })()}
                </div>{" "}
              </div>
            </div>
            {/* Messages button under KPIs */}
            <div className="flex items-center justify-center">
              <Button
                type="button"
                variant="secondary"
                className="w-full sm:w-auto sm:min-w-[260px] justify-center"
                onClick={() => {
                  if (walletIsGuest || !hasSupabaseSession) {
                    promptSignIn();
                    return;
                  }
                  setWalletMessagesOpen(true);
                  markWalletMsgsSeen.mutate({ accessToken });
                }}
              >
                <span className="relative inline-flex items-center gap-2">
                  Messages
                  {Number(walletMsgsUnread?.unreadCount ?? 0) > 0 ? (
                    <span className="inline-block h-2.5 w-2.5 rounded-full bg-destructive" />
                  ) : null}
                </span>
              </Button>
            </div>
            <Dialog
              open={walletMessagesOpen}
              onOpenChange={(v) => {
                setWalletMessagesOpen(v);
                if (v && hasSupabaseSession) {
                  markWalletMsgsSeen.mutate({ accessToken });
                }
              }}
            >
              <DialogContent className="sm:max-w-[720px]">
                <DialogHeader>
                  <DialogTitle>Messages</DialogTitle>
                  <DialogDescription>
                    Wallet events (PPc, buys, sells)
                  </DialogDescription>
                </DialogHeader>

                <div className="max-h-[65vh] overflow-auto rounded-xl border bg-background">
                  {isWalletMsgsFetching ? (
                    <div className="p-4 text-sm text-muted-foreground">
                      Loading…
                    </div>
                  ) : null}

                  {!isWalletMsgsFetching &&
                  (!walletMsgs || walletMsgs.length === 0) ? (
                    <div className="p-4 text-sm text-muted-foreground">
                      No messages yet.
                    </div>
                  ) : null}

                  <div className="divide-y">
                    {(walletMsgs ?? []).map((m: any) => (
                      <div key={m.id} className="p-4">
                        <div className="flex items-start justify-between gap-3">
                          <div>
                            <div className="text-sm font-semibold">
                              {m.title}
                              {m.isNew ? (
                                <span className="ml-2 align-middle inline-flex h-2 w-2 rounded-full bg-destructive" />
                              ) : null}
                            </div>
                            <div className="mt-0.5 text-xs text-muted-foreground">
                              {formatDateTime(m.createdAt)}
                            </div>
                            <div className="mt-2 text-sm">{m.detail}</div>
                          </div>

                          <Dialog>
                            <DialogTrigger asChild>
                              <Button size="sm" variant="outline">
                                Info
                              </Button>
                            </DialogTrigger>
                            <DialogContent className="sm:max-w-[560px]">
                              <DialogHeader>
                                <DialogTitle>Info</DialogTitle>
                                <DialogDescription>
                                  Details about this wallet event
                                </DialogDescription>
                              </DialogHeader>
                              <div className="whitespace-pre-wrap text-sm">
                                {m.info}
                              </div>
                              <DialogFooter>
                                <DialogClose asChild>
                                  <Button variant="secondary">Close</Button>
                                </DialogClose>
                              </DialogFooter>
                            </DialogContent>
                          </Dialog>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>

                <DialogFooter>
                  <Button
                    variant="secondary"
                    onClick={() => setWalletMessagesOpen(false)}
                  >
                    Close
                  </Button>
                </DialogFooter>
              </DialogContent>
            </Dialog>
            <div className="rounded-2xl border bg-card shadow-sm p-4 sm:p-6">
              {" "}
              <div className="text-sm font-semibold text-center">
                {t("certificates")}
              </div>
              <div className="mt-5">
                <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-3">
                  {certs?.map((c: any) => {
                    const goToPlot = () => {
                      setPreviewCert({
                        id: c.id,
                        x: c?.plot?.x,
                        y: c?.plot?.y,
                        date: c?.purchasedAt,
                      });
                    };
                    return (
                      <button
                        key={c.id}
                        className="relative text-left transition-transform active:scale-95"
                        onClick={goToPlot}
                      >
                        <AspectRatio ratio={210 / 297}>
                          <div className="absolute inset-0 border rounded-lg overflow-hidden bg-background">
                            {templateUrl ? (
                              <img
                                src={templateUrl}
                                alt="Certificate"
                                className="w-full h-full object-contain select-none pointer-events-none"
                              />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center text-xs text-muted-foreground">
                                No template
                              </div>
                            )}
                          </div>
                        </AspectRatio>
                        <div className="mt-1 text-[11px] text-muted-foreground">
                          {`${c?.plot?.x ?? "?"},${c?.plot?.y ?? "?"} · ${c?.purchasedAt ? formatDateDDMMYY(c.purchasedAt) : ""}`}
                        </div>
                      </button>
                    );
                  })}

                  {!certs || certs.length === 0 ? (
                    <div className="text-sm text-muted-foreground">
                      {t("noCertificates")}
                    </div>
                  ) : null}
                </div>
              </div>
            </div>
            <Dialog
              open={authOpen}
              onOpenChange={(v) => {
                setAuthOpen(v);
                if (!v) setPendingTopup(false);
              }}
            >
              <DialogContent className="sm:max-w-[520px]">
                <DialogHeader>
                  <DialogTitle>Sign in</DialogTitle>
                  <DialogDescription>
                    Sign in to add PP coins or buy.
                  </DialogDescription>
                </DialogHeader>

                <div className="grid gap-2">
                  {supa.configError ? (
                    <Alert>
                      <AlertDescription>
                        Sign-in is currently unavailable: {supa.configError}
                      </AlertDescription>
                    </Alert>
                  ) : null}

                  {signInError ? (
                    <Alert>
                      <AlertDescription>{signInError}</AlertDescription>
                    </Alert>
                  ) : null}

                  <Button
                    disabled={!!supa.configError}
                    onClick={async () => {
                      setSignInError(null);
                      setSignInSent(false);
                      try {
                        await supa.signInWithGoogle();
                      } catch (e: any) {
                        setSignInError(e?.message || "Sign-in failed.");
                      }
                    }}
                  >
                    Continue with Google
                  </Button>

                  <div className="rounded-lg border p-3">
                    <div className="text-sm font-medium mb-2">Email link</div>
                    <div className="flex flex-col sm:flex-row gap-2">
                      <Input
                        value={signInEmail}
                        onChange={(e) => setSignInEmail(e.target.value)}
                        placeholder="you@example.com"
                        disabled={!!supa.configError}
                      />
                      <Button
                        variant="secondary"
                        disabled={!!supa.configError}
                        onClick={async () => {
                          setSignInError(null);
                          setSignInSent(false);
                          try {
                            await supa.sendEmailLink(signInEmail);
                            setSignInSent(true);
                          } catch (e: any) {
                            setSignInError(
                              e?.message || "Could not send email link.",
                            );
                          }
                        }}
                      >
                        Send link
                      </Button>
                    </div>
                    {signInSent ? (
                      <div className="text-xs text-muted-foreground mt-2">
                        Link sent. Check your inbox.
                      </div>
                    ) : null}
                  </div>
                </div>

                <DialogFooter>
                  <Button
                    type="button"
                    variant="secondary"
                    onClick={() => {
                      setAuthOpen(false);
                      setPendingTopup(false);
                    }}
                  >
                    Close
                  </Button>
                </DialogFooter>
              </DialogContent>
            </Dialog>
            <Dialog open={topupOpen} onOpenChange={setTopupOpen}>
              <DialogContent className="w-[calc(100vw-12px)] max-w-[420px] p-0 border-0 bg-transparent shadow-none overflow-visible">
                <DialogHeader className="sr-only">
                  <DialogTitle>Add PP coins</DialogTitle>
                  <DialogDescription>Top up PP coins</DialogDescription>
                </DialogHeader>
                <div
                  className="relative overflow-hidden rounded-[16px] border shadow-[0_12px_48px_rgba(0,0,0,0.45)] min-h-[290px] sm:min-h-[280px] max-h-[68vh] flex flex-col text-primary-foreground"
                  style={{
                    backgroundColor: "hsl(var(--primary))",
                    borderColor: "rgba(255,255,255,0.18)",
                  }}
                >
                  <div className="relative p-2.5 sm:p-3 flex-1 flex flex-col">
                    <div className="flex items-start justify-between gap-4">
                      <div className="min-w-0">
                        <div className="flex items-center gap-2">
                          <div
                            className="inline-flex h-8 w-8 items-center justify-center rounded-full border"
                            style={{
                              backgroundColor: "rgba(255,255,255,0.12)",
                              borderColor: "rgba(255,255,255,0.22)",
                            }}
                            aria-hidden
                          >
                            <CoinIcon className="h-4 w-4" />
                          </div>
                          <div className="text-xs font-extrabold tracking-wide opacity-80">
                            ADD PP COINS
                          </div>
                        </div>
                        <div className="mt-1.5 text-[20px] sm:text-[22px] font-extrabold tracking-tight leading-tight">
                          Add PP coins
                        </div>
                        <div className="mt-1 text-[11px] sm:text-xs font-semibold opacity-75">
                          PP coins ≈ 1 USD (reference only, not redeemable)
                        </div>
                      </div>

                      <DialogClose asChild>
                        <button
                          type="button"
                          className="shrink-0 rounded-full border p-1.5 hover:opacity-90"
                          style={{
                            backgroundColor: "rgba(255,255,255,0.12)",
                            borderColor: "rgba(255,255,255,0.22)",
                          }}
                          aria-label="Close"
                        >
                          <X className="h-3.5 w-3.5" />
                        </button>
                      </DialogClose>
                    </div>

                    <div
                      className="mt-3 rounded-[16px] border p-3 sm:p-4 flex-1 relative overflow-hidden"
                      style={{
                        backgroundColor: "rgba(255,255,255,0.08)",
                        borderColor: "rgba(255,255,255,0.16)",
                      }}
                    >
                      <div className="relative">
                        <PPCoinTopup
                          variant="inline"
                          amountUnit="PPc"
                          confirmLabel="CONFIRM"
                          showFx={false}
                          uiStyle="tour"
                          onClose={() => setTopupOpen(false)}
                        />
                      </div>
                    </div>
                  </div>
                </div>
              </DialogContent>
            </Dialog>{" "}
            {/* Certificate preview drawer */}
            <Drawer
              open={!!previewCert}
              onOpenChange={(v) => !v && setPreviewCert(null)}
            >
              <DrawerContent>
                <DrawerHeader className="text-left relative">
                  <DrawerTitle>{t("certificateTitle")}</DrawerTitle>
                  <DrawerDescription>
                    {previewCert
                      ? `${
                          previewCert.x !== undefined &&
                          previewCert.y !== undefined
                            ? `${previewCert.x},${previewCert.y} · `
                            : ""
                        }${formatDateTime(previewCert.date)}`
                      : ""}
                  </DrawerDescription>
                  <DrawerClose asChild>
                    <button
                      aria-label={t("close")}
                      className="absolute right-2 top-2 rounded-full p-1 hover:bg-secondary active:scale-95 transition-transform"
                      onClick={() => setPreviewCert(null)}
                    >
                      <X className="h-4 w-4" />
                    </button>
                  </DrawerClose>
                </DrawerHeader>
                <div className="px-4 pb-4 flex items-center justify-center">
                  <div className="relative w-full max-w-[300px] sm:max-w-[340px]">
                    <AspectRatio ratio={210 / 297}>
                      <div className="absolute inset-0 border rounded-lg overflow-hidden bg-card">
                        {templateUrl ? (
                          <img
                            src={templateUrl}
                            alt="Certificate"
                            className="w-full h-full object-contain select-none pointer-events-none"
                            onError={(e: any) => {
                              try {
                                e.currentTarget.style.display = "none";
                              } catch {}
                            }}
                          />
                        ) : (
                          <div className="w-full h-full flex items-center justify-center text-xs text-muted-foreground">
                            No template
                          </div>
                        )}
                      </div>
                    </AspectRatio>
                  </div>
                </div>
                <DrawerFooter className="pt-2 flex gap-2">
                  {previewCert?.x !== undefined &&
                    previewCert?.y !== undefined && (
                      <>
                        <Button
                          size="sm"
                          className="px-2 py-1 text-xs"
                          onClick={() => {
                            const x = previewCert!.x as number;
                            const y = previewCert!.y as number;
                            setPreviewCert(null);
                            navigate(`/map?focusX=${x}&focusY=${y}`);
                          }}
                        >
                          On map
                        </Button>
                        <Button
                          size="sm"
                          variant="default"
                          className="px-2 py-1 text-xs"
                          onClick={() => {
                            const x = previewCert!.x as number;
                            const y = previewCert!.y as number;
                            setPreviewCert(null);
                            navigate(`/map?list=1&focusX=${x}&focusY=${y}`);
                          }}
                        >
                          Sell{" "}
                        </Button>
                      </>
                    )}
                  <Button
                    size="sm"
                    variant="secondary"
                    className="px-2 py-1 text-xs"
                    onClick={() => setPreviewCert(null)}
                  >
                    {t("close")}
                  </Button>
                </DrawerFooter>
              </DrawerContent>
            </Drawer>
          </>
        ) : null}
      </div>
    </ScreenContainer>
  );
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function BuildSheet_UNUSED({
  open,
  onOpenChange,
  afterBuild,
}: {
  open: boolean;
  onOpenChange: (v: boolean) => void;
  afterBuild?: () => void;
}) {
  const isGuest = useIsGuest();
  const supa = useSupabase();
  const accessToken =
    supa.accessToken ?? (window as any).__supaAccessToken ?? undefined;
  const { data: portfolio } = useQuery<PortfolioOutput>(
    ["portfolio"],
    () =>
      apiClient.getPortfolio({
        accessToken,
      }),
    { enabled: open && !isGuest && !!accessToken },
  );
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [level, setLevel] = useState<"L1" | "L2" | "L3" | "L4" | "L5">("L1");
  const [count, setCount] = useState<string>("1");

  const buildMutation = useMutation(apiClient.buildHouses, {
    onSuccess: () => {
      onOpenChange(false);
      void queryClient.invalidateQueries(["portfolio"]);
      afterBuild?.();
    },
    onError: (e: any) => {
      toast({
        title: "Build failed",
        description: e?.message ?? "Unknown error",
      });
    },
  });

  const maxBuildable = Math.floor((portfolio?.unassignedM2 ?? 0) / 100);

  useEffect(() => {
    if (open) {
      setLevel("L1");
      setCount("1");
    }
  }, [open]);

  return (
    <Drawer open={open} onOpenChange={onOpenChange}>
      <DrawerContent>
        <DrawerHeader className="text-left">
          <DrawerTitle>Build houses</DrawerTitle>
          <DrawerDescription>
            One house uses 100 m²; no fee, increases value.
          </DrawerDescription>
        </DrawerHeader>
        <div className="px-4 pb-4 grid gap-4">
          <div>
            <Label className="mb-2 block">Level</Label>
            <Tabs value={level} onValueChange={(v) => setLevel(v as any)}>
              <TabsList className="grid grid-cols-5">
                {(["L1", "L2", "L3", "L4", "L5"] as const).map((lvl) => (
                  <TabsTrigger key={lvl} value={lvl}>
                    {lvl}
                  </TabsTrigger>
                ))}
              </TabsList>
              {(["L1", "L2", "L3", "L4", "L5"] as const).map((lvl) => (
                <TabsContent key={lvl} value={lvl} />
              ))}
            </Tabs>
            <div className="mt-2 text-xs text-muted-foreground">
              Bonus: {({ L1: 5, L2: 12, L3: 25, L4: 45, L5: 70 } as any)[level]}
              %
            </div>
          </div>
          <div className="grid grid-cols-3 items-center gap-3">
            <Label className="col-span-1">Quantity</Label>
            <Input
              className="col-span-2"
              type="tel"
              inputMode="numeric"
              pattern="[0-9]*"
              value={count}
              onChange={(e) => setCount(e.target.value.replace(/\D+/g, ""))}
              placeholder="e.g. 3"
            />
          </div>
          <div className="text-sm text-muted-foreground">
            Available for building:
            <span className="font-medium">{maxBuildable}</span> houses (
            {(maxBuildable * 100).toLocaleString("en-US")} m²)
          </div>
          <Button
            className="w-full"
            disabled={buildMutation.isLoading || !count}
            onClick={() => {
              const qty = Number(count || 0);
              if (!qty || qty < 1) return;
              if (qty > maxBuildable) {
                return;
              }
              buildMutation.mutate({ level, count: qty });
            }}
          >
            {buildMutation.isLoading ? "Building..." : "Build houses"}
          </Button>{" "}
        </div>
        <DrawerFooter>
          <Button variant="secondary" onClick={() => onOpenChange(false)}>
            Close
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function SellSheet_UNUSED({
  open,
  onOpenChange,
}: {
  open: boolean;
  onOpenChange: (v: boolean) => void;
}) {
  const { t } = useLang();
  const [m2, setM2] = useState<string>("");

  useEffect(() => {
    if (open) setM2("");
  }, [open]);

  const queryClient = useQueryClient();
  const { toast } = useToast();
  const sellMutation = useMutation(apiClient.sellLand, {
    onSuccess: () => {
      void queryClient.invalidateQueries(["market"]);
      void queryClient.invalidateQueries(["portfolio"]);
      onOpenChange(false);
      toast({ title: t("sellSuccess") });
    },
    onError: (e: any) => {
      toast({
        title: t("sellFailed"),
        description: e?.message ?? "Unknown error",
      });
    },
  });

  const { data: preview } = useQuery<SimSellOutput>(
    ["sellSimSheet", m2],
    () => apiClient.simulateSellProceeds({ m2: Number(m2 || 0) }),
    { enabled: !!m2 },
  );

  return (
    <Drawer open={open} onOpenChange={onOpenChange}>
      <DrawerContent>
        <DrawerHeader className="text-left">
          <DrawerTitle>Sell</DrawerTitle>
          <DrawerDescription>Net proceeds after 2% fee.</DrawerDescription>
        </DrawerHeader>
        <div className="px-4 pb-4 grid gap-3">
          <div className="grid grid-cols-3 items-center gap-3">
            <Label className="col-span-1">Amount (m²)</Label>
            <Input
              className="col-span-2"
              type="tel"
              inputMode="numeric"
              pattern="[0-9]*"
              value={m2}
              onChange={(e) => setM2(e.target.value.replace(/\D+/g, ""))}
              placeholder="z. B. 500"
            />
          </div>
          <div className="text-sm text-muted-foreground">
            {t("gross")}:{" "}
            <span className="font-medium">
              {currencyUSD(preview?.grossCHF)}
            </span>{" "}
            • {t("fee")}:{" "}
            <span className="font-medium">{currencyUSD(preview?.feeCHF)}</span>{" "}
            • {t("net")}:{" "}
            <span className="font-medium">{currencyUSD(preview?.netCHF)}</span>
          </div>
          <Button
            className="w-full"
            disabled={sellMutation.isLoading || !m2}
            onClick={() => {
              const qty = Number(m2 || 0);
              if (!qty || qty < 1) return;
              sellMutation.mutate({ m2: qty });
            }}
          >
            {sellMutation.isLoading ? "Selling..." : "Sell"}
          </Button>
          <Alert className="mt-2">
            <AlertDescription className="text-xs">
              Safety: Sell at current price per m² minus 2% fee. Minimum: 1 m².
            </AlertDescription>
          </Alert>
        </div>
        <DrawerFooter>
          <Button variant="secondary" onClick={() => onOpenChange(false)}>
            Close
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );
}

/* Leaderboard removed per feedback */
function BuyHint() {
  const [dismissed, setDismissed] = React.useState(false);
  React.useEffect(() => {
    try {
      if (sessionStorage.getItem("buyHintDismissed") === "1") {
        setDismissed(true);
      }
    } catch {}
  }, []);
  if (dismissed) return null;
  return (
    <div className="mt-2">
      <div className="inline-flex items-center gap-2 rounded-full bg-background/90 border px-3 py-1 text-xs shadow-sm">
        <span>
          Tip: drag to select multiple plots or tap to add one. On iPhone, press
          and drag with your finger.
        </span>
        <Button
          size="sm"
          variant="secondary"
          onClick={() => {
            setDismissed(true);
            try {
              sessionStorage.setItem("buyHintDismissed", "1");
            } catch {}
          }}
        >
          OK
        </Button>
      </div>
    </div>
  );
}

function MapScreen() {
  const { t } = useLang();
  const auth = useAuth();
  const isGuest = useIsGuest();
  const supa = useSupabase();
  const accessToken =
    supa.accessToken ?? (window as any).__supaAccessToken ?? undefined;
  const [origin, setOrigin] = useState({ x: 0, y: 0 });
  const [cellSize, setCellSize] = useState(24); // px per cell
  const originRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const cellSizeRef = useRef<number>(24);
  // Continuous zoom: derive a UI zoom level from the current cell size (0..5)

  // Locked-zoom presets for users with 0 m²: three close levels only
  const LOCKED_NEAR_SIZES = [40, 32, 24] as const;
  const getLockedSize = (i: number): number =>
    LOCKED_NEAR_SIZES[
      Math.max(0, Math.min(LOCKED_NEAR_SIZES.length - 1, i))
    ] as number;
  const viewportRef = useRef<HTMLDivElement | null>(null);
  const gridRef = useRef<HTMLDivElement | null>(null);
  const roadsCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const carsCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const gridOverlayRef = useRef<HTMLDivElement | null>(null);
  const [viewportSize, setViewportSize] = useState({ w: 0, h: 0 });

  // Irregular island polygon (same shape as backend; normalized then scaled here)
  const ISLAND_W = 800;
  const ISLAND_H = 500;
  const ISLAND_X0 = 0;
  const ISLAND_Y0 = 0;
  const ISLAND_POLY = React.useMemo(() => {
    // Normalized 0..1 polygon approximating the reference island silhouette (counter‑clockwise)
    const norm: Array<[number, number]> = [
      [0.02, 0.52],
      [0.04, 0.44],
      [0.08, 0.36],
      [0.14, 0.3],
      [0.22, 0.26],
      [0.32, 0.23],
      [0.45, 0.2],
      [0.55, 0.16],
      [0.62, 0.1],
      [0.67, 0.06],
      [0.72, 0.05],
      [0.78, 0.08],
      [0.82, 0.14],
      [0.84, 0.22],
      [0.88, 0.28],
      [0.94, 0.3],
      [0.97, 0.36],
      [0.96, 0.44],
      [0.92, 0.5],
      [0.88, 0.56],
      [0.86, 0.62],
      [0.88, 0.68],
      [0.92, 0.74],
      [0.94, 0.8],
      [0.92, 0.86],
      [0.86, 0.9],
      [0.78, 0.92],
      [0.7, 0.92],
      [0.62, 0.9],
      [0.54, 0.88],
      [0.46, 0.86],
      [0.38, 0.86],
      [0.3, 0.88],
      [0.22, 0.88],
      [0.16, 0.86],
      [0.1, 0.82],
      [0.06, 0.76],
      [0.04, 0.68],
      [0.03, 0.6],
    ];
    return norm.map(([nx, ny]) => ({
      x: Math.floor(ISLAND_X0 + nx * ISLAND_W),
      y: Math.floor(ISLAND_Y0 + ny * ISLAND_H),
    }));
  }, []);
  const pointInPolygon = React.useCallback(
    (wx: number, wy: number) => {
      let inside = false;
      for (
        let i = 0, j = ISLAND_POLY.length - 1;
        i < ISLAND_POLY.length;
        j = i++
      ) {
        const xi = ISLAND_POLY[i]!.x,
          yi = ISLAND_POLY[i]!.y;
        const xj = ISLAND_POLY[j]!.x,
          yj = ISLAND_POLY[j]!.y;
        const intersect =
          yi > wy !== yj > wy &&
          wx < ((xj - xi) * (wy - yi)) / (yj - yi + 1e-7) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    },
    [ISLAND_POLY],
  );

  // Distance from a cell center to the island coastline (polygon edges), in cells
  const distanceToCoast = React.useCallback(
    (wx: number, wy: number) => {
      const px = wx + 0.5;
      const py = wy + 0.5;
      let min = Infinity;
      for (let i = 0; i < ISLAND_POLY.length; i++) {
        const a = ISLAND_POLY[i]!;
        const b = ISLAND_POLY[(i + 1) % ISLAND_POLY.length]!;
        const vx = b.x - a.x;
        const vy = b.y - a.y;
        const wxp = px - a.x;
        const wyp = py - a.y;
        const c1 = vx * wxp + vy * wyp;
        const c2 = vx * vx + vy * vy;
        let t = 0;
        if (c2 > 0) t = Math.max(0, Math.min(1, c1 / c2));
        const projx = a.x + t * vx;
        const projy = a.y + t * vy;
        const d = Math.hypot(px - projx, py - projy);
        if (d < min) min = d;
      }
      return min;
    },
    [ISLAND_POLY],
  );

  /* overviewCellSize removed (unused) */

  const [ownedM2State, setOwnedM2State] = useState<number>(0);
  const isLockedView = false;

  // Zoomgrenzen (stufenlos)
  const allowedMaxCellSize = React.useMemo(() => 48, []);
  // Limit how far users can zoom out to keep requests light and avoid rate limits
  const minCellSizeAllowed: number = React.useMemo(() => 8, []);

  // "Classic" map mode (like early January): simpler rendering + no blocking on background image
  const useClassicMap = true;

  // Derived zoom level (0..5) used only for labels/scales
  const computedZoomLevel = React.useMemo(() => {
    const max = allowedMaxCellSize;
    const min = minCellSizeAllowed;
    const norm = (cellSize - min) / Math.max(1e-6, max - min);
    // 0 nah dran, 5 weit heraus
    return Math.max(0, Math.min(5, Math.round((1 - norm) * 5)));
  }, [cellSize]);
  const zoomOutLevel = computedZoomLevel;

  // Restrict how far the user can zoom in based on owned m²

  // Keep origin within the island bounds so we never drift into infinite sea
  const clampOriginToWorld = React.useCallback(
    (o: { x: number; y: number }, size: number = cellSize) => {
      const viewWNew = Math.max(4, Math.ceil(viewportSize.w / size));
      const viewHNew = Math.max(4, Math.ceil(viewportSize.h / size));
      const minX = ISLAND_X0;
      const minY = ISLAND_Y0;
      const maxX = ISLAND_X0 + ISLAND_W - viewWNew;
      const maxY = ISLAND_Y0 + ISLAND_H - viewHNew;
      return {
        x: Math.min(Math.max(o.x, minX), Math.max(minX, maxX)),
        y: Math.min(Math.max(o.y, minY), Math.max(minY, maxY)),
      };
    },
    [viewportSize.w, viewportSize.h, cellSize],
  );

  const centerOnIslandForSize = (size: number) => {
    const ZOOM_EPS = 0.2;
    if (Math.abs(size - cellSize) < ZOOM_EPS) return; // avoid unnecessary re-centering jitter
    // Keep the current center fixed when changing zoom, so the view never "slides".
    const viewWNew = Math.max(4, Math.ceil(viewportSize.w / size));
    const viewHNew = Math.max(4, Math.ceil(viewportSize.h / size));
    const currViewW = Math.max(4, Math.ceil(viewportSize.w / cellSize));
    const currViewH = Math.max(4, Math.ceil(viewportSize.h / cellSize));
    const currCenterX = origin.x + Math.floor(currViewW / 2);
    const currCenterY = origin.y + Math.floor(currViewH / 2);
    const unclamped = {
      x: currCenterX - Math.floor(viewWNew / 2),
      y: currCenterY - Math.floor(viewHNew / 2),
    };
    setOrigin(clampOriginToWorld(unclamped, size));
  };

  // Minimum zoom-out (smallest cell size) allowed depending on owned land

  // Prevent rapid repeated zoom actions to avoid UI hiccups
  const zoomCooldownRef = useRef(false);
  const startZoomCooldown = () => {
    zoomCooldownRef.current = true;
    window.setTimeout(() => {
      zoomCooldownRef.current = false;
    }, 150);
  };

  const handleZoomOut = () => {
    if (zoomCooldownRef.current && !zoomAnimRef.current) return;
    // Animated smooth zoom around viewport center
    const newSize = Math.max(minCellSizeAllowed, cellSize * 0.88);
    const ZOOM_EPS = 0.05;
    if (Math.abs(newSize - cellSize) < ZOOM_EPS) return;
    const rect = viewportRef.current?.getBoundingClientRect();
    const cx = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
    const cy = rect ? rect.top + rect.height / 2 : window.innerHeight / 2;
    animateZoomTo(newSize, cx, cy);
  };

  const handleZoomIn = () => {
    if (zoomCooldownRef.current && !zoomAnimRef.current) return;
    // Animated smooth zoom around viewport center
    const newSize = Math.min(allowedMaxCellSize, cellSize * 1.18);
    const ZOOM_EPS = 0.05;
    if (Math.abs(newSize - cellSize) < ZOOM_EPS) return;
    const rect = viewportRef.current?.getBoundingClientRect();
    const cx = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
    const cy = rect ? rect.top + rect.height / 2 : window.innerHeight / 2;
    animateZoomTo(newSize, cx, cy);
  };

  // Reset: center to the middle of the buildable green square and zoom in
  const centerToUnlock = () => {
    let tx: number;
    let ty: number;
    if (
      myAnchor &&
      typeof (myAnchor as any)?.x === "number" &&
      typeof (myAnchor as any)?.y === "number"
    ) {
      tx = Math.floor((myAnchor as any).x);
      ty = Math.floor((myAnchor as any).y);
    } else if (stableStartRef.current) {
      tx = Math.floor(stableStartRef.current.x);
      ty = Math.floor(stableStartRef.current.y);
    } else {
      tx = ISLAND_X0 + Math.floor(ISLAND_W / 2);
      ty = ISLAND_Y0 + Math.floor(ISLAND_H / 2);
    }
    // Goal: close-up view (e.g. 40px per cell), but never zoom out
    const targetNear = Math.min(allowedMaxCellSize, 40);
    const newSize = Math.max(cellSize, targetNear);
    const vw = Math.max(4, Math.ceil(viewportSize.w / newSize));
    const vh = Math.max(4, Math.ceil(viewportSize.h / newSize));
    setOrigin(
      clampOriginToWorld(
        { x: tx - Math.floor(vw / 2), y: ty - Math.floor(vh / 2) },
        newSize,
      ),
    );
    setCellSize(newSize);
  };
  // Panning state
  const panStartRef = useRef<{
    startX: number;
    startY: number;
    startOrigin: { x: number; y: number };
  } | null>(null);
  const panActiveRef = useRef(false);
  const panOffsetRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const panTransformRafRef = useRef<number | null>(null);
  const pendingTransformRef = useRef<{ x: number; y: number } | null>(null);
  const didPanRef = useRef(false);
  const buildTimerRef = useRef<number | null>(null);
  const panRafRef = useRef<number | null>(null);
  const pendingOriginRef = useRef<{ x: number; y: number } | null>(null);
  const lastMoveRef = useRef<{ x: number; y: number; ts: number } | null>(null);
  const velocityRef = useRef<{ vx: number; vy: number }>({ vx: 0, vy: 0 });
  const [isInteracting, setIsInteracting] = useState(false);
  const inertiaRafRef = useRef<number | null>(null);
  const stopInertia = () => {
    if (inertiaRafRef.current) cancelAnimationFrame(inertiaRafRef.current);
    inertiaRafRef.current = null;
    velocityRef.current = { vx: 0, vy: 0 };
  };
  const applyPanTransforms = (x: number, y: number) => {
    // batch DOM writes into a single rAF to avoid jank on high-frequency pointer events
    pendingTransformRef.current = { x, y };
    if (panTransformRafRef.current != null) return;
    panTransformRafRef.current = requestAnimationFrame(() => {
      const p = pendingTransformRef.current;
      panTransformRafRef.current = null;
      if (!p) return;
      const t = `translate3d(${p.x}px, ${p.y}px, 0)`;
      if (gridRef.current) gridRef.current.style.transform = t;
      if (roadsCanvasRef.current) roadsCanvasRef.current.style.transform = t;
      if (carsCanvasRef.current) carsCanvasRef.current.style.transform = t;
      if (gridOverlayRef.current) gridOverlayRef.current.style.transform = t;
    });
  };
  const startInertia = () => {
    stopInertia();
    setIsInteracting(true);
    // slightly lower friction + lower stop threshold for smoother, longer glide
    const friction = 0.99;
    const minSpeed = 0.0004; // px/ms
    let last = performance.now();
    let carryX = panOffsetRef.current.x;
    let carryY = panOffsetRef.current.y;
    const step = (now: number) => {
      const dt = Math.min(32, now - last);
      last = now;
      let { vx, vy } = velocityRef.current;
      vx *= friction;
      vy *= friction;
      velocityRef.current = { vx, vy };
      const speed = Math.hypot(vx, vy);
      if (speed < minSpeed) {
        applyPanTransforms(0, 0);
        panOffsetRef.current = { x: 0, y: 0 };
        inertiaRafRef.current = null;
        setIsInteracting(false);
        return;
      }
      carryX += vx * dt;
      carryY += vy * dt;
      const stepX = Math.trunc(carryX / cellSize);
      const stepY = Math.trunc(carryY / cellSize);
      const leftoverX = carryX - stepX * cellSize;
      const leftoverY = carryY - stepY * cellSize;
      applyPanTransforms(leftoverX, leftoverY);
      panOffsetRef.current = { x: leftoverX, y: leftoverY };
      if (stepX || stepY) {
        const base = originRef.current;
        const newOrigin = clampOriginToWorld({
          x: base.x - stepX,
          y: base.y - stepY,
        });
        if (newOrigin.x !== base.x || newOrigin.y !== base.y) {
          originRef.current = newOrigin;
          setOrigin(newOrigin);
        }
        carryX = leftoverX;
        carryY = leftoverY;
      }
      inertiaRafRef.current = requestAnimationFrame(step);
    };
    inertiaRafRef.current = requestAnimationFrame(step);
  };
  const selectedBuildType = null as null;
  // Double-tap helpers
  const lastTapTsRef = useRef<number>(0);
  const lastTapPosRef = useRef<{ x: number; y: number } | null>(null);

  const zoomAtClientPoint = (clientX: number, clientY: number) => {
    if (zoomCooldownRef.current) return;
    const newSize = Math.min(allowedMaxCellSize, cellSize * 1.15);
    const ZOOM_EPS = 0.2;
    if (Math.abs(newSize - cellSize) < ZOOM_EPS) return;
    // Smooth animated zoom around cursor/tap position
    animateZoomTo(newSize, clientX, clientY);
  };
  // build picker removed – no houses;

  useEffect(() => {
    const measure = () => {
      const el = viewportRef.current;
      if (el) {
        const rect = el.getBoundingClientRect();
        setViewportSize({
          w: Math.ceil(rect.width),
          h: Math.ceil(rect.height),
        });
      }
    };
    measure();
    window.addEventListener("resize", measure);
    return () => window.removeEventListener("resize", measure);
  }, []);

  // Keep refs in sync so pointer handlers always use the latest values (prevents jitter)
  useEffect(() => {
    originRef.current = origin;
    cellSizeRef.current = cellSize;
  }, [origin.x, origin.y, cellSize]);

  // Keep continuous-zoom limits
  useEffect(() => {
    let next = cellSize;
    if (next > allowedMaxCellSize) next = allowedMaxCellSize;
    if (next < minCellSizeAllowed) next = minCellSizeAllowed;
    if (next !== cellSize) {
      cellSizeRef.current = next;
      setCellSize(next);
      centerOnIslandForSize(next);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [allowedMaxCellSize, minCellSizeAllowed, cellSize]);

  // Center initial view on the island so it's visible immediately
  const didCenterOnceRef = useRef(false);
  // Stable per-user start: pick a deterministic point inside the island based on userId (or a local guest id)
  const authForStart = useAuth();
  const stableStartRef = useRef<{ x: number; y: number } | null>(null);
  function hash32(s: string): number {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619) >>> 0;
    }
    return h >>> 0;
  }
  function pickStableIslandPoint(seedStr: string): { x: number; y: number } {
    const seed = hash32(seedStr);
    // Initial guess within island bounds
    let x = ISLAND_X0 + (seed % ISLAND_W);
    let y = ISLAND_Y0 + (((seed >>> 11) % ISLAND_H) as number);
    if (pointInPolygon(x, y)) return { x, y };
    // Spiral out until we hit land
    const maxR = Math.max(ISLAND_W, ISLAND_H);
    for (let r = 1; r < maxR; r++) {
      for (let dx = -r; dx <= r; dx++) {
        const px1 = x + dx;
        const py1 = y - r;
        if (
          px1 >= ISLAND_X0 &&
          py1 >= ISLAND_Y0 &&
          px1 < ISLAND_X0 + ISLAND_W &&
          py1 < ISLAND_Y0 + ISLAND_H
        ) {
          if (pointInPolygon(px1, py1)) return { x: px1, y: py1 };
        }
        const py2 = y + r;
        if (
          px1 >= ISLAND_X0 &&
          py2 >= ISLAND_Y0 &&
          px1 < ISLAND_X0 + ISLAND_W &&
          py2 < ISLAND_Y0 + ISLAND_H
        ) {
          if (pointInPolygon(px1, py2)) return { x: px1, y: py2 };
        }
      }
      for (let dy = -r + 1; dy <= r - 1; dy++) {
        const py = y + dy;
        const pxL = x - r;
        const pxR = x + r;
        if (
          pxL >= ISLAND_X0 &&
          py >= ISLAND_Y0 &&
          pxL < ISLAND_X0 + ISLAND_W &&
          py < ISLAND_Y0 + ISLAND_H
        ) {
          if (pointInPolygon(pxL, py)) return { x: pxL, y: py };
        }
        if (
          pxR >= ISLAND_X0 &&
          py >= ISLAND_Y0 &&
          pxR < ISLAND_X0 + ISLAND_W &&
          py < ISLAND_Y0 + ISLAND_H
        ) {
          if (pointInPolygon(pxR, py)) return { x: pxR, y: py };
        }
      }
    }
    // Fallback to island center (should not happen)
    return {
      x: ISLAND_X0 + Math.floor(ISLAND_W / 2),
      y: ISLAND_Y0 + Math.floor(ISLAND_H / 2),
    };
  }
  useEffect(() => {
    if (!didCenterOnceRef.current && viewportSize.w > 0 && viewportSize.h > 0) {
      didCenterOnceRef.current = true;
      // Prefer server-assigned unique start anchor when available
      let start: { x: number; y: number } | null = null;
      // myStartAnchor may not be declared yet at this point; access via window stash if available
      const wAny: any = typeof window !== "undefined" ? window : {};
      const earlyAnchor = wAny.__myStartAnchor;
      if (
        earlyAnchor &&
        typeof earlyAnchor.x === "number" &&
        typeof earlyAnchor.y === "number"
      ) {
        start = { x: Math.floor(earlyAnchor.x), y: Math.floor(earlyAnchor.y) };
      }
      if (!start) {
        // Build a stable seed for guests or while waiting
        let seed = "guest";
        if (authForStart.status === "authenticated" && authForStart.userId) {
          seed = `user:${authForStart.userId}`;
        } else {
          try {
            const key = "guestSeedId_v1";
            let gid = localStorage.getItem(key);
            if (!gid) {
              gid = String(Math.random()).slice(2) + String(Date.now());
              localStorage.setItem(key, gid);
            }
            seed = `guest:${gid}`;
          } catch {}
        }
        start = pickStableIslandPoint(seed);
      }
      stableStartRef.current = start;
      const initialSize = isLockedView ? getLockedSize(0) : cellSize;
      const viewWNew = Math.max(4, Math.ceil(viewportSize.w / initialSize));
      setOrigin(
        clampOriginToWorld(
          {
            x: start.x - Math.floor(viewWNew / 2),
            y: start.y - Math.floor(viewWNew / 2),
          },
          initialSize,
        ),
      );
      if (ownedM2State <= 0) setCellSize(initialSize);
    }
  }, [
    viewportSize.w,
    viewportSize.h,
    cellSize,
    ownedM2State,
    minCellSizeAllowed,
    authForStart.status,
    authForStart.userId,
  ]);

  // If the server start anchor arrives later (e.g., after initial guest centering), re-center once for users with 0 m²
  const appliedServerCenterRef = useRef(false);

  const viewW = Math.max(4, Math.ceil(viewportSize.w / cellSize));
  const viewH = Math.max(4, Math.ceil(viewportSize.h / cellSize));

  const [searchParams, setSearchParams] = useSearchParams();
  // Drag-to-select state (buy mode)
  const [dragRect, setDragRect] = useState<{
    x: number;
    y: number;
    w: number;
    h: number;
  } | null>(null);
  const [selectionMode, setSelectionMode] = useState<"tap" | "drag">("tap");
  const dragStartRef = useRef<{ x: number; y: number } | null>(null);
  const [isDraggingSelect, setIsDraggingSelect] = useState(false);

  // Drag handlers: initiate rectangle without blocking simple clicks; only intercept once moved
  const handleDragDown = (ev: React.PointerEvent<HTMLDivElement>) => {
    if (mode !== "buy" || selectionMode !== "drag") return;
    // Ignore multi-touch: keep drag-select strictly single-finger so two-finger pan/pinch works
    if (ev.pointerType === "touch" && ev.isPrimary === false) return;
    const host = viewportRef.current;
    if (!host) return;
    const r = host.getBoundingClientRect();
    const rx = Math.max(0, Math.min(r.width, ev.clientX - r.left));
    const ry = Math.max(0, Math.min(r.height, ev.clientY - r.top));
    dragStartRef.current = { x: rx, y: ry };
    setDragRect({ x: rx, y: ry, w: 0, h: 0 });
    setIsDraggingSelect(false);
  };

  const handleDragMove = (ev: React.PointerEvent<HTMLDivElement>) => {
    if (!dragStartRef.current || mode !== "buy" || selectionMode !== "drag")
      return;
    // Ignore when a second touch is present (pinch/pan)
    if (ev.pointerType === "touch" && ev.isPrimary === false) return;
    const host = viewportRef.current;
    if (!host) return;
    const r = host.getBoundingClientRect();
    const rx = Math.max(0, Math.min(r.width, ev.clientX - r.left));
    const ry = Math.max(0, Math.min(r.height, ev.clientY - r.top));
    const x = Math.min(dragStartRef.current.x, rx);
    const y = Math.min(dragStartRef.current.y, ry);
    const w = Math.abs(rx - dragStartRef.current.x);
    const h = Math.abs(ry - dragStartRef.current.y);
    setDragRect({ x, y, w, h });
    if (!isDraggingSelect && Math.hypot(w, h) > 6) {
      setIsDraggingSelect(true);
    }
    if (isDraggingSelect) {
      ev.preventDefault();
      ev.stopPropagation();
    }
  };

  const handleDragUp = (ev: React.PointerEvent<HTMLDivElement>) => {
    if (
      !dragStartRef.current ||
      !dragRect ||
      mode !== "buy" ||
      selectionMode !== "drag"
    ) {
      setDragRect(null);
      dragStartRef.current = null;
      setIsDraggingSelect(false);
      return;
    }
    // Ignore if multi-touch gesture occurred
    if (ev.pointerType === "touch" && ev.isPrimary === false) {
      setDragRect(null);
      dragStartRef.current = null;
      setIsDraggingSelect(false);
      return;
    }

    const area = dragRect.w * dragRect.h;
    if (area > 4) {
      const leftPx = dragRect.x;
      const topPx = dragRect.y;
      const rightPx = dragRect.x + dragRect.w;
      const bottomPx = dragRect.y + dragRect.h;
      const x0 = origin.x + Math.max(0, Math.floor(leftPx / cellSize));
      const y0 = origin.y + Math.max(0, Math.floor(topPx / cellSize));
      const x1 =
        origin.x + Math.max(0, Math.floor(Math.max(0, rightPx - 1) / cellSize));
      const y1 =
        origin.y +
        Math.max(0, Math.floor(Math.max(0, bottomPx - 1) / cellSize));
      const minX = Math.min(x0, x1);
      const maxX = Math.max(x0, x1);
      const minY = Math.min(y0, y1);
      const maxY = Math.max(y0, y1);

      const candidates = (data?.cells ?? []).filter(
        (c: any) => c.x >= minX && c.x <= maxX && c.y >= minY && c.y <= maxY,
      );

      const additions = candidates.filter((c: any) => {
        const owned = !!c.ownerId;
        const kNum = cellKey(c.x, c.y);
        const listed = listedKeys.has(kNum) || optimisticHiddenKeys.has(kNum);
        const allowed = isAllowedLotWorld(c.x, c.y);
        return !owned && !listed && allowed;
      });

      if (additions.length) {
        setSelected((prev) => {
          const prevSet = new Set(prev.map((p) => `${p.x}:${p.y}`));
          const maxTotal =
            buyTarget > 0 ? Math.max(1, Math.floor(buyTarget)) : Infinity;
          const room =
            maxTotal === Infinity
              ? Infinity
              : Math.max(0, maxTotal - prev.length);
          const newOnes: { x: number; y: number }[] = [];
          for (const n of additions) {
            const k = `${n.x}:${n.y}`;
            if (!prevSet.has(k)) {
              if (room === Infinity || newOnes.length < room)
                newOnes.push({ x: n.x, y: n.y });
              else break;
            }
          }
          if (newOnes.length) {
            setSelectionHistory((h) => [...h, prev]);
            return [...prev, ...newOnes];
          }
          return prev;
        });
      }
    }
    if (isDraggingSelect) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    setDragRect(null);
    dragStartRef.current = null;
    setIsDraggingSelect(false);
  };
  // Restore last viewport
  useEffect(() => {
    try {
      const raw = localStorage.getItem("mapViewport");
      if (raw) {
        const parsed = JSON.parse(raw) as {
          x?: number;
          y?: number;
          cellSize?: number;
        };
        if (typeof parsed.x === "number" && typeof parsed.y === "number") {
          setOrigin(clampOriginToWorld({ x: parsed.x, y: parsed.y }));
        }
        if (typeof parsed.cellSize === "number") {
          setCellSize(Math.min(48, Math.max(4, Math.floor(parsed.cellSize))));
        }
      }
    } catch {}
  }, []);
  // Persist viewport (debounced)
  useEffect(() => {
    const id = window.setTimeout(() => {
      try {
        localStorage.setItem(
          "mapViewport",
          JSON.stringify({ x: origin.x, y: origin.y, cellSize }),
        );
      } catch {}
    }, 150);
    return () => window.clearTimeout(id);
  }, [origin.x, origin.y, cellSize]);
  const [coordInput, setCoordInput] = useState("");
  const [showFreePlots, setShowFreePlots] = useState(true);
  const coordInputRef = useRef<HTMLInputElement | null>(null);
  const [flashSearch, setFlashSearch] = useState(false);
  const [flash, setFlash] = useState<{
    x: number;
    y: number;
    until: number;
  } | null>(null);

  // Pointer handlers for thumb panning
  const handleCoordSearch = () => {
    // Accept formats: "x,y", "x y", or "x;y"
    const raw = (coordInput || "").trim();
    const match = raw.match(/(-?\d+)\s*[,;\s]\s*(-?\d+)/);
    if (!match) {
      toast({
        title: "Invalid coordinates",
        description: "Please enter as x,y (e.g. 123,456).",
      });
      return;
    }
    const tx = Math.floor(Number(match[1]));
    const ty = Math.floor(Number(match[2]));
    if (!Number.isFinite(tx) || !Number.isFinite(ty)) {
      toast({ title: "Invalid coordinates" });
      return;
    }
    // Center the searched cell
    const newX = tx - Math.floor(viewW / 2);
    const newY = ty - Math.floor(viewH / 2);
    setOrigin(clampOriginToWorld({ x: newX, y: newY }));
    setFlash({ x: tx, y: ty, until: Date.now() + 3000 });
  };

  // Active pointer tracking for pinch/zoom
  const activePointersRef = useRef<
    Map<number, { x: number; y: number; type: string }>
  >(new Map());
  const pinchActiveRef = useRef(false);
  const pinchStartRef = useRef<{
    dist: number;
    cellSize: number;
    midX: number;
    midY: number;
  } | null>(null);

  const zoomAroundClientPoint = (
    newSize: number,
    clientX: number,
    clientY: number,
  ) => {
    const rect = viewportRef.current?.getBoundingClientRect();
    if (!rect) return;

    const screenX = clientX - rect.left;
    const screenY = clientY - rect.top;

    const o = originRef.current;
    const cs = cellSizeRef.current;

    const worldX = o.x + Math.floor(screenX / cs);
    const worldY = o.y + Math.floor(screenY / cs);

    const newOrigin = {
      x: worldX - Math.floor(screenX / newSize),
      y: worldY - Math.floor(screenY / newSize),
    };

    const clamped = clampOriginToWorld(newOrigin, newSize);
    originRef.current = clamped;
    cellSizeRef.current = newSize;
    setOrigin(clamped);
    setCellSize(newSize);
  };

  // Ultra-smooth animated zoom for +/- controls
  const zoomAnimRef = useRef<number | null>(null);
  const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3);
  const animateZoomTo = (
    targetSize: number,
    anchorClientX?: number,
    anchorClientY?: number,
  ) => {
    const rect = viewportRef.current?.getBoundingClientRect();
    if (!rect) return;
    const from = cellSize;
    const to = targetSize;
    const duration = 340; // ms
    const start = performance.now();
    const ax = anchorClientX ?? rect.left + rect.width / 2;
    const ay = anchorClientY ?? rect.top + rect.height / 2;

    if (zoomAnimRef.current) cancelAnimationFrame(zoomAnimRef.current);
    startZoomCooldown();

    const step = (now: number) => {
      const t = Math.min(1, (now - start) / duration);
      const eased = easeOutCubic(t);
      const size = from + (to - from) * eased;
      zoomAroundClientPoint(size, ax, ay);
      if (t < 1) {
        zoomAnimRef.current = requestAnimationFrame(step);
      } else {
        zoomAnimRef.current = null;
      }
    };

    zoomAnimRef.current = requestAnimationFrame(step);
  };

  const wheelCarryRef = React.useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const wheelPanAccRef = React.useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const wheelPanRafRef = React.useRef<number | null>(null);

  const onViewportPointerDown = (ev: React.PointerEvent<HTMLDivElement>) => {
    if (ev.button !== 0 && ev.pointerType !== "touch") return;
    const rect = gridRef.current?.getBoundingClientRect();
    if (!rect) return;
    stopInertia();
    setIsInteracting(true);
    lastMoveRef.current = {
      x: ev.clientX,
      y: ev.clientY,
      ts: performance.now(),
    };

    // Track pointers (for pinch)
    // Important: we deliberately avoid setPointerCapture here so that
    // tap/click events still reach the individual m² tiles and they
    // remain directly tappable on touch devices.
    activePointersRef.current.set(ev.pointerId, {
      x: ev.clientX,
      y: ev.clientY,
      type: ev.pointerType,
    });

    if (activePointersRef.current.size >= 2) {
      // Start pinch
      const pts = Array.from(activePointersRef.current.values());
      const dx = pts[0]!.x - pts[1]!.x;
      const dy = pts[0]!.y - pts[1]!.y;
      const dist = Math.hypot(dx, dy);
      const midX = (pts[0]!.x + pts[1]!.x) / 2;
      const midY = (pts[0]!.y + pts[1]!.y) / 2;
      pinchActiveRef.current = true;
      pinchStartRef.current = { dist, cellSize, midX, midY };
      // Do not begin single-finger pan when pinch starts
      panActiveRef.current = false;
      return;
    }

    // Drag-select (classic buy flow)
    if (mode === "buy" && selectionMode === "drag") {
      try {
        ev.preventDefault();
        ev.stopPropagation();
      } catch {}
      didPanRef.current = true; // block tile clicks while drag-select is active
      handleDragDown(ev);
      return;
    }

    // One-finger panning
    panStartRef.current = {
      startX: ev.clientX,
      startY: ev.clientY,
      startOrigin: { ...origin },
    };
    panActiveRef.current = true;
    didPanRef.current = false;
    panOffsetRef.current = { x: 0, y: 0 };
    gridRef.current?.style.setProperty("transform", "translate3d(0,0,0)");
    roadsCanvasRef.current?.style.setProperty(
      "transform",
      "translate3d(0,0,0)",
    );
    carsCanvasRef.current?.style.setProperty("transform", "translate3d(0,0,0)");
    gridOverlayRef.current?.style.setProperty(
      "transform",
      "translate3d(0,0,0)",
    );
  };
  const onViewportPointerMove = (ev: React.PointerEvent<HTMLDivElement>) => {
    // Update tracked pointer position
    if (activePointersRef.current.has(ev.pointerId)) {
      activePointersRef.current.set(ev.pointerId, {
        x: ev.clientX,
        y: ev.clientY,
        type: ev.pointerType,
      });
    }

    // Pinch-to-zoom (and pan by moving midpoint)
    if (
      pinchActiveRef.current &&
      activePointersRef.current.size >= 2 &&
      pinchStartRef.current
    ) {
      const pts = Array.from(activePointersRef.current.values()).slice(0, 2);
      const dx = pts[0]!.x - pts[1]!.x;
      const dy = pts[0]!.y - pts[1]!.y;
      const dist = Math.hypot(dx, dy) || 1;
      const midX = (pts[0]!.x + pts[1]!.x) / 2;
      const midY = (pts[0]!.y + pts[1]!.y) / 2;

      const start = pinchStartRef.current;

      // Incremental pinch keeps things stable and avoids jitter from rounding.
      const ratio = Math.max(0.25, Math.min(4, dist / Math.max(1, start.dist)));
      const desired = Math.max(
        minCellSizeAllowed,
        Math.min(allowedMaxCellSize, start.cellSize * ratio),
      );

      // Zoom around current midpoint so the fingers feel anchored
      zoomAroundClientPoint(desired, midX, midY);

      // Two-finger pan (use incremental midpoint delta so it never “jumps”)
      const dxPx = midX - start.midX;
      const dyPx = midY - start.midY;
      if (Math.abs(dxPx) + Math.abs(dyPx) > 0.5) {
        const cs = cellSizeRef.current;
        const stepX = Math.floor(dxPx / cs);
        const stepY = Math.floor(dyPx / cs);
        if (stepX || stepY) {
          const base = originRef.current;
          const newOrigin = clampOriginToWorld({
            x: base.x - stepX,
            y: base.y - stepY,
          });
          if (newOrigin.x !== base.x || newOrigin.y !== base.y) {
            originRef.current = newOrigin;
            setOrigin(newOrigin);
          }
        }
      }

      // Update gesture baseline for smooth continuous zoom+pan
      start.dist = dist;
      start.cellSize = desired;
      start.midX = midX;
      start.midY = midY;

      return;
    }

    // Drag-select move (classic buy flow)
    if (mode === "buy" && selectionMode === "drag" && dragStartRef.current) {
      handleDragMove(ev);
      return;
    }

    // One-finger panning
    if (!panActiveRef.current || !panStartRef.current) return;
    const dx = ev.clientX - panStartRef.current.startX;
    const dy = ev.clientY - panStartRef.current.startY;
    // sample velocity
    try {
      const nowTs = performance.now();
      const last = lastMoveRef.current;
      if (last) {
        const dt = Math.max(1, nowTs - last.ts);
        const instVx = (ev.clientX - last.x) / dt;
        const instVy = (ev.clientY - last.y) / dt;
        const prev = velocityRef.current;
        velocityRef.current = {
          vx: prev.vx * 0.8 + instVx * 0.2,
          vy: prev.vy * 0.8 + instVy * 0.2,
        };
      }
      lastMoveRef.current = { x: ev.clientX, y: ev.clientY, ts: nowTs };
    } catch {}
    if (!didPanRef.current && Math.hypot(dx, dy) > 8) {
      didPanRef.current = true;
      if (buildTimerRef.current) {
        window.clearTimeout(buildTimerRef.current);
        buildTimerRef.current = null;
      }
    }
    if (!didPanRef.current) return;

    const stepX = Math.floor(dx / cellSize);
    const stepY = Math.floor(dy / cellSize);
    const leftoverX = dx - stepX * cellSize;
    const leftoverY = dy - stepY * cellSize;
    panOffsetRef.current = { x: -leftoverX, y: -leftoverY };
    applyPanTransforms(panOffsetRef.current.x, panOffsetRef.current.y);

    const newX = panStartRef.current.startOrigin.x - stepX;
    const newY = panStartRef.current.startOrigin.y - stepY;
    const curr = pendingOriginRef.current;
    if (!curr || curr.x !== newX || curr.y !== newY) {
      pendingOriginRef.current = { x: newX, y: newY };
      if (!panRafRef.current) {
        panRafRef.current = window.requestAnimationFrame(() => {
          if (pendingOriginRef.current)
            setOrigin(clampOriginToWorld(pendingOriginRef.current!));
          panRafRef.current = null;
        });
      }
    }
  };
  const clearTransforms = () => {
    gridRef.current && (gridRef.current.style.transform = "");
    roadsCanvasRef.current && (roadsCanvasRef.current.style.transform = "");
    carsCanvasRef.current && (carsCanvasRef.current.style.transform = "");
    gridOverlayRef.current && (gridOverlayRef.current.style.transform = "");
  };

  const onViewportPointerUp = (ev: React.PointerEvent<HTMLDivElement>) => {
    // Remove pointer from tracking
    if (activePointersRef.current.has(ev.pointerId)) {
      activePointersRef.current.delete(ev.pointerId);
    }
    if (activePointersRef.current.size < 2) {
      pinchActiveRef.current = false;
      pinchStartRef.current = null;
    }

    if (buildTimerRef.current) {
      window.clearTimeout(buildTimerRef.current);
      buildTimerRef.current = null;
    }

    // Drag-select end (classic buy flow)
    if (mode === "buy" && selectionMode === "drag" && dragStartRef.current) {
      handleDragUp(ev);
      // allow clicks again after finishing
      didPanRef.current = false;
      if (activePointersRef.current.size === 0) setIsInteracting(false);
      return;
    }

    if (panActiveRef.current) {
      panActiveRef.current = false;
      panStartRef.current = null;
      if (panRafRef.current) {
        cancelAnimationFrame(panRafRef.current);
        panRafRef.current = null;
      }
      pendingOriginRef.current = null;
      // don't clear immediately; inertia might continue
      if (Math.hypot(velocityRef.current.vx, velocityRef.current.vy) < 0.02) {
        clearTransforms();
      }

      // Double-tap/double-click zoom detection
      // Start inertia if there was a pan gesture
      if (didPanRef.current) {
        if (
          Math.hypot(velocityRef.current.vx, velocityRef.current.vy) >= 0.02
        ) {
          startInertia();
        } else {
          setIsInteracting(false);
        }
      }
      if (!didPanRef.current) {
        const now = Date.now();
        const last = lastTapTsRef.current || 0;
        const dt = now - last;
        const cx = ev.clientX;
        const cy = ev.clientY;
        const lastPos = lastTapPosRef.current;
        lastTapTsRef.current = now;
        lastTapPosRef.current = { x: cx, y: cy };
        const closeInSpace = lastPos
          ? Math.hypot((lastPos.x || 0) - cx, (lastPos.y || 0) - cy) < 24
          : false;
        if (dt < 280 && closeInSpace) {
          zoomAtClientPoint(cx, cy);
        }
        setIsInteracting(false);
      }
    }
  };
  const buyTarget = Number(searchParams.get("buy") || 0);
  const sellTarget = Number(searchParams.get("sell") || 0);
  const listParam = searchParams.get("list");
  const focusXParam = searchParams.get("focusX");
  const focusYParam = searchParams.get("focusY");
  const certIdParam = searchParams.get("certId");
  const mode: "buy" | "sell" | "list" | "browse" = listParam
    ? "list"
    : buyTarget > 0
      ? "buy"
      : sellTarget > 0
        ? "sell"
        : "browse";

  // Optional: certificate lookup for focusing via certId if X/Y aren't provided
  const { data: _allCertsForFocus } = useQuery(
    ["certsForFocus", certIdParam],
    () => apiClient.listCertificates(),
    {
      enabled: !!certIdParam,
      staleTime: 60_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      retry: 0,
    },
  );

  const CHUNK_SIZE = 100;
  const [fetchAnchor, setFetchAnchor] = useState<{ x: number; y: number }>(
    () => ({
      x: Math.floor(origin.x / CHUNK_SIZE) * CHUNK_SIZE,
      y: Math.floor(origin.y / CHUNK_SIZE) * CHUNK_SIZE,
    }),
  );
  const fetchDebounceRef = useRef<number | null>(null);
  const [didFirstStableMap, setDidFirstStableMap] = useState(false);
  const desiredFetchAnchor = React.useMemo(
    () => ({
      x: Math.floor(origin.x / CHUNK_SIZE) * CHUNK_SIZE,
      y: Math.floor(origin.y / CHUNK_SIZE) * CHUNK_SIZE,
    }),
    [origin.x, origin.y],
  );
  const isFetchAnchorSynced =
    fetchAnchor.x === desiredFetchAnchor.x &&
    fetchAnchor.y === desiredFetchAnchor.y;
  // Area overlay & search
  const areasCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const [areaQuery, setAreaQuery] = useState<string>("");
  void areaQuery;
  void setAreaQuery;
  const AREAS_PER_ROW = 50;
  const AREA_W = 80; // cells (m²) per area width
  const AREA_H = 40; // cells per area height
  const AREAS_TOTAL = 1250; // 50 x 25 grid = 1,250 areas
  useEffect(() => {
    if (fetchDebounceRef.current) window.clearTimeout(fetchDebounceRef.current);

    const delay = didFirstStableMap ? 250 : 0;

    fetchDebounceRef.current = window.setTimeout(() => {
      setFetchAnchor((prev) => {
        if (prev.x === desiredFetchAnchor.x && prev.y === desiredFetchAnchor.y)
          return prev;
        return { x: desiredFetchAnchor.x, y: desiredFetchAnchor.y };
      });
    }, delay) as unknown as number;

    return () => {
      if (fetchDebounceRef.current)
        window.clearTimeout(fetchDebounceRef.current);
    };
  }, [desiredFetchAnchor.x, desiredFetchAnchor.y]);

  const fetchX0 = fetchAnchor.x;
  const fetchY0 = fetchAnchor.y;
  const fetchW = CHUNK_SIZE;
  const fetchH = CHUNK_SIZE;

  // Global map request guard to avoid bursts and recover after limits
  const lastMapReqTsRef = React.useRef<number>(0);
  const mapCooldownUntilRef = React.useRef<number>(0);
  async function limitedGetMapChunk(params: {
    x0: number;
    y0: number;
    width: number;
    height: number;
  }) {
    const now = Date.now();
    if (mapCooldownUntilRef.current && now < mapCooldownUntilRef.current) {
      await new Promise((r) =>
        setTimeout(r, mapCooldownUntilRef.current - now),
      );
    }
    const since = now - (lastMapReqTsRef.current || 0);
    const minGap = 400; // min ~0.4s between map requests
    if (since < minGap) {
      await new Promise((r) => setTimeout(r, minGap - since));
    }
    lastMapReqTsRef.current = Date.now();
    return apiClient.getMapChunk({ ...params, accessToken } as any);
  }

  const {
    data,
    refetch,
    isFetching,
    isFetched: isMapFetched,
    isInitialLoading: isMapInitialLoading,
    isError: isMapError,
    error: mapError,
  } = useQuery(
    ["map", fetchX0, fetchY0, fetchW, fetchH],
    () =>
      limitedGetMapChunk({
        x0: fetchX0,
        y0: fetchY0,
        width: fetchW,
        height: fetchH,
      }),
    {
      keepPreviousData: true,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      staleTime: 10000,
      retry: 0,
      onError: () => {
        // Back off for a few seconds and zoom to safe level
        mapCooldownUntilRef.current = Date.now() + 5000;
        setCellSize((s) => (s < 40 ? 40 : s));
      },
    },
  );

  // Fetch cell→m² scale from server
  const { data: scaleResp } = useQuery<CellScaleOutput>(
    ["cellScale"],
    () => apiClient.getCellToM2Scale(),
    {
      // This rarely changes; keep it cached to reduce background load.
      staleTime: Infinity,
      cacheTime: Infinity,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      retry: 1,
    },
  );
  const cellScale = scaleResp?.scale ?? 1;

  // Active secondary listings to hide from map
  const { data: activeListings, refetch: refetchListings } = useQuery(
    ["activeListings"],
    () => apiClient.listSecondaryListings(),
    {
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      retry: 0,
    },
  );

  // Listen to secondary market events to keep listed/hide state in sync
  const [secondaryRT] = useRealtimeStore("secondary", { ts: 0 });

  // Refetch when secondary market updates
  useEffect(() => {
    if (secondaryRT?.ts) void refetchListings();
  }, [secondaryRT?.ts]);

  const [mapRT] = useRealtimeStore("map", { ts: 0, changes: [] as any[] });
  useEffect(() => {
    // Throttle realtime-triggered refetches to max ~1 every 2s
    const now = Date.now();
    // store on window to avoid re-creating a ref
    const key = "__lastMapRefetchTs" as const;
    const last = (window as any)[key] as number | undefined;
    if (mapRT?.ts && (!last || now - last > 5000)) {
      (window as any)[key] = now;
      void refetch();
    }
  }, [mapRT?.ts]);

  const [selected, setSelected] = useState<{ x: number; y: number }[]>([]);
  const [, setSelectionHistory] = useState<{ x: number; y: number }[][]>([]);
  const [myListOpen, setMyListOpen] = useState(false);
  const [myHighlightUntil, setMyHighlightUntil] = useState<number>(0);

  const { data: myPlots } = useQuery(
    ["myPlots", accessToken],
    () => apiClient.listMyPlots({ accessToken } as any),
    {
      enabled: auth.status === "authenticated" && !isGuest,
      staleTime: 15000,
      refetchOnWindowFocus: false,
    },
  );
  // Compute unlocked window size based on owned m²: starts at 8x8, then +4 per sqrt step (8,12,16,20,…)
  const unlockedSide = React.useMemo(() => {
    // Start 8×8; for each additional owned 1 m² grow window by +2 cells in width AND height
    const nWhole = Math.max(0, Math.floor(ownedM2State || 0));
    const side = 8 + 2 * nWhole; // 0 m² => 8, 1 m² => 10, 2 m² => 12, ...
    // No artificial cap; effectively capped by viewport/world when rendering
    return Math.max(8, side);
  }, [ownedM2State]);
  // Map overview kept for potential future use (not shown in UI)
  // Disable it for now to avoid background requests.
  useQuery(["mapOverview"], () => apiClient.getMapOverview(), {
    enabled: false,
  });
  const { data: market } = useQuery<MarketOutput>(
    ["market"],
    () => apiClient.getMarket(),
    {
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      retry: 0,
    },
  );
  const templateUrlForMap = market?.certificateTemplateUrl ?? null;

  const mapQueryClient = useQueryClient();

  /* focusMyPlots removed: list opens instead */
  function focusMyPlotsRemoved() {
    try {
      const plots = Array.isArray(myPlots) ? (myPlots as any[]) : [];
      if (!plots || plots.length === 0) {
        toast({
          title: "No m² owned",
          description: "Buy land first to see it here.",
        });
        return;
      }
      let minX = Infinity,
        maxX = -Infinity,
        minY = Infinity,
        maxY = -Infinity;
      for (const p of plots) {
        const x = Math.floor(p.x),
          y = Math.floor(p.y);
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      const widthCells = Math.max(1, maxX - minX + 1);
      const heightCells = Math.max(1, maxY - minY + 1);
      const marginCells = 2;
      const targetW = widthCells + marginCells * 2;
      const targetH = heightCells + marginCells * 2;
      const sizeByW =
        viewportSize.w > 0 ? Math.floor(viewportSize.w / targetW) : cellSize;
      const sizeByH =
        viewportSize.h > 0 ? Math.floor(viewportSize.h / targetH) : cellSize;
      const desired = Math.max(
        minCellSizeAllowed,
        Math.min(allowedMaxCellSize, Math.floor(Math.min(sizeByW, sizeByH))),
      );
      // compute view size at desired
      const vW = Math.max(4, Math.ceil(viewportSize.w / desired));
      const vH = Math.max(4, Math.ceil(viewportSize.h / desired));
      const centerX = Math.floor((minX + maxX) / 2);
      const centerY = Math.floor((minY + maxY) / 2);
      const newOrigin = clampOriginToWorld(
        { x: centerX - Math.floor(vW / 2), y: centerY - Math.floor(vH / 2) },
        desired,
      );
      setCellSize(() => desired);
      setOrigin(newOrigin);
      setMyHighlightUntil(Date.now() + 5000);
    } catch {
      // no-op
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  false && focusMyPlotsRemoved();

  const [mapPreviewCert, setMapPreviewCert] = useState<{
    id: string;
    x?: number;
    y?: number;
    date?: string;
  } | null>(null);
  const openCertificateFor = async (x: number, y: number) => {
    try {
      const certs = (await mapQueryClient.fetchQuery(["certsForMap"], () =>
        apiClient.listCertificates({
          accessToken,
        }),
      )) as any[];
      const match = certs.find(
        (c) => c?.plot && c.plot.x === x && c.plot.y === y,
      );
      if (match) {
        setMapPreviewCert({ id: match.id, x, y, date: match.purchasedAt });
      } else {
        toast({
          title: "No certificate",
          description: "There is no certificate for this plot.",
        });
      }
    } catch (e: any) {
      toast({
        title: "Error",
        description: e?.message ?? "Unknown error",
      });
    }
  };

  const { data: profile } = useQuery<GetProfileOutput>(
    ["profile"],
    () => apiClient.getProfile(),
    {
      enabled: auth.status === "authenticated",
      staleTime: 30_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      retry: 1,
    },
  );
  const { data: portfolio } = useQuery<PortfolioOutput>(
    ["portfolio", accessToken],
    () => apiClient.getPortfolio({ accessToken } as any),
    {
      enabled: auth.status === "authenticated" && !!accessToken && !isGuest,
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      retry: 0,
    },
  );
  type MyStartAnchorOutput = inferRPCOutputType<"getMyStartAnchor">;
  const { data: myStartAnchor } = useQuery<MyStartAnchorOutput>(
    ["myStartAnchor", accessToken],
    () => apiClient.getMyStartAnchor({ accessToken } as any),
    {
      enabled: auth.status === "authenticated" && !isGuest,
      staleTime: Infinity,
      cacheTime: Infinity,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      retry: 0,
    },
  );
  const { data: myAnchor } = useQuery<MyAnchorOutput>(
    ["myAnchor", portfolio?.landOwnedM2, accessToken],
    () => apiClient.getMyAnchorPlot({ accessToken } as any),
    {
      enabled: (portfolio?.landOwnedM2 ?? 0) > 0,
      staleTime: 30_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      retry: 0,
    },
  );
  // Re-center once when server-assigned start anchor arrives (for users with 0 m²)
  useEffect(() => {
    if (
      myStartAnchor &&
      viewportSize.w > 0 &&
      viewportSize.h > 0 &&
      ownedM2State <= 0 &&
      !appliedServerCenterRef.current
    ) {
      const start = {
        x: Math.floor((myStartAnchor as any).x),
        y: Math.floor((myStartAnchor as any).y),
      };
      const targetSize = Math.min(allowedMaxCellSize, 40);
      const vw = Math.max(4, Math.floor(viewportSize.w / targetSize));
      const vh = Math.max(4, Math.floor(viewportSize.h / targetSize));
      setCellSize((s) => (s < targetSize ? targetSize : s));
      setOrigin(
        clampOriginToWorld(
          { x: start.x - Math.floor(vw / 2), y: start.y - Math.floor(vh / 2) },
          targetSize,
        ),
      );
      stableStartRef.current = start;
      appliedServerCenterRef.current = true;
    }
  }, [myStartAnchor, viewportSize.w, viewportSize.h, ownedM2State]);

  // Always center on user's land when the map opens: prefer largest connected cluster
  const centeredToMyOwnedRef = useRef(false);
  useEffect(() => {
    if (centeredToMyOwnedRef.current) return;
    if (viewportSize.w <= 0 || viewportSize.h <= 0) return;

    // Helper: compute largest 4-connected component from myPlots (if available)
    const plots = Array.isArray(myPlots) ? (myPlots as any[]) : [];
    let centerFromPlots: { x: number; y: number } | null = null;

    if (plots.length > 0) {
      const keys = new Set<string>();
      const coords: Array<{ x: number; y: number }> = plots.map((p: any) => ({
        x: Math.floor(p.x),
        y: Math.floor(p.y),
      }));
      coords.forEach((c) => keys.add(`${c.x}:${c.y}`));
      const visited = new Set<string>();
      let bestSize = 0;
      let bestCenter: { x: number; y: number } | null = null;
      for (const c of coords) {
        const k = `${c.x}:${c.y}`;
        if (visited.has(k)) continue;
        // BFS
        const q: Array<{ x: number; y: number }> = [c];
        visited.add(k);
        let sumX = 0,
          sumY = 0,
          n = 0;
        while (q.length) {
          const cur = q.shift()!;
          sumX += cur.x;
          sumY += cur.y;
          n++;
          const neigh = [
            { x: cur.x + 1, y: cur.y },
            { x: cur.x - 1, y: cur.y },
            { x: cur.x, y: cur.y + 1 },
            { x: cur.x, y: cur.y - 1 },
          ];
          for (const nb of neigh) {
            const nk = `${nb.x}:${nb.y}`;
            if (keys.has(nk) && !visited.has(nk)) {
              visited.add(nk);
              q.push(nb);
            }
          }
        }
        if (n > bestSize) {
          bestSize = n;
          bestCenter = { x: Math.round(sumX / n), y: Math.round(sumY / n) };
        }
      }
      if (bestCenter) centerFromPlots = bestCenter;
    }

    const start = centerFromPlots
      ? centerFromPlots
      : myAnchor
        ? {
            x: Math.floor(myAnchor.x as number),
            y: Math.floor(myAnchor.y as number),
          }
        : null;

    if (!start) return;

    const targetSize = Math.min(allowedMaxCellSize, 40);
    const vw = Math.max(4, Math.floor(viewportSize.w / targetSize));
    const vh = Math.max(4, Math.floor(viewportSize.h / targetSize));
    setCellSize((s) => (s < targetSize ? targetSize : s));
    setOrigin(
      clampOriginToWorld(
        { x: start.x - Math.floor(vw / 2), y: start.y - Math.floor(vh / 2) },
        targetSize,
      ),
    );
    centeredToMyOwnedRef.current = true;
  }, [myPlots, myAnchor, viewportSize.w, viewportSize.h, allowedMaxCellSize]);

  useEffect(() => {
    setOwnedM2State((portfolio?.landOwnedM2 ?? 0) as number);
  }, [portfolio?.landOwnedM2]);
  // Center view around the first owned plot (anchor) when available
  // Re-Center auf erstes eigenes Feld deaktiviert: die Ansicht bleibt fix.
  useEffect(() => {
    void myAnchor; // no-op; keep linter happy
  }, [myAnchor]);
  const { data: simBuy } = useQuery<SimBuyOutput>(
    ["simPlotsBuy", selected.length, cellScale],
    () => apiClient.simulateBuyCost({ m2: selected.length }),
    {
      enabled: mode === "buy" && selected.length > 0,
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      retry: 0,
    },
  );
  const { data: simSell } = useQuery<SimSellOutput>(
    ["simPlotsSell", selected.length, cellScale],
    () => apiClient.simulateSellProceeds({ m2: selected.length }),
    {
      enabled: mode === "sell" && selected.length > 0,
      staleTime: 15_000,
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
      retry: 0,
    },
  );
  const queryClient = useQueryClient();
  const { toast: _toast } = useToast();

  // Admin: set exact map background image
  // Removed Set BG admin control from UI

  const toast = React.useCallback(
    (opts: any) => {
      setTimeout(() => _toast(opts), 0);
    },
    [_toast],
  );

  const selectedRef = useRef<{ x: number; y: number }[]>([]);
  const navigate = useNavigate();
  void navigate;
  const [showSuccessOverlay, setShowSuccessOverlay] = useState(false);
  const triggerSuccess = () => {
    setShowSuccessOverlay(true);
    window.setTimeout(() => setShowSuccessOverlay(false), 3000);
  };

  const [mapBuySuccessOpen, setMapBuySuccessOpen] = useState(false);
  const [mapBuySuccessM2, setMapBuySuccessM2] = useState(0);
  const [mapBuySuccessFocus, setMapBuySuccessFocus] = useState<{
    x: number;
    y: number;
  } | null>(null);

  const proceedAfterMapBuySuccess = () => {
    setMapBuySuccessOpen(false);
    const f = mapBuySuccessFocus;
    if (!f) return;

    const targetCellSize = Math.min(allowedMaxCellSize, 40);
    setCellSize((s) => (s < targetCellSize ? targetCellSize : s));

    const vw = Math.max(4, Math.floor(viewportSize.w / targetCellSize));
    const vh = Math.max(4, Math.floor(viewportSize.h / targetCellSize));
    setOrigin(
      clampOriginToWorld(
        { x: f.x - Math.floor(vw / 2), y: f.y - Math.floor(vh / 2) },
        targetCellSize,
      ),
    );
    setFlash({ x: f.x, y: f.y, until: Date.now() + 6000 });
  };

  const buyMutation = useMutation(apiClient.buyAndClaimPlots, {
    onMutate: (vars) => {
      selectedRef.current = vars.coords;
    },
    onSuccess: async () => {
      const coords = selectedRef.current;
      setSelected([]);
      setSelectionHistory([]);
      // refresh everything that depends on ownership immediately
      await queryClient.invalidateQueries(["market"]);
      await queryClient.invalidateQueries(["portfolio"]);
      await queryClient.invalidateQueries(["myPlots"]);
      await queryClient.invalidateQueries(["myPlots_2nd"]);
      await queryClient.invalidateQueries(["certificates"]);

      // actively refetch so the new m² appears without waiting
      await queryClient.refetchQueries(["portfolio"], { active: true } as any);
      await queryClient.refetchQueries(["myPlots"], { active: true } as any);
      await queryClient.refetchQueries(["myPlots_2nd"], {
        active: true,
      } as any);

      await refetch();
      setMyHighlightUntil(Date.now() + 5000);
      const list = coords
        .slice(0, 5)
        .map((c) => `(${c.x},${c.y})`)
        .join(", ");
      toast({
        title: "Plots purchased",
        description: coords.length
          ? `New: ${coords.length} plot(s) at ${list}${coords.length > 5 ? " …" : ""}`
          : undefined,
      });
      setMapBuySuccessM2(Math.max(0, coords.length));
      setMapBuySuccessFocus(coords?.[0] ?? null);
      setMapBuySuccessOpen(true);
      window.setTimeout(() => triggerSuccess(), 50);
      setSearchParams({});
    },
    onError: (e: any) => {
      toast({
        title: t("buyFailed"),
        description: e?.message ?? "Unknown error",
      });
    },
  });

  const sellPlotsMutation = useMutation(apiClient.sellSelectedPlots, {
    onMutate: (vars) => {
      selectedRef.current = vars.coords;
    },
    onSuccess: async (res) => {
      // Show success immediately.
      triggerSuccess();
      const coords = selectedRef.current;
      setSelected([]);
      await queryClient.invalidateQueries(["market"]);
      await queryClient.invalidateQueries(["portfolio"]);
      await refetch();
      const list = coords
        .slice(0, 5)
        .map((c) => `(${c.x},${c.y})`)
        .join(", ");
      const baseDesc = coords.length
        ? `Sold: ${coords.length} plot(s) from ${list}${coords.length > 5 ? " …" : ""}`
        : undefined;
      const profit = typeof res?.profitCHF === "number" ? res!.profitCHF : 0;
      const isProfit = profit >= 0;
      const net = typeof res?.netCHF === "number" ? res!.netCHF : 0;
      const desc = `${baseDesc ? baseDesc + " • " : ""}${isProfit ? "Profit" : "Loss"}: ${currencyUSD(Math.abs(profit))} (Net: ${currencyUSD(net)})`;
      toast({
        title: "Plots sold",
        description: desc,
        ...(isProfit ? {} : ({ variant: "destructive" } as any)),
      } as any);
      setSearchParams({});
    },
    onError: (e: any) => {
      toast({
        title: t("sellFailed"),
        description: e?.message ?? "Unknown error",
      });
    },
  });

  // Optimistic hidden plots right after listing
  const [optimisticHidden, setOptimisticHidden] = useState<Set<string>>(
    new Set(),
  );
  const [listDrawerOpen, setListDrawerOpen] = useState(false);
  const [listPrices, setListPrices] = useState<Record<string, string>>({});

  const createListingsBatch = useMutation(
    async (input: {
      items: Array<{ x: number; y: number; priceEUR: number }>;
    }) => {
      await Promise.all(
        input.items.map((it) =>
          apiClient.createSecondaryListing({
            x: it.x,
            y: it.y,
            priceEUR: it.priceEUR,
            accessToken,
          } as any),
        ),
      );
    },
    {
      onMutate: async (vars) => {
        const keys = vars.items.map(
          (it) => `${Math.floor(it.x)}:${Math.floor(it.y)}`,
        );
        setOptimisticHidden((prev) => {
          const s = new Set(prev);
          keys.forEach((k) => s.add(k));
          return s;
        });
        await queryClient.cancelQueries(["activeListings"]);
        const previous = queryClient.getQueryData(["activeListings"]);
        queryClient.setQueryData(["activeListings"], (old: any) => {
          const arr = Array.isArray(old) ? old.slice() : [];
          vars.items.forEach((it) =>
            arr.push({
              x: Math.floor(it.x),
              y: Math.floor(it.y),
              priceEUR: it.priceEUR,
              listedAt: new Date().toISOString(),
            }),
          );
          return arr;
        });
        return { previous };
      },
      onSuccess: async () => {
        setSelected([]);
        setListPrices({});
        setListDrawerOpen(false);
        toast({ title: "Listings created" });
        triggerSuccess();
        await Promise.all([
          queryClient.invalidateQueries(["activeListings"]),
          queryClient.invalidateQueries(["secondaryListings"]),
        ]);
        await refetchListings();
        setSearchParams({});
      },
      onError: (e: any, _vars, context) => {
        if ((context as any)?.previous)
          queryClient.setQueryData(
            ["activeListings"],
            (context as any).previous,
          );
        toast({
          title: "Listing failed",
          description: (e?.message || "").toLowerCase().includes("too many")
            ? "Please enter a smaller amount (max 500 m² at once)."
            : e?.message || "Please try again.",
        });
      },
    },
  );

  const [sellPulse, setSellPulse] = React.useState<Record<string, number>>({});
  const [infoTip, setInfoTip] = React.useState<{
    x: number;
    y: number;
    until: number;
    text: string;
    sub?: string;
  } | null>(null);
  const pulseRing = (x: number, y: number) => {
    const key = `${x}:${y}`;
    setSellPulse((prev) => ({ ...prev, [key]: Date.now() }));
    window.setTimeout(() => {
      setSellPulse((prev) => {
        const cp = { ...prev } as Record<string, number>;
        delete cp[key];
        return cp;
      });
    }, 3000);
  };

  const toggleSelect = (
    x: number,
    y: number,
    owned: boolean,
    ownedByMe?: boolean,
  ) => {
    if (didPanRef.current) return; // ignore clicks after a pan gesture
    if (mode === "buy" && owned) return; // buy: only free cells
    if (mode === "sell" && (!owned || !ownedByMe)) return; // sell: only your owned cells
    setSelected((prev) => {
      const key = `${x}:${y}`;
      const exists = prev.find((c) => `${c.x}:${c.y}` === key);
      const next = exists
        ? prev.filter((c) => `${c.x}:${c.y}` !== key)
        : [...prev, { x, y }];

      if (mode === "buy" && !exists && buyTarget > 0) {
        const maxCells = Math.max(1, Math.floor(buyTarget));
        if (next.length > maxCells) {
          toast({
            title: "Target exceeded",
            description: `You can select up to ${maxCells} cell(s).`,
          });
          return prev;
        }
      }
      if (mode === "sell" && sellTarget > 0 && next.length > sellTarget) {
        next.shift();
      }
      // push history only if selection actually changes
      if (next.length !== prev.length) {
        setSelectionHistory((h) => [...h, prev]);
      }
      return next;
    });
  };

  const allCells = data?.cells ?? [];

  // Performance: keep tile elements stable while panning/zooming.
  // Instead of mapping by world-coordinates (which changes keys on every move),
  // we render a fixed grid of viewport positions and just swap the underlying cell data.
  const cellKey = React.useCallback(
    (x: number, y: number) => Math.floor(y) * ISLAND_W + Math.floor(x),
    [],
  );

  const cellMap = React.useMemo(() => {
    const m = new Map<number, any>();
    for (const c of allCells as any[]) {
      m.set(cellKey((c as any).x, (c as any).y), c);
    }
    return m;
  }, [allCells, cellKey]);

  const viewportPositions = React.useMemo(() => {
    const arr: Array<{ key: string; col: number; row: number }> = [];
    for (let row = 0; row < viewH; row++) {
      for (let col = 0; col < viewW; col++) {
        arr.push({ key: `${row}:${col}`, col, row });
      }
    }
    return arr;
  }, [viewW, viewH]);

  const selectedKeys = React.useMemo(() => {
    const s = new Set<number>();
    for (const c of selected) s.add(cellKey(c.x, c.y));
    return s;
  }, [selected, cellKey]);

  // Build a fast lookup for listed plots (hide on map)
  const listedKeys = React.useMemo(() => {
    const set = new Set<number>();
    (activeListings ?? []).forEach((l: any) =>
      set.add(cellKey((l as any).x, (l as any).y)),
    );
    return set;
  }, [activeListings, cellKey]);

  const optimisticHiddenKeys = React.useMemo(() => {
    const set = new Set<number>();
    (optimisticHidden ? Array.from(optimisticHidden) : []).forEach((k) => {
      const parts = k.split(":");
      const x = Number(parts[0]);
      const y = Number(parts[1]);
      if (Number.isFinite(x) && Number.isFinite(y)) set.add(cellKey(x, y));
    });
    return set;
  }, [optimisticHidden, cellKey]);

  // Fast lookup of my-owned cells for local 3×3 unlocks

  // Ensure selection never contains listed (hidden) plots (server state)
  useEffect(() => {
    if (mode !== "sell") {
      setSelected((prev) =>
        prev.filter((c) => !listedKeys.has(cellKey(c.x, c.y))),
      );
    }
  }, [listedKeys, mode, cellKey]);

  // Keep optimistic-hidden keys only while they are actually listed server-side
  // This makes canceled listings immediately reappear on the map
  useEffect(() => {
    // Keep the string-set for UI + API payloads, but only for still-listed items
    setOptimisticHidden((prev) => {
      if (!prev || prev.size === 0) return prev;
      const keep = new Set<string>();
      for (const key of prev) {
        const parts = key.split(":");
        const x = Number(parts[0]);
        const y = Number(parts[1]);
        if (
          Number.isFinite(x) &&
          Number.isFinite(y) &&
          listedKeys.has(cellKey(x, y))
        ) {
          keep.add(key);
        }
      }
      return keep.size === prev.size ? prev : keep;
    });
  }, [listedKeys, cellKey]);

  // Entferne selektierte Plots sofort, wenn sie optimistisch versteckt werden (Listing gestartet)
  useEffect(() => {
    if (!optimisticHidden || optimisticHidden.size === 0) return;
    setSelected((prev) =>
      prev.filter((c) => !optimisticHidden.has(`${c.x}:${c.y}`)),
    );
  }, [optimisticHidden]);

  // Houses removed: no house target drawer

  // Focus and flash a specific cell when arriving from a certificate
  useEffect(() => {
    const fx = Number(focusXParam ?? NaN);
    const fy = Number(focusYParam ?? NaN);
    if (
      !Number.isFinite(fx) ||
      !Number.isFinite(fy) ||
      viewportSize.w <= 0 ||
      viewportSize.h <= 0
    )
      return;

    // Zoom in so the highlighted m² is clearly visible
    const targetCellSize = Math.min(allowedMaxCellSize, 40); // nah, aber innerhalb der erlaubten Grenze
    const vw = Math.max(4, Math.ceil(viewportSize.w / targetCellSize));
    const vh = Math.max(4, Math.ceil(viewportSize.h / targetCellSize));

    setCellSize((s) => (s < targetCellSize ? targetCellSize : s));

    const cx = Math.floor(fx - Math.floor(vw / 2));
    const cy = Math.floor(fy - Math.floor(vh / 2));
    setOrigin(clampOriginToWorld({ x: cx, y: cy }, targetCellSize));
    setFlash({
      x: Math.floor(fx),
      y: Math.floor(fy),
      until: Date.now() + 6000,
    });
    const to = window.setTimeout(() => setFlash(null), 6000);
    // Clean params so es nicht erneut triggert
    const params = new URLSearchParams(searchParams);
    params.delete("focusX");
    params.delete("focusY");
    setSearchParams(params);
    return () => window.clearTimeout(to);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    focusXParam,
    focusYParam,
    viewportSize.w,
    viewportSize.h,
    allowedMaxCellSize,
  ]);

  // Fallback focus via certificate ID (if coordinates weren't provided)
  useEffect(() => {
    if (!certIdParam || !_allCertsForFocus) return;
    const c = (_allCertsForFocus as any[]).find(
      (x: any) => x?.id === certIdParam && x?.plot,
    );
    if (!c || !c.plot) return;
    const fx = Math.floor(c.plot.x);
    const fy = Math.floor(c.plot.y);

    const targetCellSize = Math.min(allowedMaxCellSize, 40);
    const vw = Math.max(4, Math.ceil(viewportSize.w / targetCellSize));
    const vh = Math.max(4, Math.ceil(viewportSize.h / targetCellSize));
    setCellSize((s) => (s < targetCellSize ? targetCellSize : s));

    const cx = Math.floor(fx - Math.floor(vw / 2));
    const cy = Math.floor(fy - Math.floor(vh / 2));
    setOrigin(clampOriginToWorld({ x: cx, y: cy }, targetCellSize));
    setFlash({ x: fx, y: fy, until: Date.now() + 6000 });
    const to = window.setTimeout(() => setFlash(null), 6000);
    const params = new URLSearchParams(searchParams);
    params.delete("certId");
    setSearchParams(params);
    return () => window.clearTimeout(to);
  }, [
    certIdParam,
    _allCertsForFocus,
    viewportSize.w,
    viewportSize.h,
    allowedMaxCellSize,
  ]);

  // Draw large "Area" grid overlay when zoomed far out
  useEffect(() => {
    // 05.01.2026 map had no area overlay
    if (useClassicMap) return;
    const canvas = areasCanvasRef.current;
    if (!canvas) return;
    const dpr = window.devicePixelRatio || 1;
    const w = viewW * cellSize;
    const h = viewH * cellSize;
    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
    // Sharpen all canvas rendering
    if (ctx) (ctx as any).imageSmoothingEnabled = false;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, w, h);

    // Compute visible area tiles
    const startCol = Math.floor(origin.x / AREA_W);
    const endCol = Math.floor((origin.x + viewW - 1) / AREA_W);
    const startRow = Math.floor(origin.y / AREA_H);
    const endRow = Math.floor((origin.y + viewH - 1) / AREA_H);

    ctx.strokeStyle = "rgba(200,200,200,0.6)";
    ctx.lineWidth = Math.max(1, cellSize * 0.08);
    ctx.fillStyle = "rgba(220,220,220,0.22)";

    for (let r = startRow; r <= endRow; r++) {
      for (let c = startCol; c <= endCol; c++) {
        const idx = r * AREAS_PER_ROW + c + 1; // 1-based
        if (idx < 1 || idx > AREAS_TOTAL) continue;
        const pxX = (c * AREA_W - origin.x) * cellSize;
        const pxY = (r * AREA_H - origin.y) * cellSize;
        const pxW = AREA_W * cellSize;
        const pxH = AREA_H * cellSize;
        // semi-transparent fill to visually group
        ctx.fillRect(pxX, pxY, pxW, pxH);
        ctx.strokeRect(pxX + 0.5, pxY + 0.5, pxW - 1, pxH - 1);
        // big centered label
        const label = `Area ${idx}`;
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = `${Math.max(24, Math.floor(cellSize * 3))}px system-ui, -apple-system, Segoe UI, Roboto`;
        const tw = ctx.measureText(label).width;
        const th = Math.max(24, Math.floor(cellSize * 3));
        ctx.fillText(label, pxX + (pxW - tw) / 2, pxY + (pxH + th / 2) / 2);
        ctx.fillStyle = "rgba(220,220,220,0.22)"; // restore fill for next block
      }
    }
  }, [origin.x, origin.y, viewW, viewH, cellSize]);

  // Houses removed: no drag-to-build or place mutations

  const openHouseSheet = (cell: any) => {
    console.log("Houses disabled", cell);
  };

  // setConfirmBuild removed – no houses;
  const [confirmBuy, setConfirmBuy] = useState<{
    m2: number;
    totalEUR: string;
  } | null>(null);
  const [mainBuyInfo, setMainBuyInfo] = useState<{
    m2: number;
    totalEUR: string;
  } | null>(null);

  // Houses removed

  const openConfirm = (
    x: number,
    y: number,
    type: "BASIC" | "VILLA" | "MANSION",
  ) => {
    console.log("Houses disabled", x, y, type);
  };

  // Houses removed

  // houses: removed getClientXY helper

  // Houses removed

  // Houses removed

  // Houses removed

  // Houses removed

  // Houses removed

  // Houses removed: no global drag handlers

  // Colors util for canvas (reserved for future theme-aware roads)
  // const hslVar = (name: string) => {
  //   const v = getComputedStyle(document.documentElement)
  //     .getPropertyValue(name)
  //     .trim();
  //   return `hsl(${v || "0 0% 0%"})`;
  // };

  // Load exact background image once when provided by server
  const [bgImg, setBgImg] = useState<HTMLImageElement | null>(null);
  useEffect(() => {
    // Classic map: do not block rendering on a background image.
    if (useClassicMap) {
      setBgImg(null);
      return;
    }

    if (market?.mapBackgroundUrl) {
      const img = new Image();
      img.decoding = "async";
      img.src = market.mapBackgroundUrl;
      img.onload = () => setBgImg(img);
      img.onerror = () => setBgImg(null);
    } else {
      setBgImg(null);
    }
  }, [market?.mapBackgroundUrl, useClassicMap]);

  const isViewportReady = viewportSize.w > 0 && viewportSize.h > 0;
  const isBgReady = useClassicMap ? true : !market?.mapBackgroundUrl || !!bgImg;
  const isMapReady = isMapFetched && !isMapInitialLoading;
  // Mark first stable render once everything is truly ready. After that, we never
  // block the map again just because the fetch-anchor is throttled.
  useEffect(() => {
    if (
      !didFirstStableMap &&
      isViewportReady &&
      isBgReady &&
      isMapReady &&
      isFetchAnchorSynced
    ) {
      setDidFirstStableMap(true);
    }
  }, [
    didFirstStableMap,
    isViewportReady,
    isBgReady,
    isMapReady,
    isFetchAnchorSynced,
  ]);

  const needsInitialAnchorSync = !didFirstStableMap && !isFetchAnchorSynced;
  void needsInitialAnchorSync;

  const showMapLoadingOverlay =
    !isMapError &&
    (!isViewportReady || !isMapReady || (!isBgReady && !useClassicMap));
  const showMapErrorOverlay = isMapError;

  // Canvas draw parameters (kept fully in sync with the current viewport).
  // This avoids the “color layer drifting/overlapping” effect while panning.
  const drawParams = React.useMemo(
    () => ({ x: origin.x, y: origin.y, cellSize, viewW, viewH }),
    [origin.x, origin.y, cellSize, viewW, viewH],
  );

  // Draw roads, blocks (8x4 tiles), trees and landmarks (static layer) whenever view changes
  useEffect(() => {
    // While the user is actively panning/zooming we avoid heavy redraw work.
    // We redraw once the interaction ends.
    if (isInteracting) return;

    const canvas = roadsCanvasRef.current;
    if (!canvas) return;

    const dpr = window.devicePixelRatio || 1;
    const w = drawParams.viewW * drawParams.cellSize;
    const h = drawParams.viewH * drawParams.cellSize;
    // Skip expensive details when far zoomed out to keep panning/zoom silky-smooth
    const showFineDetails = drawParams.cellSize >= 12;

    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
    // Sharpen all canvas rendering
    if (ctx) (ctx as any).imageSmoothingEnabled = false;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, w, h);

    // If an exact background image is configured, draw it smaller and centered (as a visual backdrop),
    // then continue with UI overlays so m² squares remain clearly tappable.
    if (bgImg && market?.mapBackgroundUrl) {
      const iw = bgImg.naturalWidth || 1;
      const ih = bgImg.naturalHeight || 1;
      // Make photo much smaller than the grid viewport (e.g., 55% of the available size)
      const maxW = w * 0.55;
      const maxH = h * 0.55;
      const scale = Math.min(maxW / iw, maxH / ih);
      const dw = Math.max(1, Math.floor(iw * scale));
      const dh = Math.max(1, Math.floor(ih * scale));
      const dx = Math.floor((w - dw) / 2);
      const dy = Math.floor((h - dh) / 2);
      try {
        ctx.drawImage(bgImg, 0, 0, iw, ih, dx, dy, dw, dh);
      } catch {}
      // Do not return; continue to draw the m² tile grid so selection remains clear.
    }

    // Classic map renderer (as it was before): ocean + island + roads + crisp grid
    // Keep it simple and fast, so zoom/pan feels like the older version.
    if (useClassicMap) {
      // Important: In classic map mode, the “tiles” are rendered by the DOM grid (so they always
      // move/zoom perfectly with interactions). The canvas only paints the background.
      const rootStyles = getComputedStyle(document.documentElement);
      const mapBgVar = rootStyles.getPropertyValue("--map-bg").trim();
      const mapBg = mapBgVar ? `hsl(${mapBgVar})` : "hsl(120 30% 88%)";
      ctx.fillStyle = mapBg;
      ctx.fillRect(0, 0, w, h);
      return;
    }

    // New island: draw sea background and island landmass, then skip legacy roads
    // Simplified rendering when zoomed far out to prevent heavy per-tile drawing

    // Unified grid and grout colors so the map base looks consistent
    const rootStyles = getComputedStyle(document.documentElement);
    const borderVar = rootStyles.getPropertyValue("--border").trim();
    const neutralStroke = borderVar
      ? `hsl(${borderVar} / 0.5)`
      : "rgba(120,120,120,0.5)";
    const neutralGrout = borderVar ? `hsl(${borderVar})` : "rgb(100,100,100)";

    if (drawParams.cellSize < 12) {
      // Plain background
      ctx.fillStyle = "hsl(118 34% 44%)";
      ctx.fillRect(0, 0, w, h);

      // Draw background image (if any) already rendered above

      // Lightweight grid lines only
      ctx.strokeStyle = neutralStroke;
      const cs = drawParams.cellSize;
      ctx.lineWidth = Math.max(1, cs * 0.06);
      ctx.beginPath();
      for (let c = 0; c <= drawParams.viewW; c++) {
        const x = Math.floor(c * cs) + 0.5;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
      }
      for (let r = 0; r <= drawParams.viewH; r++) {
        const y = Math.floor(r * cs) + 0.5;
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
      }
      ctx.stroke();

      // Keep canvas light at far zoom levels
      return;
    }
    // Sea base (clear canvas)
    // Photo-style grid: grout-first background + rounded green tiles per cell (no noise, no bushes)
    const grout = Math.max(1, Math.floor(cellSize * 0.035));
    // Golden grout background
    ctx.fillStyle = neutralGrout;
    ctx.fillRect(0, 0, w, h);

    for (let row = 0; row < viewH; row++) {
      for (let col = 0; col < viewW; col++) {
        const wx = origin.x + col;
        const wy = origin.y + row;
        // Only draw land tiles inside the island silhouette
        if (!pointInPolygon(wx, wy)) continue;

        const px = col * cellSize;
        const py = row * cellSize;

        // Tile rect (inset by grout) with rounded corners
        const gx = px + grout / 2;
        const gy = py + grout / 2;
        const tw = Math.max(0, cellSize - grout);
        const th = Math.max(0, cellSize - grout);
        const r = Math.max(2, Math.min(tw, th) * 0.12);

        // Uniform land tiles: no more water areas
        const grad = ctx.createLinearGradient(gx, gy, gx + tw, gy + th);
        grad.addColorStop(0, "hsl(122 40% 50%)");
        grad.addColorStop(1, "hsl(116 34% 42%)");
        ctx.fillStyle = grad;
        roundRect(ctx, gx, gy, tw, th, r);
        ctx.fill();

        // Inner bevel for the tile (soft highlight and shadow inside the edge)
        if (cellSize >= 8) {
          ctx.strokeStyle = "rgba(255,255,255,0.05)";
          ctx.lineWidth = Math.max(1, cellSize * 0.02);
          roundRect(
            ctx,
            gx + 0.8,
            gy + 0.8,
            tw - 1.6,
            th - 1.6,
            Math.max(1, r - 0.8),
          );
          ctx.stroke();

          ctx.strokeStyle = "rgba(0,0,0,0.05)";
          ctx.lineWidth = Math.max(1, cellSize * 0.02);
          roundRect(
            ctx,
            gx + 1.6,
            gy + 1.6,
            tw - 3.2,
            th - 3.2,
            Math.max(1, r - 1.6),
          );
          ctx.stroke();

          // Centered radial highlight + soft edge vignette (matches reference photo)
          ctx.save();
          ctx.beginPath();
          roundRect(ctx, gx, gy, tw, th, r);
          ctx.clip();
          // Central highlight (very subtle)
          const cx = gx + tw / 2;
          const cy = gy + th / 2;
          const maxR = Math.max(tw, th) * 0.6;
          let radial = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
          radial.addColorStop(0, "rgba(255,255,255,0.10)");
          radial.addColorStop(0.35, "rgba(255,255,255,0.06)");
          radial.addColorStop(0.6, "rgba(255,255,255,0.02)");
          radial.addColorStop(1, "rgba(255,255,255,0.00)");
          ctx.fillStyle = radial;
          ctx.fillRect(gx, gy, tw, th);
          // Edge vignette (adds gentle depth)
          radial = ctx.createRadialGradient(
            cx,
            cy,
            Math.max(tw, th) * 0.55,
            cx,
            cy,
            Math.max(tw, th) * 0.9,
          );
          radial.addColorStop(0, "rgba(0,0,0,0.00)");
          radial.addColorStop(1, "rgba(0,0,0,0.08)");
          ctx.fillStyle = radial;
          ctx.fillRect(gx, gy, tw, th);
          ctx.restore();
        }
      }
    }
    // Subtle felt noise overlay to match matte texture
    try {
      const noiseCanvas = document.createElement("canvas");
      noiseCanvas.width = 32;
      noiseCanvas.height = 32;
      const nctx = noiseCanvas.getContext("2d");
      if (nctx) {
        nctx.clearRect(0, 0, 32, 32);
        for (let i = 0; i < 80; i++) {
          nctx.fillStyle = "rgba(0,0,0,0.03)";
          nctx.fillRect(
            Math.floor(Math.random() * 32),
            Math.floor(Math.random() * 32),
            1,
            1,
          );
          nctx.fillStyle = "rgba(255,255,255,0.02)";
          nctx.fillRect(
            Math.floor(Math.random() * 32),
            Math.floor(Math.random() * 32),
            1,
            1,
          );
        }
        const pattern = ctx.createPattern(noiseCanvas, "repeat");
        if (pattern) {
          ctx.globalAlpha = 1;
          ctx.fillStyle = pattern;
          ctx.fillRect(0, 0, w, h);
        }
      }
    } catch {}
    // Grout-based grid already rendered above; stop here to preserve the exact photo look
    // Sprinkle small, natural tree clusters sparsely across tiles (stable per world cell)
    (function sprinkleTrees() {
      const rand01 = (ax: number, ay: number) => {
        let t =
          Math.imul(ax, 374761393) ^
          Math.imul(ay, 668265263) ^
          Math.imul(origin.x | 0, 1274126177) ^
          Math.imul(origin.y | 0, 461845907);
        t = (t ^ (t >>> 15)) >>> 0;
        return (t >>> 0) / 0xffffffff;
      };
      const density = 0; // trees disabled: no tree clusters will be drawn
      for (let row = 0; row < viewH; row++) {
        for (let col = 0; col < viewW; col++) {
          const wx = origin.x + col;
          const wy = origin.y + row;
          if (rand01(wx, wy) < density) {
            const px = col * cellSize;
            const py = row * cellSize;
            const cx = px + cellSize * 0.5;
            const cy = py + cellSize * 0.52;
            const r = Math.max(2, cellSize * 0.32);
            // shadow
            ctx.fillStyle = "rgba(0,0,0,0.20)";
            ctx.beginPath();
            ctx.ellipse(
              cx + 1,
              cy + Math.max(1, cellSize * 0.1),
              r * 0.9,
              r * 0.55,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();
            // canopy gradient
            const g = ctx.createRadialGradient(
              cx - r * 0.1,
              cy - r * 0.25,
              r * 0.2,
              cx,
              cy - r * 0.25,
              r,
            );
            g.addColorStop(0, "hsl(120 36% 36%)");
            g.addColorStop(1, "hsl(120 28% 28%)");
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(cx, cy - r * 0.15, r, 0, Math.PI * 2);
            ctx.fill();
            // a couple of leaves blobs for realism
            const g2 = ctx.createRadialGradient(
              cx + r * 0.25,
              cy - r * 0.2,
              r * 0.1,
              cx + r * 0.25,
              cy - r * 0.2,
              r * 0.6,
            );
            g2.addColorStop(0, "hsl(120 34% 34%)");
            g2.addColorStop(1, "hsl(120 26% 26%)");
            ctx.fillStyle = g2;
            ctx.beginPath();
            ctx.arc(cx + r * 0.22, cy - r * 0.12, r * 0.65, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
    })();
    return;
    // Gold grid with slight highlight
    ctx.lineCap = "round";
    const primaryGold = "hsl(46 88% 54%)";
    const highlightGold = "hsl(46 95% 68%)";
    const w1 = Math.max(0.8, cellSize * 0.04);
    const w2 = Math.max(0.5, cellSize * 0.015);
    // primary pass
    ctx.strokeStyle = primaryGold;
    ctx.lineWidth = w1;
    ctx.beginPath();
    for (let c = 0; c <= viewW; c++) {
      const x = Math.floor(c * cellSize) + 0.5;
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
    }
    for (let r = 0; r <= viewH; r++) {
      const y = Math.floor(r * cellSize) + 0.5;
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
    }
    ctx.stroke();
    // highlight pass
    ctx.strokeStyle = highlightGold;
    ctx.lineWidth = w2;
    ctx.beginPath();
    for (let c = 0; c <= viewW; c++) {
      const x = Math.floor(c * cellSize) + 0.5;
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
    }
    for (let r = 0; r <= viewH; r++) {
      const y = Math.floor(r * cellSize) + 0.5;
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
    }
    ctx.stroke();

    // Bush clusters to match photo feel
    const drawBush = (cx: number, cy: number, r: number) => {
      // soft ground shadow
      const shGrad = ctx.createRadialGradient(
        cx + r * 0.1,
        cy + r * 0.25,
        r * 0.2,
        cx + r * 0.1,
        cy + r * 0.25,
        r,
      );
      shGrad.addColorStop(0, "rgba(0,0,0,0.22)");
      shGrad.addColorStop(1, "rgba(0,0,0,0.0)");
      ctx.fillStyle = shGrad;
      ctx.beginPath();
      ctx.ellipse(
        cx + r * 0.1,
        cy + r * 0.25,
        r * 0.9,
        r * 0.5,
        0,
        0,
        Math.PI * 2,
      );
      ctx.fill();

      const leafColors = [
        "hsl(120 36% 32%)",
        "hsl(120 32% 28%)",
        "hsl(120 28% 24%)",
      ];
      // base canopy blobs
      for (let ring = 0; ring < 3; ring++) {
        const blobs = 6 + ring * 4;
        for (let i = 0; i < blobs; i++) {
          const ang = (i / blobs) * Math.PI * 2;
          const rr = r * (0.35 + ring * 0.12);
          const bx = cx + Math.cos(ang) * r * 0.5 * (0.8 + ring * 0.12);
          const by =
            cy + Math.sin(ang) * r * 0.38 * (0.8 + ring * 0.08) - r * 0.15;
          const grad = ctx.createRadialGradient(
            bx - r * 0.05,
            by - r * 0.08,
            rr * 0.2,
            bx,
            by,
            rr,
          );
          grad.addColorStop(0, leafColors[(ring + i) % leafColors.length]!);
          grad.addColorStop(1, "hsl(120 30% 28%)");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(bx, by, rr, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // top highlight
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.ellipse(
        cx - r * 0.2,
        cy - r * 0.45,
        r * 0.6,
        r * 0.35,
        -0.2,
        0,
        Math.PI * 2,
      );
      ctx.fill();
    };
    // World→pixel helpers (keep bushes fixed in world)
    // removed: world-to-pixel helper not used
    // removed: world-to-pixel helper not used
    const clustersPx = [
      { x: w * 0.24, y: h * 0.2, r: Math.max(16, cellSize * 1.9) },
      { x: w * 0.8, y: h * 0.78, r: Math.max(26, cellSize * 2.8) },
    ];
    for (const c of clustersPx) {
      drawBush(c.x, c.y, c.r);
    }

    // Done with photo-style background
    return;

    // Lightweight deterministic noise for pixelated coastline variation
    const noise = (x: number, y: number) => {
      let t = Math.imul(x, 374761393) + Math.imul(y, 668265263);
      t = (t ^ (t << 13)) >>> 0;
      return (t / 0xffffffff) * 2 - 1; // [-1, 1]
    };

    // Helper to draw a shrub cluster in the style of the reference image (layered green blobs)
    const drawShrubCluster = (x: number, y: number, s: number) => {
      const r1 = s * 0.42,
        r2 = s * 0.32,
        r3 = s * 0.26;
      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.beginPath();
      ctx.ellipse(
        x + s * 0.05,
        y + s * 0.08,
        r1 * 0.9,
        r1 * 0.55,
        0,
        0,
        Math.PI * 2,
      );
      ctx.fill();
      // base blob
      ctx.fillStyle = "hsl(100 52% 54%)";
      ctx.beginPath();
      ctx.arc(x, y, r1, 0, Math.PI * 2);
      ctx.fill();
      // mid blob
      ctx.fillStyle = "hsl(100 58% 60%)";
      ctx.beginPath();
      ctx.arc(x - s * 0.18, y - s * 0.12, r2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + s * 0.18, y - s * 0.06, r2 * 0.92, 0, Math.PI * 2);
      ctx.fill();
      // highlight spots
      ctx.fillStyle = "hsl(100 62% 70%)";
      ctx.beginPath();
      ctx.arc(x - s * 0.06, y - s * 0.12, r3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + s * 0.14, y + s * 0.02, r3 * 0.85, 0, Math.PI * 2);
      ctx.fill();
    };

    // Draw per-tile background to mimic the pixel-art coast from the reference
    for (let row = 0; row < viewH; row++) {
      for (let col = 0; col < viewW; col++) {
        const wx = origin.x + col;
        const wy = origin.y + row;

        // Classify tile by distance to polygon coastline instead of rectangle edges
        const inside = pointInPolygon(wx, wy);
        const dist = distanceToCoast(wx, wy); // 0 at coast, grows inward/outward

        // Subtle jitter to avoid perfectly straight pixel lines
        const n = noise(Math.floor(wx * 3), Math.floor(wy * 3));
        const jitter = (Math.round(n * 2) as number) * 0.25; // ±0.5 cell max

        const beachWidth =
          3 + Math.min(2, Math.floor(Math.abs(noise(wx * 2, wy * 2)) * 3)); // 3..5
        let fill: string;
        if (!inside) {
          // Water outside polygon; shallow band right outside coast
          fill = "hsl(120 44% 60%)";
        } else if (dist + jitter < beachWidth) {
          fill = "hsl(46 90% 78%)"; // sand/beach (buildable)
        } else {
          // Inland grass (buildable)
          const alt = (wx + wy) & 3;
          fill =
            alt === 0
              ? "hsl(120 44% 60%)"
              : alt === 1
                ? "hsl(120 44% 56%)"
                : alt === 2
                  ? "hsl(120 44% 64%)"
                  : "hsl(120 44% 58%)";
        }

        ctx.fillStyle = fill;
        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);

        // Tiny details to evoke trees/rocks in grass and pebbles on sand
        if (inside && dist >= 3 && showFineDetails) {
          // fine grass speckles to match reference texture
          ctx.fillStyle = "rgba(0,0,0,0.08)";
          const px0 = col * cellSize;
          const py0 = row * cellSize;
          const s = ((wx * 37 + wy * 17) >>> 0) % 3;
          if (s === 0)
            ctx.fillRect(
              Math.floor(px0 + cellSize * 0.28) + 0.5,
              Math.floor(py0 + cellSize * 0.32) + 0.5,
              1,
              1,
            );
          if (s === 1)
            ctx.fillRect(
              Math.floor(px0 + cellSize * 0.62) + 0.5,
              Math.floor(py0 + cellSize * 0.58) + 0.5,
              1,
              1,
            );
          if (s === 2)
            ctx.fillRect(
              Math.floor(px0 + cellSize * 0.44) + 0.5,
              Math.floor(py0 + cellSize * 0.18) + 0.5,
              1,
              1,
            );
          const h = Math.abs(noise(wx * 5, wy * 7));
          if (false && h > 0.93) {
            ctx.fillStyle = "hsl(120 35% 28%)"; // tree dot
            const cx = col * cellSize + Math.floor(cellSize * 0.5);
            const cy = row * cellSize + Math.floor(cellSize * 0.5);
            ctx.fillRect(cx - 1, cy - 1, 2, 2);
          }
          // occasional small rocks inland
          if (h > 0.975) {
            ctx.fillStyle = "hsl(210 8% 30%)";
            ctx.fillRect(
              px0 + Math.floor(cellSize * 0.65),
              py0 + Math.floor(cellSize * 0.3),
              1,
              1,
            );
          }
        } else if (inside && dist >= 1 && dist < 3 && showFineDetails) {
          const h2 = Math.abs(noise(wx * 11, wy * 13));
          if (h2 > 0.965) {
            ctx.fillStyle = "hsl(30 20% 50%)"; // pebble/rock on beach
            const px = col * cellSize + Math.floor(cellSize * 0.35);
            const py = row * cellSize + Math.floor(cellSize * 0.6);
            ctx.fillRect(px, py, 1, 1);
          }
          // a few palms along the beach line
          if (false && h2 > 0.992) {
            const px = col * cellSize + Math.floor(cellSize * 0.5);
            const py = row * cellSize + Math.floor(cellSize * 0.5);
            // trunk
            ctx.fillStyle = "hsl(25 50% 38%)";
            ctx.fillRect(
              px - 1,
              py - Math.max(3, Math.floor(cellSize * 0.4)),
              2,
              Math.max(3, Math.floor(cellSize * 0.4)),
            );
            // leaves (simple circles)
            ctx.fillStyle = "hsl(140 50% 36%)";
            const r = Math.max(2, Math.floor(cellSize * 0.22));
            ctx.beginPath();
            ctx.arc(px - r, py - r, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + r, py - r * 0.9, r, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (!inside && dist > 2 && dist < 6 && showFineDetails) {
          // Decorative shrubs on extra non-buildable m² just outside the island
          const chance = Math.abs(noise(wx * 13, wy * 29));
          if (false && chance > 0.992) {
            const px = col * cellSize + Math.floor(cellSize * 0.5);
            const py = row * cellSize + Math.floor(cellSize * 0.5);
            drawShrubCluster(px, py, Math.max(10, cellSize * 0.9));
          }
        }
      }
    }

    // Minimal interior: only green fields (no paths/ponds/mountains/palms)
    // Wir lassen hier bewusst nur Gras-Sprenkel (oben bereits gezeichnet) – keine weiteren Patches.
    // Dadurch wirkt das Inland wie auf dem Foto „nur Felder“.
    // (Absichtlich leer gelassen)

    // A thin river flowing south-east from the mountain to the coast (visual only)
    if (false) {
      const startX = ISLAND_X0 + Math.floor(ISLAND_W * 0.69);
      const startY = ISLAND_Y0 + Math.floor(ISLAND_H * 0.32);
      const endX = ISLAND_X0 + Math.floor(ISLAND_W * 0.76);
      const endY = ISLAND_Y0 + Math.floor(ISLAND_H * 0.52);
      const steps = 80;
      ctx.fillStyle = "hsl(204 80% 62%)";
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const wx = Math.floor(
          startX + (endX - startX) * t + Math.sin(t * Math.PI * 2) * 2,
        );
        const wy = Math.floor(
          startY + (endY - startY) * t + Math.cos(t * Math.PI) * 1.5,
        );
        const px = (wx - origin.x) * cellSize;
        const py = (wy - origin.y) * cellSize;
        if (
          px + cellSize < 0 ||
          py + cellSize < 0 ||
          px > viewW * cellSize ||
          py > viewH * cellSize
        )
          continue;
        ctx.fillRect(
          Math.floor(px),
          Math.floor(py),
          Math.max(2, Math.floor(cellSize * 0.6)),
          Math.max(2, Math.floor(cellSize * 0.6)),
        );
      }
    }
    // Tiny villages disabled (removed cities/villages)
    /*
    for (let row = 0; row < viewH; row++) {
      for (let col = 0; col < viewW; col++) {
        const wx = origin.x + col;
        const wy = origin.y + row;
        if (inlandEffective(wx, wy) < 8) continue; // deeper inland
        // One village per 24x24 block probabilistically
        const vx = Math.floor(wx / 24);
        const vy = Math.floor(wy / 24);
        const rv = Math.abs(noise(vx * 547, vy * 811));
        if (rv > 0.985) {
          // Anchor the cluster inside this block near current cell only once
          if (wx % 24 === 12 && wy % 24 === 12) {
            const baseX = (col - 1) * cellSize;
            const baseY = (row - 1) * cellSize;
            const hut = (bx: number, by: number, s: number) => {
              // walls
              ctx.fillStyle = "hsl(25 38% 46%)";
              ctx.fillRect(
                Math.floor(bx),
                Math.floor(by + s * 0.4),
                Math.floor(s),
                Math.floor(s * 0.6),
              );
              // roof
              ctx.fillStyle = "hsl(10 55% 40%)";
              ctx.fillRect(
                Math.floor(bx - s * 0.05),
                Math.floor(by + s * 0.15),
                Math.floor(s * 1.1),
                Math.floor(s * 0.3),
              );
            };
            const s = Math.max(6, cellSize * 0.8);
            hut(baseX + cellSize * 0.5, baseY + cellSize * 0.2, s);
            hut(baseX + cellSize * 1.4, baseY + cellSize * 0.8, s * 0.9);
            hut(baseX + cellSize * 0.2, baseY + cellSize * 1.2, s * 0.85);
            // a couple of darker dots as trees/rocks near the village
            ctx.fillStyle = "hsl(120 35% 28%)";
            ctx.fillRect(baseX + cellSize * 1.9, baseY + cellSize * 1.6, 2, 2);
            ctx.fillRect(baseX + cellSize * 1.1, baseY + cellSize * 0.3, 2, 2);
          }
        }
      }
    }

    */
    // (No paths/bands — fields only)

    // (Keine Teiche – auf Wunsch „nur Felder“ ohne Extras)

    // No extra trees/animals/rocks — pure field pattern.
    // (Absichtlich leer gelassen)

    // Keep legacy systems disabled: do not draw old roads/landmarks
    return;

    // Visual palette (top‑down asphalt + sidewalks)
    const ROAD_SPACING = 8; // every N cells a road with full intersections
    const roadColor = "hsl(220 7% 28%)"; // asphalt (slightly lighter, closer to photo)
    const laneColor = "hsl(0 0% 96%)"; // bright lane dashes like the photo
    const curbColor = "hsl(220 10% 42%)"; // curb edge slightly lighter
    const sidewalkColor = "hsl(46 100% 92%)"; // warmer, brighter sidewalks like photo
    const blockStroke = "hsl(120 34% 38%)"; // darker edge for green areas
    const blockFill = "hsl(120 44% 72%)"; // rich green for city blocks

    const roadWidth = Math.max(2, Math.floor(cellSize * 1.2));
    const laneWidth = Math.max(1, Math.floor(cellSize * 0.1));
    const sidewalkWidth = Math.max(2, Math.floor(cellSize * 0.5));

    // Roundabout drawer (at selected intersections)
    const drawRoundabout = (cx: number, cy: number) => {
      const rOuter = Math.max(6, roadWidth * 0.7);
      const rInner = Math.max(3, roadWidth * 0.35);
      // asphalt circle
      ctx.fillStyle = "hsl(220 8% 26%)";
      ctx.beginPath();
      ctx.arc(cx, cy, rOuter, 0, Math.PI * 2);
      ctx.fill();
      // dashed lane ring
      ctx.strokeStyle = "hsl(0 0% 96%)";
      ctx.lineWidth = Math.max(1, cellSize * 0.08);
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.arc(cx, cy, (rOuter + rInner) / 2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      // center island
      const grad = ctx.createRadialGradient(
        cx,
        cy,
        rInner * 0.2,
        cx,
        cy,
        rInner,
      );
      grad.addColorStop(0, "hsl(120 48% 58%)");
      grad.addColorStop(1, "hsl(120 38% 42%)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, rInner, 0, Math.PI * 2);
      ctx.fill();
      // traffic lights at approaches
      const light = (lx: number, ly: number, color: string) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(lx, ly, Math.max(1.5, cellSize * 0.08), 0, Math.PI * 2);
        ctx.fill();
      };
      light(cx - rOuter - 4, cy - 2, "hsl(0 80% 55%)"); // red
      light(cx + rOuter + 4, cy + 2, "hsl(120 70% 50%)"); // green
      light(cx, cy - rOuter - 4, "hsl(45 90% 55%)"); // amber
      light(cx, cy + rOuter + 4, "hsl(0 80% 55%)");
    };

    // Helper: tiled sidewalks (helle Steinplatten)
    const drawSidewalkTiles = (x: number, y: number, w: number, h: number) => {
      const tile = Math.max(2, Math.floor(cellSize * 0.18));
      for (let yy = 0; yy < h; yy += tile) {
        for (let xx = 0; xx < w; xx += tile) {
          const alt = (xx / tile + yy / tile) % 2 === 0;
          ctx.fillStyle = alt ? "hsl(46 100% 90%)" : "hsl(46 92% 86%)";
          ctx.fillRect(
            x + xx,
            y + yy,
            Math.min(tile - 1, w - xx),
            Math.min(tile - 1, h - yy),
          );
        }
      }
      // feine Kante
      ctx.fillStyle = "hsl(46 60% 70%)";
      ctx.fillRect(x, y, w, 1);
      ctx.fillRect(x, y + h - 1, w, 1);
    };

    // Landmark helpers (draw if in view)
    const worldToPx = (wx: number, wy: number) => ({
      x: (wx - origin.x) * cellSize,
      y: (wy - origin.y) * cellSize,
    });

    const drawPond = (rect: { x: number; y: number; w: number; h: number }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      const r = Math.min(pxW, pxH) * 0.25;
      const margin = Math.max(cellSize * 0.8, 10);
      const parkX = x - margin;
      const parkY = y - margin;
      const parkW = pxW + margin * 2;
      const parkH = pxH + margin * 2;

      ctx.save();
      // Park area (rich green)
      ctx.fillStyle = "hsl(120 40% 60%)";
      roundRect(ctx, parkX, parkY, parkW, parkH, r * 1.15);
      ctx.fill();
      // umlaufender Gehweg als Ring
      const ringW = Math.max(4, cellSize * 0.5);
      ctx.fillStyle = "hsl(46 85% 80%)";
      roundRect(
        ctx,
        parkX + ringW / 2,
        parkY + ringW / 2,
        parkW - ringW,
        parkH - ringW,
        r * 1.05,
      );
      ctx.fill();
      // Make the park interior green again to keep a ring
      ctx.fillStyle = "hsl(120 44% 72%)";
      roundRect(
        ctx,
        parkX + ringW,
        parkY + ringW,
        parkW - ringW * 2,
        parkH - ringW * 2,
        r,
      );
      ctx.fill();

      // Water area
      ctx.fillStyle = "hsl(206 85% 58%)";
      roundRect(ctx, x, y, pxW, pxH, r);
      ctx.fill();
      // sanfte Wellen
      ctx.strokeStyle = "hsl(206 85% 75%)";
      ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.06));
      ctx.setLineDash([8, 10]);
      ctx.strokeRect(x + r, y + r, pxW - 2 * r, pxH - 2 * r);
      ctx.setLineDash([]);

      // kleine Boote
      const drawBoat = (
        bx: number,
        by: number,
        bw: number,
        bh: number,
        hue: number,
      ) => {
        ctx.save();
        // Rumpf
        ctx.fillStyle = `hsl(${hue} 70% 50%)`;
        roundRect(ctx, bx, by, bw, bh, Math.min(bw, bh) * 0.4);
        ctx.fill();
        // Cabin / deck
        ctx.fillStyle = "hsl(0 0% 95%)";
        roundRect(
          ctx,
          bx + bw * 0.25,
          by + bh * 0.2,
          bw * 0.5,
          bh * 0.6,
          Math.min(bw, bh) * 0.2,
        );
        ctx.fill();
        // kleiner Schatten
        ctx.fillStyle = "rgba(0,0,0,0.15)";
        roundRect(ctx, bx + 1, by + bh, bw, 2, 1);
        ctx.fill();
        ctx.restore();
      };
      const boatW = Math.max(6, cellSize * 0.8);
      const boatH = Math.max(3, cellSize * 0.4);
      drawBoat(x + pxW * 0.25, y + pxH * 0.55, boatW, boatH, 15);
      drawBoat(x + pxW * 0.62, y + pxH * 0.35, boatW, boatH, 210);

      ctx.restore();
    };

    const drawAirport = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      ctx.save();
      // apron background
      ctx.fillStyle = "hsl(220 10% 25%)";
      roundRect(ctx, x, y, pxW, pxH, Math.min(pxW, pxH) * 0.06);
      ctx.fill();
      // runway stripe
      ctx.fillStyle = "hsl(0 0% 92%)";
      const rwY = y + pxH * 0.5 - Math.max(2, cellSize * 0.6);
      ctx.fillRect(x + pxW * 0.05, rwY, pxW * 0.9, Math.max(2, cellSize * 1.2));
      // center dashes
      ctx.fillStyle = "hsl(0 0% 98%)";
      const dashW = Math.max(6, cellSize * 0.8);
      const gapW = dashW * 0.8;
      let cxPos = x + pxW * 0.08;
      const cyPos = y + pxH * 0.5 - Math.max(1, cellSize * 0.15);
      while (cxPos < x + pxW * 0.92) {
        ctx.fillRect(cxPos, cyPos, dashW, Math.max(2, cellSize * 0.3));
        cxPos += dashW + gapW;
      }

      // terminal building with gates
      const termW = Math.max(pxW * 0.22, 12);
      const termH = Math.max(pxH * 0.55, pxH * 0.4);
      const termX = x + pxW * 0.05;
      const termY = y + pxH * 0.2;
      const gradTerm = ctx.createLinearGradient(
        termX,
        termY + termH,
        termX,
        termY,
      );
      gradTerm.addColorStop(0, "hsl(220 10% 32%)");
      gradTerm.addColorStop(1, "hsl(220 10% 44%)");
      ctx.fillStyle = gradTerm;
      roundRect(ctx, termX, termY, termW, termH, Math.min(8, termH * 0.08));
      ctx.fill();
      // gates
      ctx.fillStyle = "hsl(0 0% 92%)";
      for (let i = 0; i < 4; i++) {
        const gx = termX + termW + 2;
        const gy = termY + (i + 1) * (termH / 5);
        ctx.fillRect(gx, gy, Math.max(4, pxW * 0.04), Math.max(2, pxH * 0.06));
      }
      // taxiway line
      ctx.strokeStyle = "hsl(50 100% 64%)";
      ctx.lineWidth = Math.max(1, cellSize * 0.12);
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(x + pxW * 0.2, y + pxH * 0.5);
      ctx.lineTo(x + pxW * 0.8, y + pxH * 0.5);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.restore();
    };

    const drawCity = (rect: { x: number; y: number; w: number; h: number }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      ctx.save();
      // city block background
      ctx.fillStyle = "hsl(220 10% 20%)";
      roundRect(ctx, x, y, pxW, pxH, Math.min(pxW, pxH) * 0.06);
      ctx.fill();
      // buildings grid
      const cols = Math.max(3, Math.floor(rect.w / 2));
      const rows = Math.max(2, Math.floor(rect.h / 2));
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const bx = x + (c + 0.1) * (pxW / cols);
          const by = y + (r + 0.1) * (pxH / rows);
          const bw = (pxW / cols) * 0.8;
          const bh = (pxH / rows) * (0.5 + 0.4 * ((c + r) % 2));
          // skyscraper with vertical gradient and roof
          const grad = ctx.createLinearGradient(bx, by + bh, bx, by);
          grad.addColorStop(0, "hsl(220 10% 22%)");
          grad.addColorStop(1, "hsl(220 12% 34%)");
          ctx.fillStyle = grad;
          ctx.fillRect(bx, by, bw, bh);
          ctx.fillStyle = "hsl(220 8% 18%)";
          ctx.fillRect(
            bx,
            by - Math.max(1, cellSize * 0.1),
            bw,
            Math.max(1, cellSize * 0.1),
          );
          // windows grid
          ctx.fillStyle = "hsl(50 95% 70%)";
          const winW = Math.max(1, cellSize * 0.14);
          const winH = Math.max(1, cellSize * 0.14);
          for (let wy = by + winW; wy < by + bh - winW; wy += winW * 1.8) {
            for (let wx = bx + winW; wx < bx + bw - winW; wx += winW * 1.6) {
              ctx.fillRect(wx, wy, winW, winH);
            }
          }
        }
      }
      ctx.restore();
    };

    const drawStadium = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      ctx.save();
      // Outer grass area
      ctx.fillStyle = "hsl(120 45% 60%)";
      roundRect(ctx, x, y, pxW, pxH, Math.min(pxW, pxH) * 0.12);
      ctx.fill();
      // Running track (oval)
      const trackMargin = Math.max(6, cellSize * 0.6);
      const outerR = Math.min(pxW, pxH) * 0.26;
      const trackW = Math.max(8, cellSize * 0.7);
      ctx.fillStyle = "hsl(10 78% 52%)"; // red track
      roundRect(
        ctx,
        x + trackMargin,
        y + trackMargin,
        pxW - trackMargin * 2,
        pxH - trackMargin * 2,
        outerR,
      );
      ctx.fill();
      // inner cut to create ring
      ctx.globalCompositeOperation = "destination-out";
      roundRect(
        ctx,
        x + trackMargin + trackW,
        y + trackMargin + trackW,
        pxW - (trackMargin + trackW) * 2,
        pxH - (trackMargin + trackW) * 2,
        outerR - trackW,
      );
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";
      // Field inside
      ctx.fillStyle = "hsl(120 40% 48%)";
      roundRect(
        ctx,
        x + trackMargin + trackW + 2,
        y + trackMargin + trackW + 2,
        pxW - (trackMargin + trackW + 2) * 2,
        pxH - (trackMargin + trackW + 2) * 2,
        Math.max(6, outerR - trackW - 6),
      );
      ctx.fill();
      // Center markings
      ctx.strokeStyle = "hsl(0 0% 98%)";
      ctx.lineWidth = Math.max(1, cellSize * 0.08);
      // mid line
      ctx.beginPath();
      ctx.moveTo(x + pxW / 2, y + trackMargin + trackW + 6);
      ctx.lineTo(x + pxW / 2, y + pxH - (trackMargin + trackW + 6));
      ctx.stroke();
      // circle
      const cx = x + pxW / 2;
      const cy = y + pxH / 2;
      ctx.beginPath();
      ctx.arc(cx, cy, Math.max(6, Math.min(pxW, pxH) * 0.08), 0, Math.PI * 2);
      ctx.stroke();
      // small benches outside
      ctx.fillStyle = "hsl(0 0% 92%)";
      const benchW = Math.max(6, cellSize * 0.8);
      const benchH = Math.max(2, cellSize * 0.25);
      for (let i = 0; i < 4; i++) {
        const bx = x + (i + 1) * (pxW / 5) - benchW / 2;
        const by = y - benchH - 2;
        ctx.fillRect(bx, by, benchW, benchH);
      }
      ctx.restore();
    };

    // Horizontal roads
    for (let row = 0; row < viewH; row++) {
      const worldY = origin.y + row;
      if (worldY % ROAD_SPACING !== 0) continue;
      const y = row * cellSize + cellSize / 2;

      // sidewalks (top & bottom)
      ctx.fillStyle = sidewalkColor;
      ctx.fillRect(0, y - roadWidth / 2 - sidewalkWidth, w, sidewalkWidth);
      ctx.fillRect(0, y + roadWidth / 2, w, sidewalkWidth);
      // tiled pattern on sidewalks
      drawSidewalkTiles(0, y - roadWidth / 2 - sidewalkWidth, w, sidewalkWidth);
      drawSidewalkTiles(0, y + roadWidth / 2, w, sidewalkWidth);

      // asphalt
      ctx.fillStyle = roadColor;
      ctx.fillRect(0, y - roadWidth / 2, w, roadWidth);
      // edge lines (solid)
      ctx.strokeStyle = "hsl(0 0% 96%)";
      ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.08));
      ctx.beginPath();
      ctx.moveTo(0, y - roadWidth / 2 + ctx.lineWidth);
      ctx.lineTo(w, y - roadWidth / 2 + ctx.lineWidth);
      ctx.moveTo(0, y + roadWidth / 2 - ctx.lineWidth);
      ctx.lineTo(w, y + roadWidth / 2 - ctx.lineWidth);
      ctx.stroke();

      // curbs
      ctx.fillStyle = curbColor;
      ctx.fillRect(0, y - roadWidth / 2 - 1, w, 2);
      ctx.fillRect(0, y + roadWidth / 2 - 1, w, 2);

      // dashed center lane
      ctx.strokeStyle = laneColor;
      ctx.lineWidth = laneWidth;
      ctx.setLineDash([cellSize * 0.6, cellSize * 0.6]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
      ctx.setLineDash([]);

      // Intersections: stop lines and occasional roundabouts (no zebra crossings)
      for (let col = 0; col < viewW; col++) {
        const worldX = origin.x + col;
        if (worldX % ROAD_SPACING !== 0) continue;
        const x = col * cellSize + cellSize / 2;
        // stop lines (horizontal approaches)
        ctx.fillStyle = "hsl(0 0% 96%)";
        const stopW = Math.max(2, cellSize * 0.12);
        const stopTop = y - roadWidth * 0.45;
        const stopHeight = roadWidth * 0.9;
        ctx.fillRect(x - roadWidth * 0.6, stopTop, stopW, stopHeight);
        ctx.fillRect(x + roadWidth * 0.6 - stopW, stopTop, stopW, stopHeight);
        // place a roundabout on some intersections
        const gridI = Math.abs(
          Math.floor(worldX / ROAD_SPACING) + Math.floor(worldY / ROAD_SPACING),
        );
        if (gridI % 3 === 0) {
          drawRoundabout(x, y);
        } else {
          // simple traffic lights markers at corners
          ctx.fillStyle = "hsl(0 80% 55%)";
          ctx.fillRect(x - roadWidth * 0.55, y - roadWidth * 0.55, 2, 2);
          ctx.fillStyle = "hsl(120 70% 50%)";
          ctx.fillRect(
            x + roadWidth * 0.55 - 2,
            y + roadWidth * 0.55 - 2,
            2,
            2,
          );
        }
      }

      // side blocks removed; city blocks will be drawn in a dedicated pass below to avoid overlaps
    }

    // Vertical roads (actual draw)
    for (let col = 0; col < viewW; col++) {
      const worldX = origin.x + col;
      if (worldX % ROAD_SPACING !== 0) continue;
      const x = col * cellSize + cellSize / 2;

      // sidewalks (left & right)
      ctx.fillStyle = sidewalkColor;
      ctx.fillRect(x - roadWidth / 2 - sidewalkWidth, 0, sidewalkWidth, h);
      ctx.fillRect(x + roadWidth / 2, 0, sidewalkWidth, h);
      // tiled pattern on sidewalks
      drawSidewalkTiles(x - roadWidth / 2 - sidewalkWidth, 0, sidewalkWidth, h);
      drawSidewalkTiles(x + roadWidth / 2, 0, sidewalkWidth, h);

      // asphalt
      ctx.fillStyle = roadColor;
      ctx.fillRect(x - roadWidth / 2, 0, roadWidth, h);
      // edge lines (solid)
      ctx.strokeStyle = "hsl(0 0% 96%)";
      ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.08));
      ctx.beginPath();
      ctx.moveTo(x - roadWidth / 2 + ctx.lineWidth, 0);
      ctx.lineTo(x - roadWidth / 2 + ctx.lineWidth, h);
      ctx.moveTo(x + roadWidth / 2 - ctx.lineWidth, 0);
      ctx.lineTo(x + roadWidth / 2 - ctx.lineWidth, h);
      ctx.stroke();

      // curbs
      ctx.fillStyle = curbColor;
      ctx.fillRect(x - roadWidth / 2 - 1, 0, 2, h);
      ctx.fillRect(x + roadWidth / 2 - 1, 0, 2, h);

      // dashed center lane
      ctx.strokeStyle = laneColor;
      ctx.lineWidth = laneWidth;
      ctx.setLineDash([cellSize * 0.6, cellSize * 0.6]);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
      ctx.setLineDash([]);

      // stop lines (vertical approaches) at each horizontal road (no zebra crossings)
      for (let row = 0; row < viewH; row++) {
        const worldY2 = origin.y + row;
        if (worldY2 % ROAD_SPACING !== 0) continue;
        const y2 = row * cellSize + cellSize / 2;
        ctx.fillStyle = "hsl(0 0% 96%)";
        const sH = Math.max(2, cellSize * 0.12);
        const sW = roadWidth * 0.9;
        ctx.fillRect(x - sW / 2, y2 - roadWidth * 0.6, sW, sH);
        ctx.fillRect(x - sW / 2, y2 + roadWidth * 0.6 - sH, sW, sH);
      }

      // side blocks removed; city blocks will be drawn in a dedicated pass below to avoid overlaps
    }

    // Helpers for protected rail corridor and parking lot
    const drawRail = (rect: { x: number; y: number; w: number; h: number }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      ctx.save();
      // ballast background
      ctx.fillStyle = "hsl(40 20% 78%)";
      ctx.fillRect(x, y, pxW, pxH);
      // sleepers
      ctx.fillStyle = "hsl(30 20% 50%)";
      const sleeperGap = Math.max(6, cellSize * 0.8);
      for (let yy = y + 4; yy < y + pxH - 4; yy += sleeperGap) {
        ctx.fillRect(x + 2, yy, pxW - 4, Math.max(2, cellSize * 0.15));
      }
      // two rails (inner dark strips with steel edges)
      const railW = Math.max(4, Math.min(10, pxW / 4));
      const inset = Math.max(6, (pxW - railW * 2) / 3);
      const leftX = x + inset;
      const rightX = x + pxW - inset - railW;
      const drawRailBar = (rx: number) => {
        ctx.fillStyle = "hsl(0 0% 30%)";
        ctx.fillRect(rx, y, railW, pxH);
        ctx.fillStyle = "hsl(0 0% 80%)";
        ctx.fillRect(rx, y, railW, 2);
        ctx.fillRect(rx, y + pxH - 2, railW, 2);
      };
      drawRailBar(leftX);
      drawRailBar(rightX);
      // safety fences
      ctx.fillStyle = "hsl(120 15% 30%)";
      ctx.fillRect(x, y, 2, pxH);
      ctx.fillRect(x + pxW - 2, y, 2, pxH);
      ctx.restore();
    };

    const drawParking = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      ctx.save();
      // outer curb
      ctx.fillStyle = "hsl(40 25% 88%)";
      roundRect(ctx, x, y, pxW, pxH, Math.min(pxW, pxH) * 0.06);
      ctx.fill();
      // asphalt
      const curb = Math.max(4, cellSize * 0.4);
      ctx.fillStyle = "hsl(220 12% 22%)";
      roundRect(
        ctx,
        x + curb,
        y + curb,
        pxW - 2 * curb,
        pxH - 2 * curb,
        Math.min(pxW, pxH) * 0.04,
      );
      ctx.fill();
      // entry gate
      const gateW = Math.max(8, pxW * 0.18);
      ctx.fillStyle = "hsl(40 60% 60%)";
      ctx.fillRect(x + pxW / 2 - gateW / 2, y + curb - 2, gateW, 4);
      // parking slots (angled)
      ctx.strokeStyle = "hsl(0 0% 96%)";
      ctx.lineWidth = Math.max(1, cellSize * 0.08);
      const innerX = x + curb + 6;
      const innerY = y + curb + 6;
      const innerW = pxW - 2 * curb - 12;
      const innerH = pxH - 2 * curb - 12;
      const slotGap = Math.max(10, cellSize * 1.2);
      for (
        let sx = innerX + slotGap;
        sx < innerX + innerW - slotGap;
        sx += slotGap
      ) {
        ctx.beginPath();
        ctx.moveTo(sx, innerY + 8);
        ctx.lineTo(sx + 14, innerY + innerH - 8);
        ctx.stroke();
      }
      // a few colorful cars
      const colors = [
        "hsl(0 72% 52%)",
        "hsl(210 82% 54%)",
        "hsl(46 92% 54%)",
        "hsl(140 56% 42%)",
      ];
      for (let i = 0; i < 5; i++) {
        const cx = innerX + slotGap * (1 + (i % 4)) + (i % 2 ? 4 : -6);
        const cy = innerY + innerH * (0.25 + 0.12 * (i % 3));
        const cw = Math.max(8, cellSize * 0.8);
        const ch = Math.max(14, cellSize * 1.2);
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate((-15 * Math.PI) / 180);
        ctx.fillStyle = colors[i % colors.length]!;
        roundRect(ctx, -cw / 2, -ch / 2, cw, ch, 3);
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();
    };

    // City blocks: draw once per non-road rectangle between roads
    try {
      const cellsW = viewW;
      const cellsH = viewH;
      const startCol = (() => {
        let c = origin.x;
        while (c % ROAD_SPACING !== 1 && c <= origin.x + viewW - 1) c++;
        return c;
      })();
      const startRow = (() => {
        let r = origin.y;
        while (r % ROAD_SPACING !== 1 && r <= origin.y + viewH - 1) r++;
        return r;
      })();
      for (let wy = startRow; wy <= origin.y + cellsH - 1; wy += ROAD_SPACING) {
        const blockHeightCells = Math.min(
          ROAD_SPACING - 1,
          origin.y + cellsH - wy,
        );
        for (
          let wx = startCol;
          wx <= origin.x + cellsW - 1;
          wx += ROAD_SPACING
        ) {
          const blockWidthCells = Math.min(
            ROAD_SPACING - 1,
            origin.x + cellsW - wx,
          );
          const pxX = (wx - origin.x) * cellSize;
          const pxY = (wy - origin.y) * cellSize;
          const pxW = blockWidthCells * cellSize;
          const pxH = blockHeightCells * cellSize;

          const worldRect = {
            x: wx,
            y: wy,
            w: blockWidthCells,
            h: blockHeightCells,
          };
          const overlapsProtected = (
            rects: { x: number; y: number; w: number; h: number }[],
          ) => {
            const corners = [
              { x: worldRect.x, y: worldRect.y },
              { x: worldRect.x + worldRect.w - 1, y: worldRect.y },
              { x: worldRect.x, y: worldRect.y + worldRect.h - 1 },
              {
                x: worldRect.x + worldRect.w - 1,
                y: worldRect.y + worldRect.h - 1,
              },
            ];
            return rects.some((r) =>
              corners.some(
                (c) =>
                  c.x >= r.x &&
                  c.x < r.x + r.w &&
                  c.y >= r.y &&
                  c.y < r.y + r.h,
              ),
            );
          };
          if (
            overlapsProtected([
              PROTECTED.POND,
              PROTECTED.CITY,
              PROTECTED.STADIUM,
              PROTECTED.RAIL,
              PROTECTED.PARKING,
              ...AIRPORTS,
              ...LAKES,
              ...GOLF_COURSES,
              ...BEACHES,
              ...MARINAS,
              ...FOOTBALL_FIELDS,
              ...CITIES,
            ])
          ) {
            continue;
          }

          drawBlock32(ctx, pxX, pxY, pxW, pxH, blockFill, blockStroke);
        }
      }
    } catch (err) {
      const e: any = err as any;
      console.log("MapCityBlocksDraw", e?.message ?? String(e));
    }

    // Helper: generic rounded rectangle path
    function roundRect(
      ctx: CanvasRenderingContext2D,
      x: number,
      y: number,
      w: number,
      h: number,
      r: number,
    ) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    // New landmark drawers
    const drawLake = (rect: { x: number; y: number; w: number; h: number }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      const r = Math.min(pxW, pxH) * 0.22;
      // Park ring
      const margin = Math.max(cellSize * 0.6, 8);
      ctx.fillStyle = "hsl(120 40% 60%)";
      roundRect(
        ctx,
        x - margin,
        y - margin,
        pxW + margin * 2,
        pxH + margin * 2,
        r * 1.1,
      );
      ctx.fill();
      // Sand/stone walkway
      ctx.fillStyle = "hsl(46 85% 80%)";
      roundRect(
        ctx,
        x - margin / 2,
        y - margin / 2,
        pxW + margin,
        pxH + margin,
        r,
      );
      ctx.fill();
      // Water
      const grad = ctx.createLinearGradient(x, y, x + pxW, y + pxH);
      grad.addColorStop(0, "hsl(206 85% 58%)");
      grad.addColorStop(1, "hsl(206 90% 63%)");
      ctx.fillStyle = grad;
      roundRect(ctx, x, y, pxW, pxH, r * 0.9);
      ctx.fill();
    };

    const drawGolfCourse = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      // Fairway
      ctx.fillStyle = "hsl(120 44% 68%)";
      roundRect(ctx, x, y, pxW, pxH, Math.min(pxW, pxH) * 0.2);
      ctx.fill();
      // Greens
      ctx.fillStyle = "hsl(120 50% 56%)";
      const gW = Math.max(10, pxW * 0.22);
      const gH = Math.max(8, pxH * 0.22);
      roundRect(
        ctx,
        x + pxW * 0.12,
        y + pxH * 0.2,
        gW,
        gH,
        Math.min(gW, gH) * 0.4,
      );
      ctx.fill();
      roundRect(
        ctx,
        x + pxW * 0.68,
        y + pxH * 0.6,
        gW,
        gH,
        Math.min(gW, gH) * 0.4,
      );
      ctx.fill();
      // Bunkers
      ctx.fillStyle = "hsl(46 80% 78%)";
      roundRect(ctx, x + pxW * 0.4, y + pxH * 0.35, gW * 0.6, gH * 0.6, 6);
      ctx.fill();
    };

    const drawBeach = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      // Sand band
      const sandGrad = ctx.createLinearGradient(x, y, x, y + pxH);
      sandGrad.addColorStop(0, "hsl(46 86% 82%)");
      sandGrad.addColorStop(1, "hsl(46 90% 76%)");
      ctx.fillStyle = sandGrad;
      ctx.fillRect(x, y, pxW, pxH);
      // Water edge
      ctx.fillStyle = "hsl(206 85% 60%)";
      ctx.fillRect(
        x,
        y + pxH - Math.max(6, cellSize * 0.6),
        pxW,
        Math.max(6, cellSize * 0.6),
      );
    };

    const drawMarina = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      // Docks as piers
      ctx.fillStyle = "hsl(30 24% 62%)";
      const pierW = Math.max(4, cellSize * 0.4);
      for (let i = 0; i < 4; i++) {
        ctx.fillRect(x + i * (pxW / 4) + pierW, y, pierW, pxH);
      }
      // Small boats
      const boatW = Math.max(6, cellSize * 0.7);
      const boatH = Math.max(3, cellSize * 0.4);
      for (let i = 0; i < 5; i++) {
        const bx = x + (i + 0.5) * (pxW / 5) - boatW / 2;
        const by = y + pxH * (0.2 + 0.6 * ((i % 2) / 2));
        ctx.fillStyle = [
          "hsl(0 72% 52%)",
          "hsl(210 82% 54%)",
          "hsl(46 92% 54%)",
        ][i % 3]!;
        roundRect(ctx, bx, by, boatW, boatH, 3);
        ctx.fill();
      }
    };

    const drawFootballField = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      ctx.fillStyle = "hsl(120 45% 60%)";
      roundRect(ctx, x, y, pxW, pxH, Math.min(pxW, pxH) * 0.1);
      ctx.fill();
      // Lines
      ctx.strokeStyle = "hsl(0 0% 98%)";
      ctx.lineWidth = Math.max(1, cellSize * 0.08);
      ctx.strokeRect(x + 4, y + 4, pxW - 8, pxH - 8);
      // Mid circle
      ctx.beginPath();
      ctx.arc(
        x + pxW / 2,
        y + pxH / 2,
        Math.max(6, Math.min(pxW, pxH) * 0.12),
        0,
        Math.PI * 2,
      );
      ctx.stroke();
    };

    const drawTennisCourt = (rect: {
      x: number;
      y: number;
      w: number;
      h: number;
    }) => {
      const { x, y } = worldToPx(rect.x, rect.y);
      const pxW = rect.w * cellSize;
      const pxH = rect.h * cellSize;
      if (x + pxW < 0 || y + pxH < 0 || x > w || y > h) return;
      // surface
      ctx.fillStyle = "hsl(160 45% 40%)";
      roundRect(ctx, x, y, pxW, pxH, Math.min(pxW, pxH) * 0.08);
      ctx.fill();
      // boundary lines
      ctx.strokeStyle = "hsl(0 0% 96%)";
      ctx.lineWidth = Math.max(1, cellSize * 0.08);
      ctx.strokeRect(x + 3, y + 3, pxW - 6, pxH - 6);
      // net line in the middle
      const midY = y + pxH / 2;
      ctx.beginPath();
      ctx.moveTo(x + 3, midY);
      ctx.lineTo(x + pxW - 3, midY);
      ctx.stroke();
    };

    // Landmarks (fixed world positions near origin so they are visible by default)
    const pond = PROTECTED.POND;
    const city = PROTECTED.CITY;
    const stadium = PROTECTED.STADIUM;
    const rail = PROTECTED.RAIL;
    const parking = PROTECTED.PARKING;
    drawPond(pond);
    AIRPORTS.forEach((a) => drawAirport(a));
    drawCity(city);
    CITIES.forEach((c) => drawCity(c));
    drawStadium(stadium);
    drawRail(rail);
    drawParking(parking);
    // New landmarks
    LAKES.forEach((r) => drawLake(r));
    GOLF_COURSES.forEach((r) => drawGolfCourse(r));
    BEACHES.forEach((r) => drawBeach(r));
    MARINAS.forEach((r) => drawMarina(r));
    FOOTBALL_FIELDS.forEach((r) => drawFootballField(r));
    TENNIS_COURTS.forEach((r) => drawTennisCourt(r));

    // Seasonal luxury areas (drawn relative to area base)
    const drawAreaRelative = (
      areaId: number,
      drawFn: (px: number, py: number, pw: number, ph: number) => void,
    ) => {
      const base = areaBaseRectFromId(areaId);
      if (!base) return;
      const { x, y } = worldToPx(base.x, base.y);
      const pw = AREA_W * cellSize;
      const ph = AREA_H * cellSize;
      if (x + pw < -50 || y + ph < -50 || x > w + 50 || y > h + 50) return;
      drawFn(x, y, pw, ph);
    };

    // Area 740: Summer luxury (rounded lake + marina, beach with umbrellas & sunbeds, golf green)
    drawAreaRelative(740, (ax, ay, aw, ah) => {
      ctx.save();
      // Curved lake with subtle gradient and sparkle
      const lake = {
        x: ax + (9 / AREA_W) * aw,
        y: ay + (7 / AREA_H) * ah,
        w: (30 / AREA_W) * aw,
        h: (12 / AREA_H) * ah,
      };
      const lakeGrad = ctx.createLinearGradient(
        lake.x,
        lake.y,
        lake.x + lake.w,
        lake.y + lake.h,
      );
      lakeGrad.addColorStop(0, "hsl(206 85% 60%)");
      lakeGrad.addColorStop(1, "hsl(206 90% 66%)");
      ctx.fillStyle = lakeGrad;
      roundRect(
        ctx,
        lake.x,
        lake.y,
        lake.w,
        lake.h,
        Math.min(lake.w, lake.h) * 0.28,
      );
      ctx.fill();
      // water sparkle
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = Math.max(1, cellSize * 0.08);
      for (let i = 0; i < 18; i++) {
        const t = i / 18;
        const sx = lake.x + lake.w * (0.1 + 0.8 * t);
        const sy = lake.y + lake.h * (0.2 + 0.6 * ((i % 3) / 3));
        ctx.beginPath();
        ctx.moveTo(sx - 2, sy);
        ctx.lineTo(sx + 2, sy);
        ctx.stroke();
      }
      // Marina piers jutting into the lake
      ctx.fillStyle = "hsl(30 24% 62%)";
      const mx = lake.x + lake.w * 0.82;
      const my = lake.y + lake.h * 0.08;
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(
          mx - i * (lake.w / 8),
          my,
          Math.max(4, cellSize * 0.4),
          lake.h * (0.45 + 0.05 * (i % 2)),
        );
      }
      // palm trees near beach
      const palm = (px: number, py: number, s: number) => {
        ctx.save();
        ctx.translate(px, py);
        // trunk
        ctx.fillStyle = "hsl(25 50% 38%)";
        ctx.fillRect(-s * 0.3, -s * 1.8, s * 0.6, s * 1.8);
        // leaves as robust circles (avoid ellipse incompatibility)
        ctx.fillStyle = "hsl(140 50% 36%)";
        const r = Math.max(2, s * 0.6);
        for (let a = 0; a < 6; a++) {
          const ang = (a / 6) * Math.PI * 2;
          const lx = Math.cos(ang) * s * 0.9;
          const ly = -s * 1.8 + Math.sin(ang) * s * 0.5;
          ctx.beginPath();
          ctx.arc(lx, ly, r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      };
      // Small yachts
      const drawYacht = (bx: number, by: number, s: number) => {
        ctx.save();
        ctx.translate(bx, by);
        ctx.rotate(-0.15);
        ctx.fillStyle = "hsl(0 0% 98%)";
        roundRect(ctx, -8 * s, -3 * s, 16 * s, 6 * s, 3);
        ctx.fill();
        ctx.fillStyle = "hsl(210 20% 70%)";
        ctx.beginPath();
        ctx.moveTo(0, -3 * s);
        ctx.lineTo(6 * s, 0);
        ctx.lineTo(0, 3 * s);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      };
      drawYacht(lake.x + lake.w * 0.35, lake.y + lake.h * 0.4, 1);
      drawYacht(lake.x + lake.w * 0.55, lake.y + lake.h * 0.25, 0.9);
      // Beach – rounded band of sand
      const beach = {
        x: ax + (43 / AREA_W) * aw,
        y: ay + (19 / AREA_H) * ah,
        w: (26 / AREA_W) * aw,
        h: (7 / AREA_H) * ah,
      };
      const sandGrad = ctx.createLinearGradient(
        beach.x,
        beach.y,
        beach.x,
        beach.y + beach.h,
      );
      sandGrad.addColorStop(0, "hsl(46 92% 82%)");
      sandGrad.addColorStop(1, "hsl(46 90% 74%)");
      ctx.fillStyle = sandGrad;
      roundRect(
        ctx,
        beach.x,
        beach.y,
        beach.w,
        beach.h,
        Math.min(beach.w, beach.h) * 0.3,
      );
      ctx.fill();
      // Palms along the beach
      for (let i = 0; i < 4; i++)
        palm(
          beach.x + (i + 0.5) * (beach.w / 4),
          beach.y + beach.h * 0.2,
          Math.max(4, cellSize * 0.7),
        );
      // Umbrellas & sunbeds
      for (let i = 0; i < 6; i++) {
        const ux = beach.x + beach.w * (0.1 + 0.13 * i);
        const uy = beach.y + beach.h * 0.35;
        ctx.fillStyle = i % 2 ? "hsl(0 78% 58%)" : "hsl(210 82% 54%)";
        ctx.beginPath();
        ctx.arc(ux, uy, Math.max(3, cellSize * 0.5), 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "hsl(0 0% 96%)";
        roundRect(ctx, ux - 6, uy + 4, 12, 3, 1);
      }
      // Golf green with bunkers and flag
      ctx.fillStyle = "hsl(120 44% 68%)";
      const gx = ax + (6 / AREA_W) * aw,
        gy = ay + (26 / AREA_H) * ah,
        gw = (24 / AREA_W) * aw,
        gh = (10 / AREA_H) * ah;
      roundRect(ctx, gx, gy, gw, gh, Math.min(gw, gh) * 0.2);
      ctx.fill();
      ctx.fillStyle = "hsl(46 80% 78%)";
      roundRect(ctx, gx + gw * 0.65, gy + gh * 0.25, gw * 0.22, gh * 0.35, 6);
      ctx.strokeStyle = "hsl(0 80% 50%)";
      ctx.beginPath();
      ctx.moveTo(gx + gw * 0.18, gy + gh * 0.18);
      ctx.lineTo(gx + gw * 0.18, gy + gh * 0.02);
      ctx.stroke();
      ctx.fillStyle = "hsl(0 80% 50%)";
      ctx.beginPath();
      ctx.moveTo(gx + gw * 0.18, gy + gh * 0.02);
      ctx.lineTo(gx + gw * 0.23, gy + gh * 0.08);
      ctx.lineTo(gx + gw * 0.18, gy + gh * 0.08);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });

    // Area 1111: Winter luxury (layered mountain, skiers, glowing Xmas tree, Santa)
    drawAreaRelative(1111, (ax, ay, aw, ah) => {
      ctx.save();
      // Snow blanket
      const snow = {
        x: ax + (8 / AREA_W) * aw,
        y: ay + (6 / AREA_H) * ah,
        w: (28 / AREA_W) * aw,
        h: (22 / AREA_H) * ah,
      };
      ctx.fillStyle = "hsl(210 20% 95%)";
      roundRect(
        ctx,
        snow.x,
        snow.y,
        snow.w,
        snow.h,
        Math.min(snow.w, snow.h) * 0.14,
      );
      ctx.fill();
      // Layered mountain with shaded faces
      const baseX = ax + (10 / AREA_W) * aw;
      const baseY = ay + (26 / AREA_H) * ah;
      const mW = (24 / AREA_W) * aw;
      const mH = (18 / AREA_H) * ah;
      const drawPeak = (offset: number, shade: string) => {
        ctx.fillStyle = shade;
        ctx.beginPath();
        ctx.moveTo(baseX + offset, baseY);
        ctx.lineTo(baseX + mW / 2 + offset, baseY - mH * 1.05);
        ctx.lineTo(baseX + mW + offset, baseY);
        ctx.closePath();
        ctx.fill();
      };
      drawPeak(-mW * 0.08, "hsl(210 12% 74%)");
      drawPeak(0, "hsl(210 10% 68%)");
      drawPeak(mW * 0.06, "hsl(210 8% 62%)");
      // Ski tracks with tiny skiers
      ctx.strokeStyle = "hsl(210 12% 50%)";
      ctx.lineWidth = Math.max(1, cellSize * 0.06);
      for (let i = 0; i < 7; i++) {
        const sx = baseX + (i / 7) * mW * 0.9;
        const sy = baseY - (i / 7) * mH * 0.92;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + 7, sy + 9);
        ctx.stroke();
        // skier dot
        ctx.fillStyle = i % 2 ? "hsl(0 80% 55%)" : "hsl(210 82% 54%)";
        ctx.beginPath();
        ctx.arc(sx + 7, sy + 9, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      // Xmas tree with glow
      const tx = ax + (44 / AREA_W) * aw;
      const ty = ay + (8 / AREA_H) * ah;
      const glow = ctx.createRadialGradient(
        tx + 4,
        ty + 6,
        2,
        tx + 4,
        ty + 6,
        18,
      );
      glow.addColorStop(0, "rgba(255,230,120,0.8)");
      glow.addColorStop(1, "rgba(255,230,120,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(tx + 4, ty + 6, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "hsl(140 50% 32%)";
      roundRect(ctx, tx, ty + 12, 8, 10, 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(tx + 4, ty);
      ctx.lineTo(tx + 10, ty + 12);
      ctx.lineTo(tx - 2, ty + 12);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "hsl(50 100% 60%)";
      for (let i = 0; i < 6; i++)
        ctx.fillRect(tx + (i % 3) * 4, ty + 6 + Math.floor(i / 3) * 4, 2, 2);
      // Santa
      ctx.fillStyle = "hsl(0 80% 55%)";
      ctx.beginPath();
      const scx = ax + (50 / AREA_W) * aw + 6;
      const scy = ay + (18 / AREA_H) * ah + 6;
      ctx.arc(scx, scy, 6, 0, Math.PI * 2);
      ctx.fill();
      // Snowfall
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      for (let i = 0; i < 30; i++) {
        const px = snow.x + (((i * 59) % 1000) / 1000) * snow.w;
        const py = snow.y + (((i * 97) % 1000) / 1000) * snow.h;
        ctx.fillRect(px, py, 1.5, 1.5);
      }
      ctx.restore();
    });

    // Area 989: Autumn luxury (brown park with drifting leaves)
    drawAreaRelative(989, (ax, ay, aw, ah) => {
      ctx.save();
      const park = {
        x: ax + (10 / AREA_W) * aw,
        y: ay + (8 / AREA_H) * ah,
        w: (40 / AREA_W) * aw,
        h: (20 / AREA_H) * ah,
      };
      const grad = ctx.createLinearGradient(
        park.x,
        park.y,
        park.x,
        park.y + park.h,
      );
      grad.addColorStop(0, "hsl(30 42% 62%)");
      grad.addColorStop(1, "hsl(28 38% 54%)");
      ctx.fillStyle = grad;
      roundRect(ctx, park.x, park.y, park.w, park.h, 12);
      ctx.fill();
      const colors = [
        "hsl(25 60% 50%)",
        "hsl(30 55% 45%)",
        "hsl(12 65% 48%)",
        "hsl(40 52% 56%)",
      ];
      for (let i = 0; i < 110; i++) {
        ctx.fillStyle = colors[i % colors.length]!;
        const px = park.x + Math.random() * park.w;
        const py = park.y + Math.random() * park.h;
        ctx.beginPath();
        ctx.ellipse(
          px,
          py,
          2 + Math.random() * 1.5,
          1 + Math.random(),
          Math.random() * Math.PI,
          0,
          Math.PI * 2,
        );
        ctx.fill();
      }
      ctx.restore();
    });

    // Area 247: Spring luxury (pastel blossom park)
    drawAreaRelative(247, (ax, ay, aw, ah) => {
      ctx.save();
      const patch = {
        x: ax + (12 / AREA_W) * aw,
        y: ay + (10 / AREA_H) * ah,
        w: (48 / AREA_W) * aw,
        h: (20 / AREA_H) * ah,
      };
      const g = ctx.createLinearGradient(
        patch.x,
        patch.y,
        patch.x + patch.w,
        patch.y + patch.h,
      );
      g.addColorStop(0, "hsl(140 42% 72%)");
      g.addColorStop(1, "hsl(140 38% 66%)");
      ctx.fillStyle = g;
      roundRect(ctx, patch.x, patch.y, patch.w, patch.h, 14);
      ctx.fill();
      const blossoms = [
        "hsl(330 70% 82%)",
        "hsl(210 80% 82%)",
        "hsl(280 45% 80%)",
      ];
      for (let i = 0; i < 80; i++) {
        ctx.fillStyle = blossoms[i % blossoms.length]!;
        ctx.beginPath();
        ctx.arc(
          patch.x + Math.random() * patch.w,
          patch.y + Math.random() * patch.h,
          Math.max(2, cellSize * 0.18),
          0,
          Math.PI * 2,
        );
        ctx.fill();
      }
      ctx.restore();
    });

    // Per-area mini parks (decorative, at least one per visible area)
    try {
      const startColA = Math.floor(origin.x / AREA_W);
      const endColA = Math.floor((origin.x + viewW - 1) / AREA_W);
      const startRowA = Math.floor(origin.y / AREA_H);
      const endRowA = Math.floor((origin.y + viewH - 1) / AREA_H);
      for (let r = startRowA; r <= endRowA; r++) {
        for (let c = startColA; c <= endColA; c++) {
          const areaId = r * AREAS_PER_ROW + c + 1;
          const base = areaBaseRectFromId(areaId);
          if (!base) continue;
          const pxX = ((base?.x ?? 0) - origin.x) * cellSize;
          const pxY = ((base?.y ?? 0) - origin.y) * cellSize;
          const pw = AREA_W * cellSize;
          const ph = AREA_H * cellSize;
          const seed = areaId * 2654435761;
          const rx = ((seed >>> 3) % 1000) / 1000;
          const ry = ((seed >>> 13) % 1000) / 1000;
          const parkW = Math.max(18, pw * 0.16);
          const parkH = Math.max(12, ph * 0.18);
          const px = pxX + 6 + rx * (pw - parkW - 12);
          const py = pxY + 6 + ry * (ph - parkH - 12);
          ctx.save();
          ctx.fillStyle = "hsl(120 44% 62%)";
          roundRect(
            ctx,
            px,
            py,
            parkW,
            parkH,
            Math.min(10, Math.min(parkW, parkH) * 0.2),
          );
          ctx.fill();
          ctx.fillStyle = "hsl(46 85% 80%)";
          const pathW = Math.max(3, parkW * 0.12);
          ctx.fillRect(px + parkW / 2 - pathW / 2, py + 4, pathW, parkH - 8);
          const tree = (tx: number, ty: number) => {
            ctx.fillStyle = "rgba(0,0,0,0.15)";
            ctx.beginPath();
            ctx.ellipse(tx + 2, ty + 6, 6, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "hsl(25 24% 26%)";
            ctx.fillRect(tx - 1, ty, 2, 6);
            const grd = ctx.createRadialGradient(tx, ty - 4, 2, tx, ty - 4, 9);
            grd.addColorStop(0, "hsl(120 52% 46%)");
            grd.addColorStop(1, "hsl(120 36% 32%)");
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(tx, ty - 4, 9, 0, Math.PI * 2);
            ctx.fill();
          };
          tree(px + parkW * 0.2, py + parkH * 0.7);
          tree(px + parkW * 0.8, py + parkH * 0.4);
          ctx.restore();
        }
      }
    } catch {
      /* ignore */
    }

    // Trees strictly on sidewalks near roads (never inside buildable block interiors)
    const isInRect = (
      wx: number,
      wy: number,
      r: { x: number; y: number; w: number; h: number },
    ) => wx >= r.x && wx < r.x + r.w && wy >= r.y && wy < r.y + r.h;

    const hash = (xv: number, yv: number) => {
      let t = xv * 374761393 + yv * 668265263;
      t = (t ^ (t << 13)) >>> 0;
      return ((t * 1274126177) >>> 0) / 0xffffffff;
    };

    const ownedCells = new Set<string>(
      (data?.cells ?? [])
        .filter((c: any) => !!c.ownerId)
        .map((c: any) => `${c.x}:${c.y}`),
    );

    for (let row = 0; row < viewH; row++) {
      for (let col = 0; col < viewW; col++) {
        const wx = origin.x + col;
        const wy = origin.y + row;
        // Only edges next to a road
        const isEdgeLeft = (wx - 1) % ROAD_SPACING === 0;
        const isEdgeRight = (wx + 1) % ROAD_SPACING === 0;
        const isEdgeTop = (wy - 1) % ROAD_SPACING === 0;
        const isEdgeBottom = (wy + 1) % ROAD_SPACING === 0;
        const isEdge = isEdgeLeft || isEdgeRight || isEdgeTop || isEdgeBottom;
        if (!isEdge) continue;
        // Never draw trees on buildbare 6×6 Lots
        if (isAllowedLotWorld(wx, wy)) continue;
        // avoid protected & owned
        let inAnyAirport = false;
        for (const a of AIRPORTS) {
          if (isInRect(wx, wy, a)) {
            inAnyAirport = true;
            break;
          }
        }
        if (
          inAnyAirport ||
          isInRect(wx, wy, PROTECTED.POND) ||
          isInRect(wx, wy, PROTECTED.CITY)
        )
          continue;
        if (ownedCells.has(`${wx}:${wy}`)) continue;
        const rnd = hash(wx, wy);
        if (rnd < 0.1) {
          // position inside sidewalk band next to the nearest road
          const cellLeft = col * cellSize;
          const cellTop = row * cellSize;
          let cx = cellLeft + cellSize / 2;
          let cy = cellTop + cellSize / 2;
          const offset = roadWidth / 2 + sidewalkWidth * 0.6;
          if (isEdgeTop) cy = cellTop + offset;
          if (isEdgeBottom) cy = cellTop + cellSize - offset;
          if (isEdgeLeft) cx = cellLeft + offset;
          if (isEdgeRight) cx = cellLeft + cellSize - offset;

          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.20)";
          ctx.beginPath();
          ctx.ellipse(
            cx + 1,
            cy + 3,
            cellSize * 0.18,
            cellSize * 0.12,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          // trunk
          ctx.fillStyle = "hsl(25 24% 26%)";
          ctx.fillRect(
            cx - cellSize * 0.045,
            cy - cellSize * 0.18,
            cellSize * 0.09,
            cellSize * 0.18,
          );
          // canopy
          const grd = ctx.createRadialGradient(
            cx,
            cy - cellSize * 0.12,
            Math.max(1, cellSize * 0.05),
            cx,
            cy - cellSize * 0.12,
            Math.max(2, cellSize * 0.38),
          );
          grd.addColorStop(0, "hsl(120 52% 46%)");
          grd.addColorStop(1, "hsl(120 36% 32%)");
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(
            cx - cellSize * 0.12,
            cy - cellSize * 0.12,
            Math.max(2, cellSize * 0.2),
            0,
            Math.PI * 2,
          );
          ctx.arc(
            cx + cellSize * 0.12,
            cy - cellSize * 0.14,
            Math.max(2, cellSize * 0.18),
            0,
            Math.PI * 2,
          );
          ctx.arc(
            cx,
            cy - cellSize * 0.18,
            Math.max(2, cellSize * 0.18),
            0,
            Math.PI * 2,
          );
          ctx.fill();
        }
      }
    }
  }, [origin.x, origin.y, viewW, viewH, cellSize]);

  // Cars animation layer
  type Car = {
    dir: "h" | "v";
    laneOffset: number;
    t: number;
    speed: number;
    fixed: number;
  };
  const carsRef = useRef<Car[]>([]);
  type Plane = {
    // Moving along a horizontal runway inside airport rect
    startX: number; // px
    endX: number; // px
    y: number; // px
    t: number; // 0..1
    speed: number; // px per ms relative
  };
  const planesRef = useRef<Plane[]>([]);
  const animRafRef = useRef<number | null>(null);

  // Helpers to keep cars off protected areas and to forbid building there on client-side
  const PROTECTED = {
    POND: { x: 18, y: 10, w: 10, h: 6 },
    CITY: { x: 22, y: -12, w: 28, h: 16 },
    STADIUM: { x: 6, y: 22, w: 24, h: 12 },
    RAIL: { x: -2, y: -20, w: 6, h: 60 },
    PARKING: { x: 36, y: 6, w: 20, h: 16 },
  } as const;
  const AIRPORTS: ReadonlyArray<{
    x: number;
    y: number;
    w: number;
    h: number;
  }> = [
    { x: -32, y: 14, w: 32, h: 10 },
    { x: -96, y: -24, w: 28, h: 10 },
    { x: 48, y: 44, w: 30, h: 10 },
    { x: 118, y: -30, w: 24, h: 8 },
    { x: -140, y: 68, w: 36, h: 12 },
    { x: 82, y: -88, w: 28, h: 10 },
    { x: 12, y: 110, w: 28, h: 10 },
    { x: -160, y: -110, w: 30, h: 10 },
  ];
  // New island world (matches server): 800 x 500 m²
  // inRect helper not needed anymore (kept for reference)
  // const inRect = (
  //   wx: number,
  //   wy: number,
  //   r: { x: number; y: number; w: number; h: number },
  // ) => wx >= r.x && wx < r.x + r.w && wy >= r.y && wy < r.y + r.h;

  // No more water: every m² inside the world is buyable
  const landMaskRef = React.useRef<Uint8Array | null>(null);
  const isAllowedLotWorld = React.useCallback(
    (wx: number, wy: number) => {
      const x = Math.floor(wx - ISLAND_X0);
      const y = Math.floor(wy - ISLAND_Y0);
      if (x < 0 || y < 0 || x >= ISLAND_W || y >= ISLAND_H) return false;

      let mask = landMaskRef.current;
      const expectedLen = ISLAND_W * ISLAND_H;
      if (!mask || mask.length !== expectedLen) {
        mask = new Uint8Array(expectedLen);
        landMaskRef.current = mask;
      }

      const idx = y * ISLAND_W + x;
      const v = mask[idx] ?? 0;
      if (v === 1) return true;
      if (v === 2) return false;

      const inside = pointInPolygon(wx, wy);
      mask[idx] = inside ? 1 : 2;
      return inside;
    },
    [pointInPolygon],
  );
  // Additional local landmark sets (mirror of server protected areas)
  const LAKES: ReadonlyArray<{ x: number; y: number; w: number; h: number }> = [
    { x: -48, y: 18, w: 18, h: 10 },
    { x: 64, y: -52, w: 14, h: 8 },
  ];
  const GOLF_COURSES: ReadonlyArray<{
    x: number;
    y: number;
    w: number;
    h: number;
  }> = [
    { x: 12, y: -42, w: 24, h: 12 },
    { x: -70, y: 40, w: 22, h: 10 },
    { x: 90, y: 66, w: 20, h: 10 },
    { x: -120, y: -70, w: 26, h: 12 },
  ];
  const BEACHES: ReadonlyArray<{ x: number; y: number; w: number; h: number }> =
    [
      { x: -10, y: 54, w: 28, h: 8 },
      { x: 78, y: 20, w: 26, h: 8 },
    ];
  const MARINAS: ReadonlyArray<{ x: number; y: number; w: number; h: number }> =
    [
      { x: -44, y: 22, w: 10, h: 6 },
      { x: 68, y: -48, w: 8, h: 5 },
    ];
  const FOOTBALL_FIELDS: ReadonlyArray<{
    x: number;
    y: number;
    w: number;
    h: number;
  }> = [
    { x: 28, y: 30, w: 10, h: 6 },
    { x: -26, y: -14, w: 10, h: 6 },
    { x: 92, y: -22, w: 10, h: 6 },
    { x: -110, y: 58, w: 10, h: 6 },
  ];
  const TENNIS_COURTS: ReadonlyArray<{
    x: number;
    y: number;
    w: number;
    h: number;
  }> = [
    { x: 20, y: -28, w: 6, h: 4 },
    { x: -38, y: 18, w: 6, h: 4 },
    { x: 100, y: 12, w: 6, h: 4 },
    { x: -120, y: -40, w: 6, h: 4 },
  ];
  const CITIES: ReadonlyArray<{ x: number; y: number; w: number; h: number }> =
    [
      { x: 60, y: -10, w: 20, h: 12 },
      { x: -60, y: 26, w: 18, h: 10 },
      { x: 6, y: -64, w: 22, h: 12 },
    ];
  // Area helpers
  // areaBaseRectFromId no longer needed (no sub-area protections)
  // const areaBaseRectFromId = (
  //   areaId: number,
  // ): { x: number; y: number; w: number; h: number } | null => {
  //   if (!Number.isFinite(areaId) || areaId < 1 || areaId > AREAS_PER_ROW * 25)
  //     return null;
  //   const idx = areaId - 1;
  //   const r = Math.floor(idx / AREAS_PER_ROW);
  //   const c = idx % AREAS_PER_ROW;
  //   return { x: c * AREA_W, y: r * AREA_H, w: AREA_W, h: AREA_H };
  // };
  // areaIdFromWorld no longer needed (no sub-area protections)
  // const areaIdFromWorld = (wx: number, wy: number): number | null => {
  //   const c = Math.floor(wx / AREA_W);
  //   const r = Math.floor(wy / AREA_H);
  //   if (c < 0 || r < 0 || c >= AREAS_PER_ROW || r >= 25) return null;
  //   return r * AREAS_PER_ROW + c + 1;
  // };
  // Special protected sub-areas removed: every land tile is buyable now
  // const isSpecialProtectedWorld = (wx: number, wy: number) => false;

  // Restored helpers used by UI rendering
  const areaBaseRectFromId = (
    areaId: number,
  ): { x: number; y: number; w: number; h: number } | null => {
    if (!Number.isFinite(areaId) || areaId < 1 || areaId > AREAS_PER_ROW * 25)
      return null;
    const idx = areaId - 1;
    const r = Math.floor(idx / AREAS_PER_ROW);
    const c = idx % AREAS_PER_ROW;
    return { x: c * AREA_W, y: r * AREA_H, w: AREA_W, h: AREA_H };
  };
  // areaIdFromWorld helper not used after removing sub-area protections
  // const areaIdFromWorld = (wx: number, wy: number): number | null => {
  //   const c = Math.floor(wx / AREA_W);
  //   const r = Math.floor(wy / AREA_H);
  //   if (c < 0 || r < 0 || c >= AREAS_PER_ROW || r >= 25) return null;
  //   return r * AREAS_PER_ROW + c + 1;
  // };

  // roads disabled on island
  const pondParkPxRect = () => {
    const pond = PROTECTED.POND;
    const x = (pond.x - origin.x) * cellSize;
    const y = (pond.y - origin.y) * cellSize;
    const wpx = pond.w * cellSize;
    const hpx = pond.h * cellSize;
    const margin = Math.max(cellSize * 0.8, 10);
    return {
      x: x - margin,
      y: y - margin,
      w: wpx + margin * 2,
      h: hpx + margin * 2,
    };
  };

  // Cars/planes disabled, keep helper but avoid lint errors.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const reseedCars = () => {
    const cars: Car[] = [];
    const ROAD_SPACING = 8;
    // Horizontal roads
    for (let row = 0; row < viewH; row++) {
      const worldY = origin.y + row;
      if (worldY % ROAD_SPACING !== 0) continue;
      const count = Math.max(2, Math.floor(viewW / 12));
      for (let i = 0; i < count; i++) {
        cars.push({
          dir: "h",
          laneOffset: (i % 3 === 0 ? -1 : i % 3 === 1 ? 0 : 1) * 0.15,
          t: Math.random(),
          speed: 0.02 + Math.random() * 0.04, // dichter & schneller
          fixed: worldY,
        });
      }
    }
    // Vertical roads
    for (let col = 0; col < viewW; col++) {
      const worldX = origin.x + col;
      if (worldX % ROAD_SPACING !== 0) continue;
      const count = Math.max(2, Math.floor(viewH / 12));
      for (let i = 0; i < count; i++) {
        cars.push({
          dir: "v",
          laneOffset: (i % 3 === 0 ? -1 : i % 3 === 1 ? 0 : 1) * 0.15,
          t: Math.random(),
          speed: 0.02 + Math.random() * 0.04,
          fixed: worldX,
        });
      }
    }
    carsRef.current = cars;
    // Seed planes for airports in view (multiple airports)
    const planes: Plane[] = [];
    AIRPORTS.forEach((ap) => {
      const ax = (ap.x - origin.x) * cellSize;
      const ay = (ap.y - origin.y) * cellSize;
      const aw = ap.w * cellSize;
      const ah = ap.h * cellSize;
      const near =
        ax + aw > -100 &&
        ay + ah > -100 &&
        ax < viewW * cellSize + 100 &&
        ay < viewH * cellSize + 100;
      if (near) {
        const rwY = ay + ah * 0.5 - Math.max(2, cellSize * 0.6);
        const startX = ax + aw * 0.05;
        const endX = ax + aw * 0.95;
        const count = 2;
        for (let i = 0; i < count; i++) {
          planes.push({
            startX,
            endX,
            y: rwY + (i % 2 === 0 ? -cellSize * 0.2 : cellSize * 0.2),
            t: Math.random(),
            speed: 0.00008 + Math.random() * 0.00012,
          });
        }
      }
    });
    planesRef.current = planes;
  };

  // Cars/planes layer is disabled for performance, so we also skip reseeding.
  // (Keeping the refs in place avoids larger UI changes.)
  useEffect(() => {
    // no-op
  }, [origin.x, origin.y, viewW, viewH]);

  // Cars/planes animation layer disabled for performance.
  useEffect(() => {
    // Keep legacy code below (never executed) without breaking typechecking.
    const w = 0 as number;
    const h = 0 as number;
    const ctx: any = {};
    void w;
    void h;
    void ctx;

    return;

    let last = performance.now();

    const carPalette = [
      "hsl(0 72% 52%)", // red
      "hsl(210 82% 54%)", // blue
      "hsl(46 92% 54%)", // yellow
      "hsl(140 56% 42%)", // green
      "hsl(0 0% 96%)", // white
      "hsl(24 60% 45%)", // orange
    ];

    const draw = (now: number) => {
      const dt = Math.min(0.05, (now - last) / 1000); // cap
      last = now;
      // Update
      for (const car of carsRef.current) {
        car.t += car.speed * dt;
        if (car.t > 1.2) car.t = -0.2;
      }
      for (const plane of planesRef.current) {
        plane.t += plane.speed * (now - last); // speed scaled by ms
        if (plane.t > 1) plane.t = 0;
      }
      // Render
      ctx.clearRect(0, 0, w, h);
      const shadow = "rgba(0,0,0,0.25)";
      const carLen = Math.max(14, cellSize * 1.25);
      const carWid = Math.max(7, cellSize * 0.54);
      const seasonalNoDriveRects = () => {
        const out: { x: number; y: number; w: number; h: number }[] = [];
        const addRel = (
          areaId: number,
          x: number,
          y: number,
          w: number,
          h: number,
        ) => {
          const base = areaBaseRectFromId(areaId);
          if (!base) return;
          out.push({
            x: (base.x + x - origin.x) * cellSize,
            y: (base.y + y - origin.y) * cellSize,
            w: w * cellSize,
            h: h * cellSize,
          });
        };
        // 740 summer
        addRel(740, 10, 8, 28, 10);
        addRel(740, 36, 9, 6, 5);
        addRel(740, 44, 20, 24, 6);
        addRel(740, 6, 26, 24, 10);
        // 1111 winter
        addRel(1111, 8, 6, 28, 22);
        addRel(1111, 40, 8, 8, 8);
        addRel(1111, 50, 18, 6, 6);
        // 989 autumn
        addRel(989, 10, 8, 40, 20);
        // 247 spring
        addRel(247, 12, 10, 48, 20);
        return out;
      };

      const noDrive = [
        pondParkPxRect(),
        ...AIRPORTS.map((a) => ({
          x: (a.x - origin.x) * cellSize,
          y: (a.y - origin.y) * cellSize,
          w: a.w * cellSize,
          h: a.h * cellSize,
        })),
        {
          x: (PROTECTED.CITY.x - origin.x) * cellSize,
          y: (PROTECTED.CITY.y - origin.y) * cellSize,
          w: PROTECTED.CITY.w * cellSize,
          h: PROTECTED.CITY.h * cellSize,
        },
        ...CITIES.map((c) => ({
          x: (c.x - origin.x) * cellSize,
          y: (c.y - origin.y) * cellSize,
          w: c.w * cellSize,
          h: c.h * cellSize,
        })),
        {
          x: (PROTECTED.STADIUM.x - origin.x) * cellSize,
          y: (PROTECTED.STADIUM.y - origin.y) * cellSize,
          w: PROTECTED.STADIUM.w * cellSize,
          h: PROTECTED.STADIUM.h * cellSize,
        },
        {
          x: (PROTECTED.RAIL.x - origin.x) * cellSize,
          y: (PROTECTED.RAIL.y - origin.y) * cellSize,
          w: PROTECTED.RAIL.w * cellSize,
          h: PROTECTED.RAIL.h * cellSize,
        },
        {
          x: (PROTECTED.PARKING.x - origin.x) * cellSize,
          y: (PROTECTED.PARKING.y - origin.y) * cellSize,
          w: PROTECTED.PARKING.w * cellSize,
          h: PROTECTED.PARKING.h * cellSize,
        },
        ...LAKES.map((r) => ({
          x: (r.x - origin.x) * cellSize,
          y: (r.y - origin.y) * cellSize,
          w: r.w * cellSize,
          h: r.h * cellSize,
        })),
        ...GOLF_COURSES.map((r) => ({
          x: (r.x - origin.x) * cellSize,
          y: (r.y - origin.y) * cellSize,
          w: r.w * cellSize,
          h: r.h * cellSize,
        })),
        ...BEACHES.map((r) => ({
          x: (r.x - origin.x) * cellSize,
          y: (r.y - origin.y) * cellSize,
          w: r.w * cellSize,
          h: r.h * cellSize,
        })),
        ...MARINAS.map((r) => ({
          x: (r.x - origin.x) * cellSize,
          y: (r.y - origin.y) * cellSize,
          w: r.w * cellSize,
          h: r.h * cellSize,
        })),
        ...FOOTBALL_FIELDS.map((r) => ({
          x: (r.x - origin.x) * cellSize,
          y: (r.y - origin.y) * cellSize,
          w: r.w * cellSize,
          h: r.h * cellSize,
        })),
        ...seasonalNoDriveRects(),
      ];
      const inPxRect = (
        px: number,
        py: number,
        r: { x: number; y: number; w: number; h: number },
      ) => px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;

      carsRef.current.forEach((car, idx) => {
        const color: string =
          carPalette[idx % carPalette.length] || "hsl(0 0% 100%)";
        if (car.dir === "h") {
          const yRow = (car.fixed - origin.y) * cellSize + cellSize / 2;
          const x = car.t * w; // 0..w
          const laneShift = Math.max(4, cellSize * 0.5) * car.laneOffset; // approximate lane shift
          const y = yRow + laneShift;
          if (noDrive.some((r) => inPxRect(x, y, r))) return; // skip
          // shadow
          ctx.fillStyle = shadow;
          roundRect(
            ctx,
            x - carLen / 2 + 1,
            y - carWid / 2 + 1,
            carLen,
            carWid,
            Math.min(6, carWid / 2),
          );
          ctx.fill();
          // body with subtle horizontal sheen
          const gradBodyH = ctx.createLinearGradient(
            x - carLen / 2,
            y,
            x + carLen / 2,
            y,
          );
          gradBodyH.addColorStop(0, color);
          gradBodyH.addColorStop(0.5, "rgba(255,255,255,0.15)");
          gradBodyH.addColorStop(1, color);
          ctx.fillStyle = gradBodyH;
          roundRect(
            ctx,
            x - carLen / 2,
            y - carWid / 2,
            carLen,
            carWid,
            Math.min(6, carWid / 2),
          );
          ctx.fill();
          // windshield / roof highlight
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          roundRect(
            ctx,
            x - carLen * 0.15,
            y - carWid * 0.35,
            carLen * 0.3,
            carWid * 0.7,
            Math.min(4, carWid / 3),
          );
          ctx.fill();
          // wheels (top-down)
          ctx.fillStyle = "hsl(0 0% 15%)";
          ctx.beginPath();
          ctx.ellipse(
            x - carLen * 0.28,
            y - carWid * 0.55,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(
            x + carLen * 0.28,
            y - carWid * 0.55,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(
            x - carLen * 0.28,
            y + carWid * 0.55,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(
            x + carLen * 0.28,
            y + carWid * 0.55,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          // lights
          ctx.fillStyle = "hsl(48 100% 85%)";
          ctx.fillRect(
            x + carLen * 0.46,
            y - carWid * 0.18,
            Math.max(1, carLen * 0.05),
            Math.max(1, carWid * 0.18),
          );
          ctx.fillRect(
            x + carLen * 0.46,
            y + carWid * 0.01,
            Math.max(1, carLen * 0.05),
            Math.max(1, carWid * 0.18),
          );
          ctx.fillStyle = "hsl(0 80% 58%)";
          ctx.fillRect(
            x - carLen * 0.51,
            y - carWid * 0.18,
            Math.max(1, carLen * 0.05),
            Math.max(1, carWid * 0.18),
          );
          ctx.fillRect(
            x - carLen * 0.51,
            y + carWid * 0.01,
            Math.max(1, carLen * 0.05),
            Math.max(1, carWid * 0.18),
          );
        } else {
          const xCol = (car.fixed - origin.x) * cellSize + cellSize / 2;
          const y = car.t * h;
          const laneShiftV = Math.max(4, cellSize * 0.5) * car.laneOffset;
          const x = xCol + laneShiftV;
          if (noDrive.some((r) => inPxRect(x, y, r))) return;
          ctx.fillStyle = shadow;
          roundRect(
            ctx,
            x - carWid / 2 + 1,
            y - carLen / 2 + 1,
            carWid,
            carLen,
            Math.min(6, carWid / 2),
          );
          ctx.fill();
          const gradBodyV = ctx.createLinearGradient(
            x,
            y - carLen / 2,
            x,
            y + carLen / 2,
          );
          gradBodyV.addColorStop(0, color);
          gradBodyV.addColorStop(0.5, "rgba(255,255,255,0.15)");
          gradBodyV.addColorStop(1, color);
          ctx.fillStyle = gradBodyV;
          roundRect(
            ctx,
            x - carWid / 2,
            y - carLen / 2,
            carWid,
            carLen,
            Math.min(6, carWid / 2),
          );
          ctx.fill();
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          roundRect(
            ctx,
            x - carWid * 0.35,
            y - carLen * 0.15,
            carWid * 0.7,
            carLen * 0.3,
            Math.min(4, carWid / 3),
          );
          ctx.fill();
          // wheels (top-down)
          ctx.fillStyle = "hsl(0 0% 15%)";
          ctx.beginPath();
          ctx.ellipse(
            x - carWid * 0.55,
            y - carLen * 0.28,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(
            x + carWid * 0.55,
            y - carLen * 0.28,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(
            x - carWid * 0.55,
            y + carLen * 0.28,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(
            x + carWid * 0.55,
            y + carLen * 0.28,
            Math.max(1, carWid * 0.18),
            Math.max(1, carWid * 0.18),
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          // lights
          ctx.fillStyle = "hsl(48 100% 85%)";
          ctx.fillRect(
            x - carWid * 0.18,
            y - carLen * 0.51,
            Math.max(1, carWid * 0.18),
            Math.max(1, carLen * 0.05),
          );
          ctx.fillRect(
            x + carWid * 0.01,
            y - carLen * 0.51,
            Math.max(1, carWid * 0.18),
            Math.max(1, carLen * 0.05),
          );
          ctx.fillStyle = "hsl(0 80% 58%)";
          ctx.fillRect(
            x - carWid * 0.18,
            y + carLen * 0.46,
            Math.max(1, carWid * 0.18),
            Math.max(1, carLen * 0.05),
          );
          ctx.fillRect(
            x + carWid * 0.01,
            y + carLen * 0.46,
            Math.max(1, carWid * 0.18),
            Math.max(1, carLen * 0.05),
          );
        }
      });

      // Draw planes moving along the airport runway
      planesRef.current.forEach((p) => {
        const x = p.startX + (p.endX - p.startX) * p.t;
        const y = p.y;
        const bodyL = Math.max(28, cellSize * 2.4);
        const bodyW = Math.max(10, cellSize * 0.9);
        // shadow
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        roundRect(
          ctx,
          x - bodyL / 2 + 2,
          y - bodyW / 2 + 2,
          bodyL,
          bodyW,
          Math.min(8, bodyW / 2),
        );
        ctx.fill();
        // fuselage gradient
        const grad = ctx.createLinearGradient(
          x - bodyL / 2,
          y,
          x + bodyL / 2,
          y,
        );
        grad.addColorStop(0, "hsl(210 10% 85%)");
        grad.addColorStop(0.5, "hsl(210 20% 96%)");
        grad.addColorStop(1, "hsl(210 10% 85%)");
        ctx.fillStyle = grad;
        roundRect(
          ctx,
          x - bodyL / 2,
          y - bodyW / 2,
          bodyL,
          bodyW,
          Math.min(8, bodyW / 2),
        );
        ctx.fill();
        // nose cone
        ctx.fillStyle = "hsl(210 30% 60%)";
        ctx.beginPath();
        ctx.arc(x + bodyL * 0.48, y, bodyW * 0.5, -Math.PI / 2, Math.PI / 2);
        ctx.fill();
        // wings
        ctx.fillStyle = "hsl(210 25% 70%)";
        ctx.beginPath();
        ctx.moveTo(x - bodyL * 0.05, y - bodyW * 1.2);
        ctx.lineTo(x + bodyL * 0.15, y);
        ctx.lineTo(x - bodyL * 0.05, y + bodyW * 1.2);
        ctx.closePath();
        ctx.fill();
        // tail
        ctx.fillStyle = "hsl(210 20% 65%)";
        ctx.fillRect(
          x - bodyL * 0.48,
          y - bodyW * 0.2,
          bodyL * 0.12,
          bodyW * 0.4,
        );
      });
      animRafRef.current = requestAnimationFrame(draw);
    };

    animRafRef.current = requestAnimationFrame(draw);
    return () => {
      if (animRafRef.current) cancelAnimationFrame(animRafRef.current);
      animRafRef.current = null;
    };
  }, [origin.x, origin.y, viewW, viewH, cellSize]);

  function roundRect(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    w: number,
    h: number,
    r: number,
  ) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawBlock32(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    w: number,
    h: number,
    fill: string,
    stroke: string,
  ) {
    ctx.save();
    // Block base: rich green — stays fully inside the field (no overlap with walkways)
    const pad = Math.max(1, Math.floor(cellSize * 0.12));
    const innerW = w - pad * 2;
    const innerH = h - pad * 2;
    ctx.fillStyle = fill;
    ctx.fillRect(x + pad, y + pad, innerW, innerH);

    // 6×6 squares = 36 m² per plot block (as requested)
    const cols = 6;
    const rows = 6;
    const tileSize = Math.min(innerW / cols, innerH / rows);
    const gridW = tileSize * cols;
    const gridH = tileSize * rows;
    // Slight right-bias to visually center within the block
    // Exactly centered without shifting toward the road edge
    const offX = x + pad + (innerW - gridW) / 2;
    const offY = y + pad + (innerH - gridH) / 2;

    // Satte Rasenfliesen mit klaren Quadraten und feiner Schattierung
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const tx = offX + c * tileSize;
        const ty = offY + r * tileSize;
        const alt = (r + c) % 2 === 0;
        const gx1 = alt ? "hsl(120 50% 68%)" : "hsl(120 44% 62%)";
        const gx2 = alt ? "hsl(120 48% 64%)" : "hsl(120 42% 58%)";
        const grad = ctx.createLinearGradient(tx, ty, tx, ty + tileSize);
        grad.addColorStop(0, gx1);
        grad.addColorStop(1, gx2);
        ctx.fillStyle = grad;
        ctx.fillRect(
          Math.floor(tx) + 0.5,
          Math.floor(ty) + 0.5,
          Math.ceil(tileSize) - 1,
          Math.ceil(tileSize) - 1,
        );
        // leichte Innenkante
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.lineWidth = Math.max(1, cellSize * 0.03);
        ctx.strokeRect(
          Math.floor(tx) + 0.5,
          Math.floor(ty) + 0.5,
          Math.ceil(tileSize) - 1,
          Math.ceil(tileSize) - 1,
        );
      }
    }

    // Gitterlinien zwischen den Quadraten (kontrastreich)
    ctx.strokeStyle = "hsl(0 0% 86%)";
    ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.06));
    // vertikal
    for (let c = 1; c < cols; c++) {
      const gx = Math.round(offX + c * tileSize) + 0.5;
      ctx.beginPath();
      ctx.moveTo(gx, offY);
      ctx.lineTo(gx, offY + gridH);
      ctx.stroke();
    }
    // horizontal
    for (let r = 1; r < rows; r++) {
      const gy = Math.round(offY + r * tileSize) + 0.5;
      ctx.beginPath();
      ctx.moveTo(offX, gy);
      ctx.lineTo(offX + gridW, gy);
      ctx.stroke();
    }

    // Rahmen um den Block
    ctx.strokeStyle = stroke;
    ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.06));
    ctx.strokeRect(x + pad, y + pad, innerW, innerH);

    ctx.restore();
  }

  return (
    <ScreenContainer
      title={t("map")}
      right={
        <div className="flex items-center gap-1">
          <div className="text-xs text-muted-foreground">
            {" "}
            Price:{" "}
            <span className="font-medium">
              {market?.pricePerM2CHF?.toLocaleString(undefined, {
                maximumFractionDigits: 0,
              })}{" "}
              PPC
            </span>
          </div>
        </div>
      }
    >
      <div className="relative">
        <div className="mt-4 flex items-center justify-between gap-2 flex-wrap">
          {" "}
          <div className="hidden sm:block text-sm text-muted-foreground">
            Zoom {Math.min(6, zoomOutLevel === 5 ? 6 : zoomOutLevel + 1)}/6
          </div>
          <div className="flex gap-2 items-center flex-wrap justify-end w-full sm:w-auto">
            {" "}
            <Button
              size="sm"
              onClick={handleZoomIn}
              disabled={cellSize >= allowedMaxCellSize - 0.5}
            >
              ＋
            </Button>
            <Button size="sm" onClick={handleZoomOut}>
              －
            </Button>
            <Button size="sm" variant="secondary" onClick={centerToUnlock}>
              Reset
            </Button>
            <div className="flex items-center gap-2 flex-wrap">
              <Button
                size="sm"
                variant="secondary"
                onClick={() => setShowFreePlots((v) => !v)}
              >
                {showFreePlots ? t("hideFree") : t("showFree")}
              </Button>
              {mode === "buy" && (
                <div className="inline-flex items-center gap-1 rounded-full border bg-background/80 p-1">
                  <Button
                    size="sm"
                    variant={selectionMode === "tap" ? "default" : "secondary"}
                    onClick={() => {
                      setSelectionMode("tap");
                      setDragRect(null);
                      dragStartRef.current = null;
                      setIsDraggingSelect(false);
                    }}
                  >
                    Tap
                  </Button>
                  <Button
                    size="sm"
                    variant={selectionMode === "drag" ? "default" : "secondary"}
                    onClick={() => {
                      setSelectionMode("drag");
                      setSelected([]);
                      setDragRect(null);
                      dragStartRef.current = null;
                      setIsDraggingSelect(false);
                    }}
                  >
                    Drag
                  </Button>
                </div>
              )}
              <Input
                ref={coordInputRef as any}
                className={`w-24 sm:w-40 transition-shadow ${flashSearch ? "ring-2 ring-primary ring-offset-1" : ""}`}
                placeholder="e.g. 123,456"
                value={coordInput}
                onChange={(e) => setCoordInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") handleCoordSearch();
                }}
              />{" "}
              <Button
                size="icon"
                variant="secondary"
                aria-label="Search"
                onClick={() => {
                  try {
                    coordInputRef.current?.focus();
                    coordInputRef.current?.scrollIntoView({
                      behavior: "smooth",
                      block: "nearest",
                      inline: "nearest",
                    });
                    setFlashSearch(true);
                    window.setTimeout(() => setFlashSearch(false), 1500);
                  } catch {}
                }}
                title="Search"
              >
                <Search className="h-4 w-4" />
              </Button>
              <Button
                size="default"
                variant="default"
                className="rounded-full px-4 py-2 ml-1 sm:ml-2"
                onClick={() => {
                  if (isGuest) {
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                    return;
                  }
                  setMyHighlightUntil(Date.now() + 5000);
                  setMyListOpen(true);
                }}
              >
                My m²
              </Button>
            </div>
          </div>
        </div>
        {/* Status legend */}
        <div className="mt-2 flex items-center justify-center">
          <div className="flex flex-wrap justify-center gap-2 rounded-full border bg-background/80 px-3 py-1 text-[11px]">
            {(
              [
                { label: "Available collectible", color: "hsl(var(--free))" },
                { label: "Owned by others", color: "hsl(var(--owned))" },
                { label: "My collectible", color: "hsl(var(--owned-mine))" },
              ] as const
            ).map((it) => (
              <div key={it.label} className="flex items-center gap-1">
                <span
                  className="inline-block"
                  style={{
                    width: 14,
                    height: 14,
                    borderRadius: 5,
                    background:
                      "linear-gradient(180deg, hsl(118 46% 44%), hsl(118 44% 40%))",
                    padding: 2,
                    boxShadow: "inset 0 0 0 1px rgba(255,255,255,0.10)",
                  }}
                >
                  <span
                    className="block"
                    style={{
                      width: "100%",
                      height: "100%",
                      borderRadius: 4,
                      backgroundColor: it.color,
                    }}
                  />
                </span>
                <span className="text-muted-foreground">{it.label}</span>
              </div>
            ))}
          </div>
        </div>
        {/* Mode switch: Browse / Buy / Sell */}{" "}
        <div className="mt-2 w-full flex justify-center">
          <div className="pointer-events-auto inline-flex items-center gap-1 p-1 rounded-full border bg-background shadow-sm">
            <Button
              size="sm"
              variant={mode === "buy" ? "default" : "secondary"}
              onClick={() => {
                const params = new URLSearchParams(searchParams);
                params.set("buy", "1");
                params.delete("sell");
                params.delete("list");
                setSearchParams(params);
              }}
            >
              Buy
            </Button>
            <Button
              size="sm"
              variant={
                mode === "sell" || mode === "list" ? "default" : "secondary"
              }
              onClick={() => {
                const params = new URLSearchParams(searchParams);
                params.set("list", "1");
                params.delete("buy");
                params.delete("sell");
                setSearchParams(params);
                try {
                  setListDrawerOpen(true);
                } catch {}
              }}
            >
              Sell
            </Button>{" "}
          </div>
        </div>
        {false && (
          <div className="mt-2">
            <div className="rounded-xl bg-background/90 border shadow-sm p-3 sm:p-4 text-sm flex flex-col sm:flex-row items-center justify-between gap-2">
              <div className="text-center sm:text-left">
                Buy your first m² to zoom in and explore the island.
              </div>
              <div className="flex items-center gap-2">
                <Button size="sm" onClick={() => navigate("/topup")}>
                  Add credit{" "}
                </Button>
                <Button
                  size="sm"
                  variant="secondary"
                  onClick={() => navigate("/")}
                >
                  Go to Market
                </Button>
              </div>
            </div>
          </div>
        )}
        {/* Buy mode hint for quick onboarding (dismissible, mobile-friendly) */}
        {mode === "buy" && <BuyHint />}
        <div
          ref={viewportRef}
          className="mt-3 rounded-lg overflow-hidden w-full relative touch-pan-x touch-pan-y"
          style={{
            height: "68vh",
            touchAction: "none",
            contain: "layout paint" as any,
          }}
          onDoubleClick={(e) => {
            e.preventDefault();
            if (zoomCooldownRef.current) return;
            try {
              zoomAtClientPoint(e.clientX, e.clientY);
            } catch {}
          }}
          onWheel={(e) => {
            // Two-finger trackpad scroll pans the map; pinch-zoom (ctrlKey=true) zooms
            e.preventDefault();
            if (e.ctrlKey) {
              if (zoomCooldownRef.current) return;
              const delta = e.deltaY; // >0 out, <0 in
              if (delta > 0 && cellSize <= minCellSizeAllowed + 0.5) return;
              const factor = Math.exp(-delta / 520);
              const desired = Math.max(
                minCellSizeAllowed,
                Math.min(allowedMaxCellSize, cellSize * factor),
              );
              if (Math.abs(desired - cellSize) < 0.01) return;
              // Smooth zoom animation around pointer position
              animateZoomTo(desired, e.clientX, e.clientY);
              return;
            } // Panning with two-finger scroll
            const carry = (wheelCarryRef.current = wheelCarryRef.current || {
              x: 0,
              y: 0,
            });
            carry.x += e.deltaX;
            carry.y += e.deltaY;
            let stepX = 0;
            let stepY = 0;
            if (Math.abs(carry.x) >= cellSize) {
              stepX = -Math.trunc(carry.x / cellSize);
              carry.x -= -stepX * cellSize;
            }
            if (Math.abs(carry.y) >= cellSize) {
              stepY = -Math.trunc(carry.y / cellSize);
              carry.y -= -stepY * cellSize;
            }
            if (stepX || stepY) {
              wheelPanAccRef.current.x += stepX;
              wheelPanAccRef.current.y += stepY;
              if (wheelPanRafRef.current == null) {
                wheelPanRafRef.current = window.requestAnimationFrame(() => {
                  const dxCells = wheelPanAccRef.current.x;
                  const dyCells = wheelPanAccRef.current.y;
                  wheelPanAccRef.current = { x: 0, y: 0 };
                  wheelPanRafRef.current = null;
                  if (dxCells || dyCells) {
                    setOrigin((prev) =>
                      clampOriginToWorld({
                        x: prev.x + dxCells,
                        y: prev.y + dyCells,
                      }),
                    );
                  }
                });
              }
            }
          }}
          onPointerDown={onViewportPointerDown}
          onPointerMove={onViewportPointerMove}
          onPointerUp={onViewportPointerUp}
          onPointerCancel={onViewportPointerUp}
        >
          {" "}
          {/* Underlay fill to avoid any visible gaps at edges during panning */}
          <div
            className="absolute inset-0 pointer-events-none"
            style={{ backgroundColor: "hsl(var(--map-bg))" }}
            aria-hidden
          />{" "}
          {/* Loading / error overlay: keep visible until map data + background are ready */}
          {showMapLoadingOverlay && (
            <div className="absolute inset-0 z-[90]">
              <AppSpinner fullScreen={false} label="Loading map" />
            </div>
          )}
          {showMapErrorOverlay && (
            <div className="absolute inset-0 z-[90] flex flex-col items-center justify-center gap-3 bg-background/85 backdrop-blur-sm p-6 text-center">
              <div className="text-sm font-medium">Could not load the map</div>
              <div className="text-xs text-muted-foreground max-w-[320px] break-words">
                {(mapError as any)?.message ?? "Please try again."}
              </div>
              <div className="flex items-center gap-2">
                <Button
                  size="sm"
                  onClick={() => {
                    try {
                      void refetch();
                    } catch {}
                  }}
                >
                  Try again
                </Button>
                <Button
                  size="sm"
                  variant="secondary"
                  onClick={() => {
                    try {
                      // quick recovery: allow next request sooner
                      mapCooldownUntilRef.current = 0;
                    } catch {}
                  }}
                >
                  OK
                </Button>
              </div>
            </div>
          )}
          {/* Subtle hint when current zoom hit the cap for the user (but > 0 m²) */}
          {false && cellSize >= allowedMaxCellSize - 0.5 && (
            <div className="absolute left-1/2 -translate-x-1/2 bottom-3 z-30">
              <div className="rounded-full bg-background/90 border px-3 py-1 text-xs shadow-sm">
                More zoom with more land owned ·{" "}
                <button className="underline" onClick={() => navigate("/")}>
                  Buy
                </button>
              </div>
            </div>
          )}
          {/* Overlay: Roads and Cars canvases for new map design */}
          <canvas
            ref={roadsCanvasRef}
            className="absolute inset-0 pointer-events-none"
            style={{
              width: viewW * cellSize,
              height: viewH * cellSize,
              willChange: "transform",
            }}
          />
          <canvas
            ref={carsCanvasRef}
            className="absolute inset-0 pointer-events-none"
            style={{
              width: viewW * cellSize,
              height: viewH * cellSize,
              willChange: "transform",
            }}
          />
          {/* Large Area overlay (shown when far zoomed out) */}
          <canvas
            ref={areasCanvasRef}
            className="absolute inset-0 pointer-events-none"
            style={{
              width: viewW * cellSize,
              height: viewH * cellSize,
              willChange: "transform",
            }}
          />
          {/* Drag selection overlay removed: handled via viewport pointer events so pinch-zoom still works */}
          {/* Drag rectangle visual */}
          {dragRect && (
            <div
              className="absolute z-[86] pointer-events-none"
              style={{
                left: dragRect.x,
                top: dragRect.y,
                width: dragRect.w,
                height: dragRect.h,
                border: "2px dashed hsla(var(--owned), 0.95)",
                background: "hsla(var(--owned), 0.20)",
                borderRadius: 6,
              }}
            />
          )}
          {/* Unlocked green grid backdrop + outside dim (anchored to user-specific center) */}
          {false &&
            (() => {
              const totalW = viewW * cellSize;
              const totalH = viewH * cellSize;
              // Use a stable per-user center: first owned (anchor) or deterministic seed position
              const anchor = myAnchor ?? stableStartRef.current;
              if (!anchor) return null;
              const centerWX = Math.floor(anchor!.x);
              const centerWY = Math.floor(anchor!.y);
              const side = unlockedSide;
              const minX = centerWX - Math.floor(side / 2);
              const minY = centerWY - Math.floor(side / 2);
              // In pixels, relative to the viewport cell
              let leftPx = (minX - origin.x) * cellSize;
              let topPx = (minY - origin.y) * cellSize;
              let wPx = side * cellSize;
              let hPx = side * cellSize;
              // Clamp in case the area is partially outside
              const clamp = (v: number, lo: number, hi: number) =>
                Math.max(lo, Math.min(hi, v));
              const l = clamp(leftPx, 0, totalW);
              const t = clamp(topPx, 0, totalH);
              const r = clamp(leftPx + wPx, 0, totalW);
              const b = clamp(topPx + hPx, 0, totalH);
              const L = l,
                T = t,
                W = Math.max(0, r - l),
                H = Math.max(0, b - t);
              return (
                <div
                  className="absolute inset-0 pointer-events-none"
                  style={{ zIndex: 40 }}
                >
                  {/* Green grid area */}
                  <div
                    className="rounded-[22px]"
                    style={{
                      position: "absolute",
                      left: L,
                      top: T,
                      width: W,
                      height: H,
                      backgroundColor: "hsla(var(--owned), 0.20)",
                      backgroundImage: `linear-gradient(to right, hsla(var(--owned), 0.55) 1px, transparent 1px), linear-gradient(to bottom, hsla(var(--owned), 0.55) 1px, transparent 1px)`,
                      backgroundSize: `${cellSize}px ${cellSize}px, ${cellSize}px ${cellSize}px`,
                      boxShadow:
                        "0 0 0 1px hsla(var(--owned), 0.4) inset, 0 0 0 1px hsla(var(--owned), 0.3)",
                    }}
                  />
                  {/* Gestrichelte Kontur */}
                  <div
                    className="rounded-[22px]"
                    style={{
                      position: "absolute",
                      left: L,
                      top: T,
                      width: W,
                      height: H,
                      border: "1px dashed",
                      borderColor: "hsla(var(--owned), 0.7)",
                    }}
                  />
                  {/* Dim outside area */}
                  <div
                    style={{
                      position: "absolute",
                      left: 0,
                      top: 0,
                      width: "100%",
                      height: T,
                      backgroundColor: "rgba(0,0,0,0.45)",
                    }}
                  />
                  <div
                    style={{
                      position: "absolute",
                      left: 0,
                      top: T,
                      width: L,
                      height: H,
                      backgroundColor: "rgba(0,0,0,0.45)",
                    }}
                  />
                  <div
                    style={{
                      position: "absolute",
                      left: L + W,
                      top: T,
                      width: Math.max(0, totalW - (L + W)),
                      height: H,
                      backgroundColor: "rgba(0,0,0,0.45)",
                    }}
                  />
                  <div
                    style={{
                      position: "absolute",
                      left: 0,
                      top: T + H,
                      width: "100%",
                      height: Math.max(0, totalH - (T + H)),
                      backgroundColor: "rgba(0,0,0,0.45)",
                    }}
                  />

                  {/* BUY TO UNLOCK Labels */}
                  {(() => {
                    const showLabels = W < totalW || H < totalH;
                    if (!showLabels) return null;
                    const reservedBottom = Math.max(
                      110,
                      Math.floor(cellSize * 3),
                    );
                    return (
                      <>
                        <div
                          style={{
                            position: "absolute",
                            left: 0,
                            right: 0,
                            top: Math.max(58, T - 42),
                            textAlign: "center",
                            color: "white",
                            fontWeight: 900,
                            letterSpacing: 0.5,
                            textShadow: "0 1px 2px rgba(0,0,0,0.45)",
                            fontSize: Math.min(28, 12 + zoomOutLevel * 2),
                            pointerEvents: "none",
                          }}
                        >
                          BUY TO UNLOCK
                        </div>
                        <div
                          style={{
                            position: "absolute",
                            left: L + W + 8,
                            top: Math.min(
                              Math.max(T + H / 2 - 14, 58),
                              totalH - reservedBottom,
                            ),
                            right: 8,
                            textAlign: "left",
                            color: "white",
                            fontWeight: 900,
                            textShadow: "0 1px 2px rgba(0,0,0,0.45)",
                            fontSize: Math.min(28, 12 + zoomOutLevel * 2),
                            pointerEvents: "none",
                          }}
                        >
                          BUY TO UNLOCK
                        </div>
                        <div
                          style={{
                            position: "absolute",
                            left: 0,
                            right: 0,
                            top: Math.min(T + H + 36, totalH - reservedBottom),
                            textAlign: "center",
                            color: "white",
                            fontWeight: 900,
                            textShadow: "0 2px 6px rgba(0,0,0,0.5)",
                            fontSize: Math.min(42, 18 + zoomOutLevel * 4),
                            pointerEvents: "none",
                          }}
                        >
                          BUY TO UNLOCK
                        </div>
                      </>
                    );
                  })()}
                </div>
              );
            })()}{" "}
          {/* Grid overlay removed in classic mode to avoid any chance of double-rendering/overlap */}
          <div
            ref={gridOverlayRef}
            className="absolute inset-0 pointer-events-none"
            style={{
              width: viewW * cellSize,
              height: viewH * cellSize,
              display: useClassicMap ? "none" : "block",
              backgroundImage: "none",
              backgroundSize: `${cellSize}px ${cellSize}px, ${cellSize}px ${cellSize}px`,
              backgroundColor: "transparent",
              zIndex: 1,
              willChange: "transform",
            }}
          />
          {/* Local mini-unlock masks (3×3 around each owned m²) */}{" "}
          {false &&
            (() => {
              const myOwned = (data?.cells ?? []).filter(
                (c: any) => c.ownedByMe,
              );
              if (!myOwned.length) return null;
              return (
                <div
                  className="absolute inset-0 pointer-events-none"
                  style={{ zIndex: 42 }}
                >
                  {myOwned.map((c: any, idx: number) => {
                    const L = (c.x - 1 - origin.x) * cellSize;
                    const T = (c.y - 1 - origin.y) * cellSize;
                    const W = 3 * cellSize;
                    const H = 3 * cellSize;
                    if (
                      L > viewW * cellSize ||
                      T > viewH * cellSize ||
                      L + W < 0 ||
                      T + H < 0
                    )
                      return null;
                    return (
                      <div
                        key={`mini-${idx}`}
                        className="absolute rounded-[14px]"
                        style={{ left: L, top: T, width: W, height: H }}
                      >
                        <div
                          className="absolute inset-0 rounded-[14px]"
                          style={{
                            backgroundColor: "hsla(var(--owned), 0.20)",
                            boxShadow:
                              "0 0 0 1px hsla(var(--owned), 0.4) inset, 0 0 0 1px hsla(var(--owned), 0.3)",
                          }}
                        />
                      </div>
                    );
                  })}
                </div>
              );
            })()}
          {/* Grid (cells) */}
          <div
            ref={gridRef}
            className="relative"
            style={{
              width: viewW * cellSize,
              height: viewH * cellSize,
              willChange: "transform",
              pointerEvents: isInteracting ? "none" : "auto",
            }}
          >
            {/* Flash highlight for focused cell */}
            {flash &&
            Date.now() < flash.until &&
            flash.x >= origin.x &&
            flash.x < origin.x + viewW &&
            flash.y >= origin.y &&
            flash.y < origin.y + viewH
              ? (() => {
                  const px = (flash.x - origin.x) * cellSize;
                  const py = (flash.y - origin.y) * cellSize;
                  const sz = cellSize;
                  return (
                    <div
                      className="pointer-events-none absolute z-[60]"
                      style={{
                        left: px - 2,
                        top: py - 2,
                        width: sz + 4,
                        height: sz + 4,
                        borderRadius: Math.max(5, Math.round(sz * 0.22)),
                        border: `${Math.max(2, Math.round(sz * 0.06))}px solid rgba(59,130,246,0.95)`,
                        boxShadow: "none",
                        background: "transparent",
                      }}
                    />
                  );
                })()
              : null}
            {mode === "browse" &&
            infoTip &&
            Date.now() < infoTip.until &&
            infoTip.x >= origin.x &&
            infoTip.x < origin.x + viewW &&
            infoTip.y >= origin.y &&
            infoTip.y < origin.y + viewH
              ? (() => {
                  const px = (infoTip.x - origin.x) * cellSize;
                  const py = (infoTip.y - origin.y) * cellSize;
                  const left = px + cellSize / 2;
                  const top = py;
                  const cell = allCells.find(
                    (c: any) => c.x === infoTip.x && c.y === infoTip.y,
                  );
                  if (!cell) return null;
                  const kNum = cellKey(infoTip.x, infoTip.y);
                  const isListed =
                    listedKeys.has(kNum) || optimisticHiddenKeys.has(kNum);
                  const owned = !!cell.ownerId;
                  const ownedByMe = !!cell.ownedByMe;
                  const isLand = isAllowedLotWorld(infoTip.x, infoTip.y);
                  const isFree = !owned && !isListed && isLand;
                  const pricePer =
                    typeof (market as any)?.pricePerM2CHF === "number"
                      ? Number((market as any).pricePerM2CHF)
                      : 0;
                  const listing = (activeListings ?? []).find(
                    (l: any) => l.x === infoTip.x && l.y === infoTip.y,
                  );

                  const isAuthed = auth.status === "authenticated" && !isGuest;
                  const wallet =
                    isAuthed &&
                    profile &&
                    typeof (profile as any).balance === "number"
                      ? Number((profile as any).balance)
                      : null;

                  const statusLabel = !isLand
                    ? "Not buyable"
                    : ownedByMe
                      ? "My collectible"
                      : owned
                        ? "Owned by others"
                        : "Available collectible";

                  return (
                    <div
                      className="pointer-events-auto absolute z-[70]"
                      style={{ left, top, transform: "translate(-50%,-115%)" }}
                    >
                      <div className="rounded-md border bg-background/95 text-foreground text-[11px] px-2 py-1 shadow min-w-[140px]">
                        <div className="font-medium truncate">
                          {statusLabel}
                        </div>{" "}
                        {isLand && (
                          <div className="text-muted-foreground">
                            Price: {currencyUSD(pricePer)} / m²
                          </div>
                        )}
                        {listing && isLand && (
                          <div className="text-muted-foreground">
                            2nd Market: {currencyUSD(listing.priceEUR)}
                          </div>
                        )}
                        <div className="text-muted-foreground">
                          Coordinate: ({infoTip.x},{infoTip.y})
                        </div>
                        <div className="text-muted-foreground">
                          Wallet:{" "}
                          {wallet === null ? "Sign in" : currencyUSD(wallet)}
                        </div>
                        {!isFree && !ownedByMe && isLand && (
                          <div className="mt-1 text-[10px] text-muted-foreground">
                            This m² is already taken.
                          </div>
                        )}
                        {ownedByMe && (
                          <div className="mt-1 space-y-1">
                            <div className="text-[10px] text-muted-foreground">
                              This m² is your m².
                            </div>
                            <Button
                              size="sm"
                              variant="secondary"
                              className="w-full"
                              onClick={(e) => {
                                e.stopPropagation();
                                void openCertificateFor(infoTip.x, infoTip.y);
                              }}
                            >
                              Open certificate
                            </Button>
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })()
              : null}
            {viewportPositions.map(({ key: vpKey, col, row }) => {
              const worldX = origin.x + col;
              const worldY = origin.y + row;
              const kNum = cellKey(worldX, worldY);
              const isLand = isAllowedLotWorld(worldX, worldY);

              // Sea/outside: don't render tiles at all (big perf win at far zoom levels)
              if (!isLand) return null;

              const cell = cellMap.get(kNum) as any;
              const x = col * cellSize;
              const y = row * cellSize;

              // If we don't have data for this viewport position yet (because we're between fetch anchors),
              // render a lightweight placeholder so the DOM stays stable and panning remains smooth.
              if (!cell) {
                const inset = Math.max(2, Math.round(cellSize * 0.18));
                const innerSize = Math.max(0, cellSize - inset * 2);
                const innerRadius = Math.max(2, Math.round(innerSize * 0.18));
                return (
                  <div
                    key={vpKey}
                    className="absolute"
                    style={{
                      left: x,
                      top: y,
                      width: cellSize,
                      height: cellSize,
                      borderRadius: Math.max(5, Math.round(cellSize * 0.22)),
                      background:
                        "linear-gradient(180deg, hsl(118 46% 44%), hsl(118 44% 40%))",
                      boxShadow:
                        "inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 -1px 0 rgba(0,0,0,0.08)",
                      pointerEvents: "none",
                      opacity: 0.85,
                    }}
                  >
                    <div
                      className="absolute"
                      style={{
                        left: inset,
                        top: inset,
                        width: innerSize,
                        height: innerSize,
                        borderRadius: innerRadius,
                        backgroundColor: "hsl(var(--free))",
                      }}
                    />
                  </div>
                );
              }

              const isListed =
                listedKeys.has(kNum) || optimisticHiddenKeys.has(kNum);
              // Hide plots that are currently listed on the 2nd market

              const pulseNow =
                mode === "sell" && !!sellPulse[`${cell.x}:${cell.y}`];
              const owned = !!cell.ownerId;
              // Hide unowned tiles unless we are actively in buy mode (so users can pick free plots)
              // Determine unlocked window (viewport-zentriert) basierend auf owned m²
              const insideWindow = true;

              if (!insideWindow) {
                // Locked area: show as grey and non-interactive; tap leads to top-up
                return (
                  <div
                    key={vpKey}
                    className="absolute rounded-[4px] bg-muted/30"
                    style={{
                      left: x,
                      top: y,
                      width: cellSize,
                      height: cellSize,
                    }}
                    title="Buy to unlock"
                    onClick={() => {
                      if (!isAllowedLotWorld(worldX, worldY)) {
                        toast({
                          title: "Not possible",
                          description: "You can only buy within the island.",
                        });
                        return;
                      }
                      navigate("/topup");
                    }}
                  />
                );
              }

              // Hide free plots in browse mode unless the user explicitly turns them on.
              if (!owned && mode === "browse" && !showFreePlots) return null;

              // Always render free plots while in buy mode so the map remains tappable.
              // Color code by house type and ownership
              const ownedByMe = !!cell.ownerId && cell.ownedByMe;
              const isSelected = selectedKeys.has(kNum);
              /* color classes removed; we now render status via inner inlay to keep grid lines visible */
              return (
                <div
                  key={vpKey}
                  className="absolute"
                  style={{
                    left: x,
                    top: y,
                    width: cellSize,
                    height: cellSize,
                    // Outer tile look (rounded, slightly 3D)
                    borderRadius: Math.max(5, Math.round(cellSize * 0.22)),
                    background:
                      "linear-gradient(180deg, hsl(118 46% 44%), hsl(118 44% 40%))",
                    boxShadow: isInteracting
                      ? "inset 0 0 0 1px rgba(255,255,255,0.08)"
                      : "inset 0 0 0 1px rgba(255,255,255,0.10), inset 0 -1px 0 rgba(0,0,0,0.10)",
                    outline:
                      pulseNow || isSelected
                        ? `${Math.max(2, Math.round(cellSize * 0.06))}px solid rgba(59,130,246,0.95)`
                        : "none",
                    outlineOffset: -1,
                    opacity:
                      mode === "list" ? (ownedByMe ? 1 : 0.18) : undefined,
                    pointerEvents: "auto",
                    zIndex:
                      pulseNow || isSelected
                        ? 60
                        : mode === "list"
                          ? ownedByMe
                            ? 2
                            : 1
                          : undefined,
                    filter:
                      mode === "list" && !ownedByMe
                        ? "grayscale(0.4) saturate(0.7)"
                        : undefined,
                    cursor: isListed
                      ? mode === "sell" && ownedByMe
                        ? "pointer"
                        : "not-allowed"
                      : mode === "buy"
                        ? !owned && isAllowedLotWorld(worldX, worldY)
                          ? "pointer"
                          : "not-allowed"
                        : mode === "sell"
                          ? ownedByMe
                            ? "pointer"
                            : "not-allowed"
                          : mode === "list"
                            ? ownedByMe
                              ? "pointer"
                              : "not-allowed"
                            : undefined,
                  }}
                  onClick={() => {
                    const isProtected = !isAllowedLotWorld(worldX, worldY);
                    if (selectedBuildType) {
                      if (isProtected) {
                        toast({
                          title: "Not on water",
                          description:
                            "Building is only possible on land within the island.",
                        });
                        return;
                      }
                      if (!cell.ownedByMe) {
                        toast({
                          title: "Only your own plots",
                          description: "Tap one of your own free plots.",
                        });
                        return;
                      }
                      if (owned && cell.houseType !== "NONE") {
                        toast({
                          title: "Plot occupied",
                          description: "Select a free plot without a house.",
                        });
                        return;
                      }
                      openConfirm(cell.x, cell.y, selectedBuildType);
                      return;
                    }
                    // In browse mode we show the info card first; the certificate can be opened from there.
                    if (false) {
                      if (owned && cell.ownedByMe) openHouseSheet(cell);
                    } else if (mode === "list") {
                      if (!cell.ownedByMe) {
                        toast({
                          title: "Only your own plots",
                          description:
                            "Select one of your own plots to sell it.",
                        });
                        return;
                      }
                      const key = `${cell.x}:${cell.y}`;
                      setSelected((prev) => {
                        const exists = prev.find(
                          (c) => c.x === cell.x && c.y === cell.y,
                        );
                        if (exists) {
                          const next = prev.filter(
                            (c) => !(c.x === cell.x && c.y === cell.y),
                          );
                          setListPrices((p) => {
                            const cp = { ...p };
                            delete cp[key];
                            return cp;
                          });
                          return next;
                        } else {
                          setListPrices((p) => ({
                            ...p,
                            [key]:
                              p[key] ??
                              String(
                                Math.round((market?.pricePerM2CHF ?? 0) * 100) /
                                  100,
                              ),
                          }));
                          return [...prev, { x: cell.x, y: cell.y }];
                        }
                      });
                    } else {
                      {
                        const listing = (activeListings ?? []).find(
                          (l: any) => l.x === cell.x && l.y === cell.y,
                        );
                        const isLand = isAllowedLotWorld(worldX, worldY);
                        const status = !isLand
                          ? "Not buyable (outside the island)"
                          : !owned
                            ? "Free (available to buy)"
                            : cell.ownedByMe
                              ? "Your plot"
                              : "Occupied (someone else)";
                        const sub =
                          listing && isLand
                            ? `2nd Market: ${currencyUSD(listing.priceEUR)}`
                            : undefined;
                        setInfoTip({
                          x: cell.x,
                          y: cell.y,
                          until: Date.now() + 20000,
                          text: status,
                          sub,
                        });
                        if (mode === "sell" && cell.ownedByMe) {
                          pulseRing(cell.x, cell.y);
                        }
                      }

                      // Browse mode: don't add to selection, just show the info card
                      if (mode === "browse") return;

                      if (isProtected) {
                        if (mode === "buy") {
                          toast({
                            title: "Not on water",
                            description:
                              "Buying is only possible on land within the island.",
                          });
                        }
                        return;
                      }
                      if (
                        mode === "buy" &&
                        !isAllowedLotWorld(worldX, worldY)
                      ) {
                        toast({
                          title: "Only 6×6 plots",
                          description:
                            "Please choose a position within the island.",
                        });
                        return;
                      }
                      toggleSelect(cell.x, cell.y, owned, cell.ownedByMe);
                    }
                  }}
                  title={
                    `${cell.x},${cell.y} • ${cell.houseType}` +
                    (isListed ? " • listed (2nd Market)" : "") +
                    (mode === "buy" && !isAllowedLotWorld(worldX, worldY)
                      ? " • water / blocked"
                      : "")
                  }
                >
                  {/* Color inlay: interior only so the canvas lines (seams) stay visible */}
                  {(() => {
                    const inset = Math.max(2, Math.round(cellSize * 0.18));
                    const innerSize = Math.max(0, cellSize - inset * 2);
                    const innerRadius = Math.max(
                      2,
                      Math.round(innerSize * 0.18),
                    );

                    const isLand = isAllowedLotWorld(worldX, worldY);

                    // Status fill (as requested): Available / Collectible (listed) / Owned by others / My collectible
                    const fill = (() => {
                      if (!isLand) return "transparent";
                      // Only 3 green types: Available, Owned by others, My collectible
                      if (ownedByMe) return "hsl(var(--owned-mine))";
                      if (owned) return "hsl(var(--owned))";
                      // Treat listed plots as "available" here (most are hidden anyway)
                      return "hsl(var(--free))";
                    })();
                    return (
                      <>
                        <div
                          className="absolute"
                          style={{
                            left: inset,
                            top: inset,
                            width: innerSize,
                            height: innerSize,
                            borderRadius: innerRadius,
                            backgroundColor: fill,
                            boxShadow:
                              ownedByMe && useClassicMap
                                ? "0 0 0 2px rgba(255,255,255,0.20) inset"
                                : undefined,
                          }}
                        />
                      </>
                    );
                  })()}
                </div>
              );
            })}
          </div>
          {/* Overlay: ensure my owned plots are always visible in the viewport */}
          {Array.isArray(myPlots) &&
            myPlots.length > 0 &&
            (myListOpen || myHighlightUntil > Date.now()) && (
              <div className="absolute inset-0 pointer-events-none z-[55]">
                {myPlots.map((p: any, idx: number) => {
                  if (
                    p.x < origin.x ||
                    p.x >= origin.x + viewW ||
                    p.y < origin.y ||
                    p.y >= origin.y + viewH
                  )
                    return null;
                  const left = (p.x - origin.x) * cellSize;
                  const top = (p.y - origin.y) * cellSize;
                  const sz = cellSize;
                  return (
                    <div
                      key={`mine-${idx}`}
                      className="absolute rounded-[4px]"
                      style={{
                        left,
                        top,
                        width: sz,
                        height: sz,
                        background: "transparent",
                        boxShadow:
                          "0 0 0 2px rgba(255,255,255,0.95), 0 0 12px rgba(0,0,0,0.35)",
                      }}
                    />
                  );
                })}
              </div>
            )}
          {/* Subtile BUY TO UNLOCK‑Hinweise statt Vollbild-Blocker (nur im Startzustand ohne Besitz) */}{" "}
          {false && ownedM2State <= 0 && <div />}
        </div>
        <div className="mt-3 text-sm text-muted-foreground">
          {t("mode")}:{" "}
          <span className="font-medium">
            {mode === "browse"
              ? "Browse"
              : mode === "buy"
                ? `Buy (target ${buyTarget || "–"} m²)`
                : mode === "sell"
                  ? `Sell (target ${sellTarget || "–"} m²)`
                  : "2nd Market: select a tile & set a price"}
          </span>
        </div>
        <div className="text-sm text-muted-foreground">
          Selected: <span className="font-medium">{selected.length}</span>{" "}
          plot(s)
          {mode === "buy" && (
            <>
              {" "}
              • m²: <span className="font-medium">{selected.length}</span> •
              Kosten:{" "}
              <span className="font-medium">
                {currencyUSD(
                  simBuy?.totalCostCHF ??
                    (market?.pricePerM2CHF ?? 0) * selected.length,
                )}
              </span>
            </>
          )}
          {mode === "sell" && (
            <>
              {" "}
              • {t("net")}:{" "}
              <span className="font-medium">
                {currencyUSD(simSell?.netCHF)}
              </span>
            </>
          )}
        </div>
        {mode === "list" && selected.length > 0 && (
          <Button
            className="mt-2 w-full"
            onClick={() => {
              if (isGuest) {
                try {
                  window.dispatchEvent(new Event("openSignIn"));
                } catch {}
                return;
              }
              setListDrawerOpen(true);
            }}
          >
            {`Create listings (${selected.length})`}
          </Button>
        )}{" "}
        {showSuccessOverlay && (
          <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/40 backdrop-blur-sm">
            <div className="success-pop rounded-full w-28 h-28 bg-background border-4 border-green-500 flex items-center justify-center shadow-xl">
              <CheckCircle2 className="h-16 w-16 text-green-500" />
            </div>
          </div>
        )}
        {/* Buy success info (same as Quick Buy) */}
        <Dialog
          open={mapBuySuccessOpen}
          onOpenChange={(v) => {
            // If user closes it, we still focus the bought area (same as Weiter)
            if (!v && mapBuySuccessOpen) {
              proceedAfterMapBuySuccess();
              return;
            }
            setMapBuySuccessOpen(!!v);
          }}
        >
          <DialogContent className="w-[calc(100vw-20px)] max-w-[440px] p-4 sm:p-6 max-h-[80vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle className="text-lg sm:text-xl font-extrabold tracking-tight">
                <span className="text-muted-foreground">NEW</span>{" "}
                {mapBuySuccessM2.toLocaleString()} m² (Main Market)
              </DialogTitle>
              <DialogDescription className="text-sm sm:text-base leading-snug text-foreground">
                <ol className="mt-3 list-decimal pl-5 space-y-1.5">
                  <li>Build islands (from +2 m²)</li>
                  <li>Usable instantly &amp; sellable</li>
                  <li>Fully flexible: buy / sell / build</li>
                  <li>For expansion &amp; growth</li>
                  <li>Faster progress</li>
                </ol>
              </DialogDescription>
            </DialogHeader>
            <DialogFooter className="mt-4">
              <Button
                className="w-full rounded-full text-sm sm:text-base py-5"
                onClick={proceedAfterMapBuySuccess}
              >
                Continue
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
        {/* Build picker & compact buy button without overlap */}
        <div className="fixed bottom-16 inset-x-0 z-[70] flex justify-center pointer-events-none">
          <div className="flex flex-col gap-2 items-center">
            <div className="flex gap-2 items-center pointer-events-auto"></div>

            {mode === "buy" && selected.length > 0 && (
              <Button
                variant="default"
                className="w-[min(92vw,680px)] sm:w-auto px-12 py-6 text-xl sm:px-14 sm:py-7 sm:text-2xl rounded-2xl shadow-lg pointer-events-auto"
                disabled={buyMutation.isLoading}
                onClick={() => {
                  if (isGuest) {
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                    return;
                  }
                  selectedRef.current = selected;
                  setMainBuyInfo({
                    m2: selected.length,
                    totalEUR: currencyUSD(
                      simBuy?.totalCostCHF ??
                        (market?.pricePerM2CHF ?? 0) * selected.length,
                    ),
                  });
                }}
              >
                {buyMutation.isLoading
                  ? "Buying..."
                  : `Buy (${selected.length} m² • ${currencyUSD(
                      simBuy?.totalCostCHF ??
                        (market?.pricePerM2CHF ?? 0) * selected.length,
                    )})`}
              </Button>
            )}
            {mode === "sell" && selected.length > 0 && (
              <Button
                variant="default"
                className="w-[min(92vw,680px)] sm:w-auto px-12 py-6 text-xl sm:px-14 sm:py-7 sm:text-2xl rounded-2xl shadow-lg pointer-events-auto"
                disabled={sellPlotsMutation.isLoading}
                onClick={() => {
                  if (isGuest) {
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                    return;
                  }
                  sellPlotsMutation.mutate({
                    coords: selected,
                    accessToken,
                  } as any);
                }}
              >
                {sellPlotsMutation.isLoading
                  ? "Selling..."
                  : `Sell (${selected.length} m² • Netto ${currencyUSD(
                      simSell?.netCHF ?? 0,
                    )})`}
              </Button>
            )}
          </div>{" "}
        </div>
        {/* My plots drawer */}
        <Drawer open={myListOpen} onOpenChange={setMyListOpen}>
          <DrawerContent>
            <DrawerHeader className="text-left">
              <DrawerTitle>My m²</DrawerTitle>
              <DrawerDescription>Tap to jump directly there.</DrawerDescription>
            </DrawerHeader>
            <div className="px-4 pb-4 max-h-[60vh] overflow-y-auto">
              {!myPlots || myPlots.length === 0 ? (
                <div className="text-sm text-muted-foreground">No entries.</div>
              ) : (
                <div className="grid gap-2">
                  {myPlots.map((p: any, idx: number) => (
                    <Button
                      key={idx}
                      size="sm"
                      variant="secondary"
                      className="w-auto self-start px-3 py-1"
                      onClick={() => {
                        const targetCellSize = Math.min(allowedMaxCellSize, 40);
                        setCellSize((s) =>
                          s < targetCellSize ? targetCellSize : s,
                        );
                        const vw = Math.max(
                          4,
                          Math.floor(viewportSize.w / targetCellSize),
                        );
                        const vh = Math.max(
                          4,
                          Math.floor(viewportSize.h / targetCellSize),
                        );
                        setOrigin(
                          clampOriginToWorld(
                            {
                              x: p.x - Math.floor(vw / 2),
                              y: p.y - Math.floor(vh / 2),
                            },
                            targetCellSize,
                          ),
                        );
                        setFlash({ x: p.x, y: p.y, until: Date.now() + 3000 });
                        setMyHighlightUntil(Date.now() + 5000);
                        setMyListOpen(false);
                      }}
                    >
                      <span>
                        ({p.x},{p.y})
                      </span>
                      <span className="ml-2 text-xs text-muted-foreground">
                        {formatDateTime(p.createdAt)}
                      </span>
                    </Button>
                  ))}
                </div>
              )}
            </div>
            <DrawerFooter>
              <Button variant="secondary" onClick={() => setMyListOpen(false)}>
                Close
              </Button>
            </DrawerFooter>
          </DrawerContent>
        </Drawer>
        {/* Houses removed: build picker deleted */}
        {/* Houses removed: no drag preview */}
        {isFetching && (
          <div className="mt-2 text-xs text-muted-foreground">
            {t("updatingMap")}{" "}
          </div>
        )}
        {/* Houses removed: no house drawer */}
        {/* Houses removed: no build confirmation dialog */}
        {/* Certificate preview from map */}
        <Drawer
          open={!!mapPreviewCert}
          onOpenChange={(v) => !v && setMapPreviewCert(null)}
        >
          <DrawerContent>
            <DrawerHeader className="text-left relative">
              <DrawerTitle>{t("certificateTitle")}</DrawerTitle>
              <DrawerDescription>
                {mapPreviewCert
                  ? `${mapPreviewCert.x !== undefined && mapPreviewCert.y !== undefined ? `(${mapPreviewCert.x},${mapPreviewCert.y}) • ` : ""}${formatDateTime(mapPreviewCert.date)}`
                  : ""}
              </DrawerDescription>
              <DrawerClose asChild>
                <button
                  aria-label={t("close")}
                  className="absolute right-2 top-2 rounded-full p-1 hover:bg-secondary active:scale-95 transition-transform"
                  onClick={() => setMapPreviewCert(null)}
                >
                  <X className="h-4 w-4" />
                </button>
              </DrawerClose>
            </DrawerHeader>
            <div className="px-4 pb-4 flex items-center justify-center">
              <div className="relative w-full max-w-[300px] sm:max-w-[340px]">
                <AspectRatio ratio={210 / 297}>
                  <div className="absolute inset-0 border rounded-lg overflow-hidden bg-card">
                    {templateUrlForMap ? (
                      <img
                        src={templateUrlForMap}
                        alt="Certificate"
                        className="w-full h-full object-contain select-none pointer-events-none"
                        onError={(e: any) => {
                          try {
                            e.currentTarget.style.display = "none";
                          } catch {}
                        }}
                      />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center text-xs text-muted-foreground">
                        No template
                      </div>
                    )}
                    {mapPreviewCert && (
                      <div className="absolute left-2 bottom-2 text-[10px] px-1.5 py-0.5 rounded bg-background/80">
                        {formatDateTime(mapPreviewCert.date)}
                        {mapPreviewCert.x !== undefined &&
                        mapPreviewCert.y !== undefined
                          ? ` • (${mapPreviewCert.x},${mapPreviewCert.y})`
                          : ""}
                      </div>
                    )}
                  </div>
                </AspectRatio>
              </div>
            </div>
            <DrawerFooter className="pt-2 flex gap-2">
              {mapPreviewCert?.x !== undefined &&
                mapPreviewCert?.y !== undefined && (
                  <Button
                    size="sm"
                    className="px-2 py-1 text-xs"
                    onClick={() => {
                      const x = mapPreviewCert!.x as number;
                      const y = mapPreviewCert!.y as number;
                      setMapPreviewCert(null);
                      navigate(`/map?focusX=${x}&focusY=${y}`);
                    }}
                  >
                    On map
                  </Button>
                )}
              <Button
                size="sm"
                variant="secondary"
                className="px-2 py-1 text-xs"
                onClick={() => setMapPreviewCert(null)}
              >
                {t("close")}
              </Button>
            </DrawerFooter>
          </DrawerContent>
        </Drawer>
        {/* Multi listings: select multiple owned m² and set a per-tile price */}
        <Drawer open={listDrawerOpen} onOpenChange={setListDrawerOpen}>
          <DrawerContent>
            <DrawerHeader className="text-left">
              <DrawerTitle>{t("listings")}</DrawerTitle>
              <DrawerDescription>
                {selected.length === 0
                  ? "Select your own tiles on the map."
                  : `Selected: ${selected.length} tile(s)`}
              </DrawerDescription>
            </DrawerHeader>
            <div className="px-4 pb-4 grid gap-3 max-w-[680px] w-full mx-auto">
              {selected.length > 0 ? (
                <div className="grid gap-2 max-h-[50vh] overflow-auto pr-1">
                  {selected.map(({ x, y }) => {
                    const key = `${x}:${y}`;
                    const val =
                      listPrices[key] ??
                      String(
                        Math.round((market?.pricePerM2CHF ?? 0) * 100) / 100,
                      );
                    return (
                      <div
                        key={key}
                        className="grid grid-cols-1 sm:grid-cols-5 items-center gap-2 border rounded p-2"
                      >
                        <div className="text-sm sm:col-span-2">
                          ({x},{y})
                        </div>
                        <div className="sm:col-span-3 grid grid-cols-3 items-center gap-2">
                          <Label className="col-span-1">{t("price")}</Label>
                          <Input
                            className="col-span-2"
                            type="tel"
                            inputMode="decimal"
                            value={val}
                            onChange={(e) =>
                              setListPrices((p) => ({
                                ...p,
                                [key]: e.target.value
                                  .replace(/[^0-9.,]/g, "")
                                  .replace(",", "."),
                              }))
                            }
                            placeholder={
                              market ? String(market.pricePerM2CHF) : "100"
                            }
                          />
                        </div>
                      </div>
                    );
                  })}
                </div>
              ) : (
                <div className="text-sm text-muted-foreground">
                  No selection yet. Tap your own plots on the map to add them.
                </div>
              )}

              {selected.length > 0 && (
                <div className="flex items-center justify-between gap-2">
                  <Button
                    variant="secondary"
                    onClick={() => {
                      setSelected([]);
                      setListPrices({});
                    }}
                  >
                    Clear selection
                  </Button>
                  <Button
                    onClick={() => {
                      const items = selected
                        .map(({ x, y }) => ({
                          x,
                          y,
                          priceEUR: Number(listPrices[`${x}:${y}`] ?? 0),
                        }))
                        .filter(
                          (it) =>
                            Number.isFinite(it.priceEUR) && it.priceEUR > 0,
                        )
                        .map((it) => ({
                          ...it,
                          priceEUR: Math.round(it.priceEUR * 100) / 100,
                        }));
                      if (items.length !== selected.length) return; // invalid price present
                      if (isGuest) return;
                      (createListingsBatch as any).mutate({ items });
                    }}
                    disabled={
                      isGuest ||
                      (createListingsBatch as any).isLoading ||
                      selected.some(
                        ({ x, y }) => !(Number(listPrices[`${x}:${y}`]) > 0),
                      )
                    }
                  >
                    {(createListingsBatch as any).isLoading
                      ? "Creating…"
                      : `Create listings (${selected.length})`}{" "}
                  </Button>
                </div>
              )}
            </div>
            <DrawerFooter>
              <Button
                variant="secondary"
                onClick={() => setListDrawerOpen(false)}
              >
                {t("close")}
              </Button>
            </DrawerFooter>
          </DrawerContent>
        </Drawer>
        {/* Main Market info popup (before buy confirmation) */}
        <AlertDialog
          open={!!mainBuyInfo}
          onOpenChange={(v) => !v && setMainBuyInfo(null)}
        >
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Main Market m²</AlertDialogTitle>
              <AlertDialogDescription>
                <div className="space-y-3 text-base">
                  <div className="rounded-lg border bg-muted/30 p-3 text-sm">
                    <ul className="list-disc pl-5 space-y-2">
                      <li>
                        Main Market m² is usable instantly after you buy it.
                      </li>
                      <li>
                        You can create islands only with{" "}
                        <span className="font-medium">2 new m²</span> bought
                        directly from the Main Market.
                      </li>
                      <li>
                        Newly bought Main Market m² can be listed immediately on
                        the 2nd Market.
                      </li>
                    </ul>
                  </div>
                  <div>
                    You are about to buy{" "}
                    <span className="font-medium">
                      {mainBuyInfo?.m2 ?? 0} m²
                    </span>{" "}
                    for{" "}
                    <span className="font-medium">
                      {mainBuyInfo?.totalEUR ?? ""}
                    </span>
                    .
                  </div>
                </div>
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel onClick={() => setMainBuyInfo(null)}>
                Cancel
              </AlertDialogCancel>
              <AlertDialogAction
                onClick={() => {
                  if (!mainBuyInfo) return;
                  setConfirmBuy({ ...mainBuyInfo });
                  setMainBuyInfo(null);
                }}
              >
                Continue
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
        {/* Buy confirmation dialog (real money) – button confirm */}
        <AlertDialog
          open={!!confirmBuy}
          onOpenChange={(v) => !v && setConfirmBuy(null)}
        >
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Confirm purchase</AlertDialogTitle>
              <AlertDialogDescription>
                {confirmBuy
                  ? `You are about to buy ${confirmBuy.m2.toLocaleString()} m² for ${confirmBuy.totalEUR}. This will be deducted from your balance.`
                  : ""}
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel onClick={() => setConfirmBuy(null)}>
                Cancel
              </AlertDialogCancel>
              <AlertDialogAction
                onClick={() => {
                  if (!confirmBuy) return;
                  if (isGuest) {
                    setConfirmBuy(null);
                    try {
                      window.dispatchEvent(new Event("openSignIn"));
                    } catch {}
                    return;
                  }
                  buyMutation.mutate({
                    coords: selectedRef.current.length
                      ? selectedRef.current
                      : selected,
                    accessToken,
                  } as any);
                  setConfirmBuy(null);
                }}
              >
                Confirm purchase
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </ScreenContainer>
  );
}

/* eslint-disable-next-line @typescript-eslint/no-unused-vars */
function BuildDragButton({
  label,
  colorClass,
  onStart,
  onCancel,
}: {
  label: string;
  colorClass: string;
  onStart: (e: any) => void;
  onCancel: () => void;
}) {
  return (
    <button
      className="px-3 py-2 rounded-lg border bg-background shadow-sm text-sm"
      onMouseDown={onStart}
      onTouchStart={onStart}
      onMouseUp={onCancel}
      onMouseLeave={onCancel}
      onTouchEnd={onCancel}
      aria-label={label}
    >
      <span className="inline-flex items-center gap-2">
        <span className={`inline-block w-4 h-4 roof ${colorClass}`} />
        {label}
      </span>
    </button>
  );
}

class AppErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { error: { message?: string; stack?: string } | null }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { error: null };
  }
  componentDidCatch(error: any, info: any) {
    try {
      const isEvent =
        error &&
        typeof error === "object" &&
        !("message" in error) &&
        "type" in error;
      const msg = isEvent
        ? `Event:${(error as any).type}`
        : (error?.message ?? String(error));
      // Log diagnostically without elevating to error-level
      console.log(
        `ErrorBoundary tag=AppErrorBoundary | message=${msg} | componentStack=${info?.componentStack ?? ""}`,
      );
      // Ignore benign browser Event objects to avoid disrupting interactive views (e.g., Map)
      if (!isEvent) {
        this.setState({
          error: { message: msg, stack: (error as any)?.stack },
        });
      }
    } catch {
      // no-op
    }
  }
  render() {
    if (this.state.error) {
      const rawMsg = this.state.error.message ?? "Unknown error";
      const msg = /script error/i.test(String(rawMsg))
        ? "A browser script error happened (details were blocked). Please reload the page. If it keeps happening, try another browser/device."
        : String(rawMsg);
      return (
        <div className="min-h-screen bg-background text-foreground flex flex-col items-center justify-center p-6">
          <h2 className="text-xl font-semibold mb-2">Unexpected error</h2>
          <p className="text-sm text-muted-foreground mb-4 text-center max-w-md">
            Something went wrong. You can try again or reload the page.{" "}
          </p>
          <div className="text-xs bg-muted text-foreground border rounded p-3 w-full max-w-md mb-4 break-words">
            {msg}
          </div>
          <div className="flex gap-2">
            <Button
              variant="secondary"
              onClick={() => (window.location.href = "/")}
            >
              Back to home
            </Button>
            <Button onClick={() => window.location.reload()}>Reload</Button>
          </div>
        </div>
      );
    }
    return this.props.children as any;
  }
}

function CertificateFullScreen() {
  const { t } = useLang();
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  void navigate;
  const { data: certs } = useQuery(["certificates-full", id], () =>
    apiClient.listCertificates(),
  );
  const { data: mkt } = useQuery<MarketOutput>(
    ["market", "certificateTemplate", id],
    () => apiClient.getMarket(),
  );
  const templateUrl = mkt?.certificateTemplateUrl ?? null;
  const cert = (certs ?? []).find((c: any) => c.id === id);

  if (!templateUrl) {
    return (
      <div className="min-h-screen bg-background text-foreground flex flex-col items-center justify-center p-6">
        <div className="text-sm text-muted-foreground mb-4">
          {t("noCertificateTemplate")}{" "}
        </div>
        <Button variant="secondary" onClick={() => navigate(-1)}>
          {t("back")}
        </Button>

        <div className="mt-auto w-full">
          <PP15Footer />
        </div>
      </div>
    );
  }
  return (
    <div className="min-h-screen bg-background text-foreground flex flex-col items-center">
      <div className="w-full sticky top-0 z-10 p-2 flex items-center justify-between gap-2">
        <div className="flex gap-2">
          <button
            aria-label="Close"
            className="rounded-full p-2 bg-secondary text-secondary-foreground hover:bg-accent active:scale-95 transition-transform"
            onClick={() => navigate(-1)}
          >
            <X className="h-4 w-4" />
          </button>
          {cert?.plot && (
            <Button
              size="sm"
              className="px-2 py-1 text-xs"
              onClick={() =>
                navigate(
                  `/map?focusX=${cert!.plot!.x}&focusY=${cert!.plot!.y}&certId=${cert!.id}`,
                )
              }
            >
              Show on map
            </Button>
          )}
        </div>
        <div className="flex gap-2">
          <button
            aria-label="Close"
            className="rounded-full p-2 bg-secondary text-secondary-foreground hover:bg-accent active:scale-95 transition-transform"
            onClick={() => navigate(-1)}
          >
            <X className="h-4 w-4" />
          </button>
        </div>
      </div>
      <div className="w-full flex justify-center px-3 pb-16">
        <div className="relative max-w-[300px] sm:max-w-[480px] lg:max-w-[720px] transition-transform active:scale-95">
          <img
            src={templateUrl}
            alt="Certificate"
            className="w-full h-auto select-none pointer-events-none object-contain"
          />
          <div className="absolute left-3 bottom-3 text-xs px-2 py-1 rounded bg-background/70">
            {formatDateTime(cert?.purchasedAt)}
            {cert?.plot ? ` • (${cert.plot.x},${cert.plot.y})` : ""}
          </div>
        </div>
      </div>

      <div className="mt-auto w-full">
        <PP15Footer />
      </div>
    </div>
  );
}

function ProfileScreen() {
  const { t } = useLang();
  const auth = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const supa = useSupabase();
  const isGuest = useIsGuest();
  const navigate = useNavigate();

  const accessToken = supa.accessToken ?? undefined;

  const { data: profile, isInitialLoading: profileInitialLoading } =
    useQuery<GetProfileOutput>(
      ["profile", accessToken ?? null],
      () =>
        accessToken
          ? apiClient.getProfile({ accessToken })
          : apiClient.getProfile(),
      {
        enabled: !isGuest,
      },
    );
  type TxOutput = inferRPCOutputType<"listMyTransactions">;
  const { data: txs, isInitialLoading: txsInitialLoading } = useQuery<TxOutput>(
    ["myTxs"],
    () => apiClient.listMyTransactions(),
    { enabled: !isGuest },
  );
  const [name, setName] = useState<string>(profile?.displayName ?? "");
  const [avatarPreview, setAvatarPreview] = useState<string | null>(
    profile?.profileImageUrl ?? null,
  );
  const [avatarBase64, setAvatarBase64] = useState<string | undefined>();

  useEffect(() => {
    setName(profile?.displayName ?? "");
    setAvatarPreview(profile?.profileImageUrl ?? null);
  }, [profile?.displayName, profile?.profileImageUrl]);

  const update = useMutation(apiClient.updateProfile, {
    onSuccess: async () => {
      await queryClient.invalidateQueries(["profile"]);
      toast({ title: t("profileUpdated") });
    },
    onError: (e: any) =>
      toast({ title: t("saveFailed"), description: e?.message }),
  });

  const [receiptTx, setReceiptTx] = useState<
    null | (TxOutput extends Array<infer U> ? U : any)
  >(null);

  // Messages drawer (compact) under Legal
  type MessageCenterOutput = inferRPCOutputType<"listMessageCenter">;
  const [messagesOpen, setMessagesOpen] = useState(false);
  const { data: messages, isFetching: isMessagesFetching } =
    useQuery<MessageCenterOutput>(
      ["messageCenter_profile"],
      () => apiClient.listMessageCenter(),
      { enabled: messagesOpen, keepPreviousData: true },
    );

  const [invoiceVisibleCount, setInvoiceVisibleCount] = useState(50);
  const [historyVisibleCount, setHistoryVisibleCount] = useState(50);
  const invoiceLines = React.useMemo(() => {
    // Invoice: purchases only (new or 2nd). Each m² as its own line
    const items = (txs ?? []).filter((t) =>
      ["BUY", "SECONDARY_BUY"].includes(((t as any).type || "").toUpperCase()),
    );
    const out: Array<{ date: Date | string; unit: number }> = [];
    for (const tx of items as any[]) {
      const count = Math.max(1, Number((tx as any).m2 || 1));
      let unit = 0;
      try {
        if ((tx as any).type === "SECONDARY_BUY") {
          const meta = (tx as any).meta
            ? (JSON.parse((tx as any).meta) as { priceEUR?: number })
            : undefined;
          unit = Number(meta?.priceEUR || 0);
        }
      } catch {}
      if (!unit) {
        const avg = Number((tx as any).avgPricePerM2 || 0);
        unit = avg || (count ? (tx as any).totalAmountEUR / count : 0);
      }
      for (let i = 0; i < count; i++) {
        out.push({ date: (tx as any).createdAt, unit });
      }
    }
    return out;
  }, [txs]);

  if (auth.status !== "authenticated") {
    return (
      <ScreenContainer title={t("profile") || "Profile"}>
        <div className="mt-4 grid gap-4 max-w-2xl mx-auto">
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-base">Profile is in preview</CardTitle>
            </CardHeader>
            <CardContent className="grid gap-3 text-sm">
              <div className="text-muted-foreground">
                You can browse the app as a guest. To edit your profile, see
                your wallet history, and manage your account, please sign in.
              </div>
              <div className="grid gap-2">
                <Button
                  className="w-full"
                  onClick={() => window.dispatchEvent(new Event("openSignIn"))}
                >
                  Sign in
                </Button>
                <Button
                  variant="secondary"
                  className="w-full"
                  onClick={() => navigate("/market")}
                >
                  Back to Market
                </Button>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-base">Legal</CardTitle>
            </CardHeader>
            <CardContent className="grid gap-3 text-sm">
              <div className="text-xs text-muted-foreground">
                These pages are always available.
              </div>
              <div className="grid gap-1">
                <Button
                  variant="link"
                  className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm justify-start"
                  onClick={() => navigate("/legal/terms")}
                >
                  Terms of Use
                </Button>
                <Button
                  variant="link"
                  className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm justify-start"
                  onClick={() => navigate("/legal/terms-en")}
                >
                  Acceptable Use Policy
                </Button>
                <Button
                  variant="link"
                  className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm justify-start"
                  onClick={() => navigate("/legal/cookies")}
                >
                  Cookie Policy
                </Button>
                <Button
                  variant="link"
                  className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm justify-start"
                  onClick={() => navigate("/legal/privacy-en")}
                >
                  Privacy Policy
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </ScreenContainer>
    );
  }

  // Logged in
  void isGuest;
  void navigate;

  if (profileInitialLoading || txsInitialLoading) {
    return <AppSpinner label="Loading..." />;
  }

  return (
    <ScreenContainer title={t("profile") || "Profile"}>
      <div className="mt-4 grid gap-4 max-w-2xl mx-auto">
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-base">
              {t("profile") || "Profile"}
            </CardTitle>
          </CardHeader>
          <CardContent className="grid gap-3 text-sm">
            <div className="flex items-center gap-3">
              <Avatar className="h-14 w-14">
                <AvatarImage src={avatarPreview ?? undefined} />
                <AvatarFallback
                  className="text-transparent"
                  style={_avatarGradientStyle(
                    name || profile?.displayName || "user",
                  )}
                >
                  <span className="sr-only">
                    {name || profile?.displayName || "User"}
                  </span>
                </AvatarFallback>
              </Avatar>
              <Input
                type="file"
                accept="image/*"
                onChange={async (e) => {
                  const f = e.target.files?.[0];
                  if (!f) return;
                  const base64 = await encodeFileAsBase64DataURL(f);
                  if (base64) {
                    setAvatarBase64(base64);
                    setAvatarPreview(URL.createObjectURL(f));
                  }
                }}
              />
            </div>
            <div className="grid gap-2">
              <Label>{t("username") || "Username"}</Label>
              <Input
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="your name"
              />
            </div>
            <div className="flex gap-2">
              <Button
                onClick={() =>
                  update.mutate({
                    displayName: name,
                    profileImageBase64: avatarBase64,
                    ...(accessToken ? { accessToken } : {}),
                  })
                }
                disabled={
                  update.isLoading ||
                  (!avatarBase64 && name === (profile?.displayName ?? ""))
                }
              >
                {" "}
                {update.isLoading ? "…" : t("saveProfile") || "Save"}
              </Button>
              <Button
                variant="secondary"
                onClick={() => {
                  setName(profile?.displayName ?? "");
                  setAvatarPreview(profile?.profileImageUrl ?? null);
                  setAvatarBase64(undefined);
                }}
              >
                {t("revert") || "Reset"}
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* Legal */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-base">Legal</CardTitle>
          </CardHeader>
          <CardContent className="grid gap-3 text-sm">
            <Accordion type="single" collapsible>
              <AccordionItem value="legal">
                <AccordionTrigger className="text-sm">
                  Show more
                </AccordionTrigger>
                <AccordionContent>
                  <Button
                    variant="link"
                    className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm"
                    onClick={() => navigate("/legal/terms")}
                  >
                    Terms of Use
                  </Button>
                  <div className="text-xs text-muted-foreground mt-1">
                    Opens the Terms of Use.
                  </div>
                  <div className="mt-2" />
                  <Button
                    variant="link"
                    className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm"
                    onClick={() => navigate("/legal/terms-en")}
                  >
                    Acceptable Use Policy
                  </Button>
                  <div className="text-xs text-muted-foreground mt-1">
                    Opens the Acceptable Use Policy.
                  </div>
                  <div className="mt-2" />
                  <Button
                    variant="link"
                    className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm"
                    onClick={() => navigate("/legal/cookies")}
                  >
                    Cookie Policy
                  </Button>
                  <div className="text-xs text-muted-foreground mt-1">
                    Opens the Cookie Policy.
                  </div>
                  <div className="mt-2" />
                  <Button
                    variant="link"
                    className="px-0 text-foreground underline underline-offset-4 hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring rounded-sm"
                    onClick={() => navigate("/legal/privacy-en")}
                  >
                    Privacy Policy
                  </Button>
                  <div className="text-xs text-muted-foreground mt-1">
                    Opens the Privacy Policy.
                  </div>
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </CardContent>
        </Card>

        {/* Messages (separate section) */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-base">Messages</CardTitle>
          </CardHeader>
          <CardContent className="grid gap-2 text-sm">
            <div className="text-xs text-muted-foreground">
              Tap to see recent activity.
            </div>
            <Button size="sm" onClick={() => setMessagesOpen(true)}>
              Open
            </Button>
          </CardContent>
        </Card>

        {/* Account */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-base">Account</CardTitle>
          </CardHeader>
          <CardContent className="grid gap-3 text-sm">
            <div className="text-xs text-muted-foreground">
              Signed in as {supa.user?.email || "—"}
            </div>
            <div className="grid gap-2">
              <Button
                variant="secondary"
                onClick={async () => {
                  try {
                    await supa.endSession();
                  } catch {}
                  try {
                    queryClient.clear();
                  } catch {}
                  try {
                    window.location.href = "/";
                  } catch {}
                }}
              >
                Log out
              </Button>
              <div className="text-xs text-muted-foreground">
                This will end your session on this device.
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2 flex items-center justify-between">
            <CardTitle className="text-base">Invoice</CardTitle>
            <Button
              size="sm"
              variant="secondary"
              onClick={() => {
                try {
                  const escapeHtml = (v: any) =>
                    String(v ?? "")
                      .replace(/&/g, "&amp;")
                      .replace(/</g, "&lt;")
                      .replace(/>/g, "&gt;")
                      .replace(/\"/g, "&quot;")
                      .replace(/'/g, "&#039;");

                  const subtitle =
                    (profile?.displayName
                      ? String(profile.displayName) + " • "
                      : "") + new Date().toLocaleString();

                  const rows = (invoiceLines || []).map((ln) => ({
                    date: formatDateTime(ln.date as any),
                    qty: "1 m²",
                    unit: currencyUSD(ln.unit),
                    total: currencyUSD(ln.unit),
                  }));

                  const html =
                    '<!doctype html><html><head><meta charset="utf-8"/>' +
                    "<title>Invoice</title>" +
                    "<style>" +
                    "body{font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial; padding:24px;}" +
                    "h1{margin:0 0 4px 0;font-size:18px;}" +
                    ".sub{color:#555;font-size:12px;margin-bottom:16px;}" +
                    "table{width:100%;border-collapse:collapse;font-size:12px;}" +
                    "th,td{border:1px solid #ddd;padding:8px;}" +
                    "th{background:#f5f5f5;text-align:left;}" +
                    "td.num,th.num{text-align:right;}" +
                    "td.center,th.center{text-align:center;}" +
                    "</style></head><body>" +
                    "<h1>Invoice</h1>" +
                    `<div class=\"sub\">${escapeHtml(subtitle)}</div>` +
                    "<table><thead><tr>" +
                    '<th>Date</th><th class="center">Amount</th><th class="num">Unit price</th><th class="num">Total cost</th>' +
                    "</tr></thead><tbody>" +
                    rows
                      .map(
                        (r) =>
                          `<tr><td>${escapeHtml(r.date)}</td><td class=\"center\">${escapeHtml(
                            r.qty,
                          )}</td><td class=\"num\">${escapeHtml(
                            r.unit,
                          )}</td><td class=\"num\">${escapeHtml(r.total)}</td></tr>`,
                      )
                      .join("") +
                    "</tbody></table>" +
                    "</body></html>";

                  const w = window.open("", "_blank", "noopener,noreferrer");
                  if (!w) {
                    toast({
                      title: "Popup blocked",
                      description: "Please allow popups to print your invoice.",
                    });
                    return;
                  }
                  w.document.open();
                  w.document.write(html);
                  w.document.close();

                  window.setTimeout(() => {
                    try {
                      w.focus();
                      w.print();
                    } catch {}
                  }, 200);
                } catch (e) {
                  toast({
                    title: "Print failed",
                    description: (e as any)?.message || String(e),
                  });
                }
              }}
            >
              Print invoices{" "}
            </Button>{" "}
          </CardHeader>
          <CardContent className="grid gap-3 text-sm">
            <Tabs defaultValue="invoice">
              <TabsList className="grid grid-cols-2 w-full max-w-xs">
                <TabsTrigger value="invoice">Invoice</TabsTrigger>{" "}
                <TabsTrigger value="history">History</TabsTrigger>
              </TabsList>

              <TabsContent value="invoice">
                {invoiceLines.length === 0 ? (
                  <div className="text-muted-foreground text-sm">
                    No transactions yet.
                  </div>
                ) : (
                  <div className="grid gap-2">
                    <div className="rounded border overflow-hidden">
                      <div className="grid grid-cols-4 text-[11px] text-muted-foreground bg-secondary border-b">
                        <div className="px-2 py-1 border-r">Datum</div>
                        <div className="px-2 py-1 text-center border-r">
                          Menge
                        </div>
                        <div className="px-2 py-1 text-right border-r">
                          Einkaufskurs
                        </div>
                        <div className="px-2 py-1 text-right">
                          Einkaufskosten
                        </div>
                      </div>
                      {invoiceLines
                        .slice(0, invoiceVisibleCount)
                        .map((ln, idx) => (
                          <div
                            key={idx}
                            className="grid grid-cols-4 text-[12px] border-b last:border-b-0 receipt-row"
                          >
                            <div className="px-2 py-1 border-r">
                              {formatDateTime(ln.date as any)}
                            </div>
                            <div className="px-2 py-1 text-center border-r">
                              1 m²
                            </div>
                            <div className="px-2 py-1 text-right border-r">
                              {currencyUSD(ln.unit)}
                            </div>
                            <div className="px-2 py-1 text-right">
                              {currencyUSD(ln.unit)}
                            </div>
                          </div>
                        ))}
                    </div>
                    {invoiceVisibleCount < invoiceLines.length && (
                      <div className="flex justify-center">
                        <Button
                          variant="secondary"
                          onClick={() => setInvoiceVisibleCount((c) => c + 50)}
                        >
                          Show more ({invoiceLines.length - invoiceVisibleCount}
                          )
                        </Button>
                      </div>
                    )}
                  </div>
                )}
              </TabsContent>

              <TabsContent value="history">
                {(txs ?? []).length === 0 ? (
                  <div className="text-muted-foreground text-sm">
                    No entries.
                  </div>
                ) : (
                  <div className="grid gap-2">
                    <div className="rounded border overflow-hidden">
                      <div className="grid grid-cols-6 text-[11px] text-muted-foreground bg-secondary border-b">
                        <div className="px-2 py-1 border-r">Date</div>
                        <div className="px-2 py-1 border-r">Type</div>
                        <div className="px-2 py-1 text-center border-r">
                          Amount
                        </div>
                        <div className="px-2 py-1 text-right border-r">
                          Rate
                        </div>
                        <div className="px-2 py-1 text-center border-r">
                          Fee
                        </div>
                        <div className="px-2 py-1 text-right">Total</div>
                      </div>{" "}
                      {txs?.slice(0, historyVisibleCount).map((tx: any) => {
                        const type = ((tx.type || "") as string).toUpperCase();
                        const meta = (() => {
                          try {
                            return tx.meta
                              ? (JSON.parse(tx.meta) as any)
                              : null;
                          } catch {
                            return null;
                          }
                        })();
                        const typeLabel =
                          type === "BUY"
                            ? "Buy"
                            : type === "SECONDARY_BUY"
                              ? "Buy (2nd)"
                              : type === "SELL"
                                ? "Sell"
                                : type === "TOPUP"
                                  ? "Top up"
                                  : type === "SECONDARY_SOLD"
                                    ? "Sold (2nd)"
                                    : type || "—";
                        const qty =
                          typeof tx.m2 === "number" && tx.m2 > 0
                            ? `${tx.m2} m²`
                            : "—";
                        const price =
                          type === "SECONDARY_BUY" && meta?.priceEUR
                            ? meta.priceEUR
                            : tx.avgPricePerM2 || 0;
                        const feePct =
                          typeof tx.feePct === "number" && tx.feePct > 0
                            ? `${tx.feePct}%`
                            : "—";
                        const amount = tx.totalAmountUSD || 0;
                        const signedAmount =
                          type === "BUY" || type === "SECONDARY_BUY"
                            ? -Math.abs(amount)
                            : amount;
                        return (
                          <div
                            key={tx.id}
                            className="grid grid-cols-6 text-[12px] border-b last:border-b-0 receipt-row"
                          >
                            <div className="px-2 py-1 border-r">
                              {formatDateTime(tx.createdAt)}
                            </div>
                            <div className="px-2 py-1 border-r">
                              {typeLabel}
                            </div>
                            <div className="px-2 py-1 text-center border-r">
                              {qty}
                            </div>
                            <div className="px-2 py-1 text-right border-r">
                              {price ? currencyUSD(price) : "—"}
                            </div>
                            <div className="px-2 py-1 text-center border-r">
                              {feePct}
                            </div>
                            <div className="px-2 py-1 text-right">
                              {signedAmount < 0
                                ? `− ${currencyUSD(Math.abs(signedAmount))}`
                                : `+ ${currencyUSD(signedAmount)}`}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                    {historyVisibleCount < (txs?.length || 0) && (
                      <div className="flex justify-center">
                        <Button
                          variant="secondary"
                          onClick={() => setHistoryVisibleCount((c) => c + 50)}
                        >
                          Show more {txs!.length - historyVisibleCount}
                        </Button>
                      </div>
                    )}
                  </div>
                )}
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>

        <Drawer
          open={!!receiptTx}
          onOpenChange={(v) => !v && setReceiptTx(null)}
        >
          <DrawerContent>
            <DrawerHeader className="text-left">
              <DrawerTitle>Invoice</DrawerTitle>
              <DrawerDescription>
                {receiptTx
                  ? `${receiptTx.type} • ${formatDateTime((receiptTx as any).createdAt)}`
                  : ""}
              </DrawerDescription>
            </DrawerHeader>
            <div className="px-4 pb-4 grid gap-2 text-sm">
              {receiptTx && (
                <>
                  {typeof (receiptTx as any).m2 === "number" && (
                    <div className="flex items-center justify-between">
                      <span className="text-muted-foreground">Amount</span>
                      <span className="font-medium">
                        {(receiptTx as any).m2} m²
                      </span>
                    </div>
                  )}
                  {typeof (receiptTx as any).avgPricePerM2 === "number" && (
                    <div className="flex items-center justify-between">
                      <span className="text-muted-foreground">
                        Ø Preis / m²
                      </span>
                      <span className="font-medium">
                        {currencyUSD((receiptTx as any).avgPricePerM2)}
                      </span>
                    </div>
                  )}
                  {typeof (receiptTx as any).feePct === "number" &&
                    (receiptTx as any).feePct > 0 && (
                      <div className="flex items-center justify-between">
                        <span className="text-muted-foreground">Fee</span>
                        <span className="font-medium">
                          {(receiptTx as any).feePct}%
                        </span>
                      </div>
                    )}
                  <div className="flex items-center justify-between">
                    <span className="text-muted-foreground">Total</span>{" "}
                    <span className="font-semibold">
                      {currencyUSD((receiptTx as any).totalAmountUSD)}
                    </span>
                  </div>
                  {(receiptTx as any).meta && (
                    <div className="mt-2 p-2 rounded border bg-secondary/40 text-xs break-words">
                      {(receiptTx as any).meta}
                    </div>
                  )}

                  {/* Detail-Positionen pro gekauftem m² */}
                  {(() => {
                    const tx: any = receiptTx;
                    const isBuy =
                      tx?.type === "BUY" || tx?.type === "SECONDARY_BUY";
                    if (!isBuy) return null;
                    const count: number = Math.max(1, Number(tx.m2 || 1));
                    let unit = 0;
                    try {
                      if (tx.type === "SECONDARY_BUY") {
                        const meta = tx.meta
                          ? (JSON.parse(tx.meta) as { priceEUR?: number })
                          : undefined;
                        unit = Number(meta?.priceEUR || 0);
                      }
                    } catch {}
                    if (!unit) {
                      unit = Number(
                        tx.avgPricePerM2 ||
                          (count ? tx.totalAmountUSD / count : 0),
                      );
                    }
                    const rowsToShow = Math.min(count, 200);
                    return (
                      <div className="mt-3">
                        <div className="text-xs uppercase tracking-wide text-muted-foreground mb-1">
                          Line items (per 1 m²)
                        </div>
                        <div className="rounded border overflow-hidden">
                          <div className="grid grid-cols-4 text-[11px] text-muted-foreground bg-secondary border-b">
                            <div className="px-2 py-1 border-r">Date</div>
                            <div className="px-2 py-1 text-center border-r">
                              Amount
                            </div>
                            <div className="px-2 py-1 text-right border-r">
                              Unit price
                            </div>
                            <div className="px-2 py-1 text-right">
                              Total cost
                            </div>
                          </div>
                          {Array.from({ length: rowsToShow }).map((_, idx) => (
                            <div
                              key={idx}
                              className="grid grid-cols-4 text-[12px] border-b last:border-b-0 receipt-row"
                            >
                              <div className="px-2 py-1 border-r">
                                {formatDateTime(tx.createdAt)}
                              </div>
                              <div className="px-2 py-1 text-center border-r">
                                1 m²
                              </div>
                              <div className="text-right">
                                {currencyUSD(unit)}
                              </div>
                              <div className="text-right">
                                {currencyUSD(unit)}
                              </div>
                            </div>
                          ))}
                        </div>
                        {count > rowsToShow && (
                          <div className="text-xs text-muted-foreground mt-1">
                            + {count - rowsToShow} more line items hidden
                          </div>
                        )}
                      </div>
                    );
                  })()}
                </>
              )}
            </div>
            <DrawerFooter>
              <Button variant="secondary" onClick={() => setReceiptTx(null)}>
                {t("close") || "Close"}
              </Button>
            </DrawerFooter>
          </DrawerContent>
        </Drawer>

        {/* Messages drawer for Profile > Legal */}
        <Drawer open={messagesOpen} onOpenChange={setMessagesOpen}>
          <DrawerContent className="sm:max-w-[720px] mx-auto">
            <DrawerHeader className="text-left">
              <DrawerTitle>Messages</DrawerTitle>
              <DrawerDescription>Recent activity</DrawerDescription>
            </DrawerHeader>
            <div className="px-4 pb-4 max-h-[60vh] overflow-y-auto">
              {isMessagesFetching && (
                <div className="text-xs text-muted-foreground mb-2">
                  Updating…
                </div>
              )}
              {(!messages || messages.length === 0) && !isMessagesFetching ? (
                <div className="text-sm text-muted-foreground">
                  No activity yet.
                </div>
              ) : (
                <div className="grid gap-2">
                  {messages?.map((m: any) => {
                    const isIn = m.direction === "in";
                    const isOut = m.direction === "out";
                    const amountCls = isIn
                      ? "text-green-600"
                      : isOut
                        ? "text-red-600"
                        : "text-muted-foreground";
                    return (
                      <div
                        key={m.id}
                        className="rounded border bg-card p-2 flex items-start justify-between gap-2 text-[12px]"
                      >
                        <div className="min-w-0 pr-2">
                          <div className="font-medium truncate">{m.title}</div>
                          {m.detail && (
                            <div className="text-[11px] text-muted-foreground truncate">
                              {m.detail}
                            </div>
                          )}
                          <div className="text-[10px] text-muted-foreground mt-1">
                            {formatDateTime(m.createdAt)}
                          </div>
                        </div>
                        <div className={`shrink-0 font-semibold ${amountCls}`}>
                          {m.direction === "out"
                            ? "− "
                            : m.direction === "in"
                              ? "+ "
                              : ""}
                          {currencyUSD(m.amountUSD)}
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
            <DrawerFooter className="pt-2">
              <Button
                variant="secondary"
                onClick={() => setMessagesOpen(false)}
              >
                Close
              </Button>
            </DrawerFooter>
          </DrawerContent>
        </Drawer>
      </div>
    </ScreenContainer>
  );
}

function NavBridge() {
  const navigate = useNavigate();
  void navigate;
  useEffect(() => {
    const handler = (e: any) => {
      const to = e?.detail;
      if (typeof to === "string") navigate(to);
    };
    window.addEventListener("navigateTo", handler);
    return () => window.removeEventListener("navigateTo", handler);
  }, [navigate]);
  return null;
}

// Login screen removed: this app does not support Adaptive sign-in.

// Component for real-money top-up: user enters amount and we redirect to purchase page
type FxSeriesOutput = inferRPCOutputType<"getFxSeries">;

type FxQuote = "CHF" | "EUR" | "GBP" | "JPY" | "CNY";

function FxSparkline({
  points,
  quote,
  heightPx = 112,
}: {
  points: Array<{ t: string; v: number }>;
  quote: FxQuote;
  heightPx?: number;
}) {
  const [hoverIdx, setHoverIdx] = useState<number | null>(null);
  const [view, setView] = useState<{ start: number; end: number } | null>(null);
  const [drag, setDrag] = useState<{ start: number; cur: number } | null>(null);

  const nFull = points?.length ?? 0;
  if (nFull < 2) return null;

  const clamp = (v: number, lo: number, hi: number) =>
    Math.max(lo, Math.min(hi, v));

  const rawStart = view?.start ?? 0;
  const rawEnd = view?.end ?? nFull - 1;
  const viewStart = clamp(Math.min(rawStart, rawEnd), 0, nFull - 1);
  const viewEnd = clamp(Math.max(rawStart, rawEnd), 0, nFull - 1);

  const viewPoints = (points ?? []).slice(viewStart, viewEnd + 1);
  const n = viewPoints.length;
  const values = (viewPoints ?? [])
    .map((p) => Number(p.v))
    .filter(Number.isFinite);
  if (n < 2 || values.length < 2) return null;

  const min = Math.min(...values);
  const max = Math.max(...values);
  const span = Math.max(1e-9, max - min);

  const width = 100;
  const height = 44;

  const toX = (i: number) => (i / Math.max(1, n - 1)) * width;
  const toY = (v: number) => (1 - (v - min) / span) * height;

  const lineD = (viewPoints ?? [])
    .map((p, i) => {
      const x = toX(i);
      const y = toY(Number(p.v));
      const cmd = i === 0 ? "M" : "L";
      return `${cmd}${x.toFixed(2)},${y.toFixed(2)}`;
    })
    .join(" ");

  const areaD = `${lineD} L${width},${height} L0,${height} Z`;

  const fmtRate = (v: number) => {
    if (!Number.isFinite(v)) return "—";
    try {
      const maxFraction = quote === "JPY" ? 2 : 4;
      const minFraction = quote === "JPY" ? 0 : Math.min(2, maxFraction);
      return new Intl.NumberFormat("en-US", {
        maximumFractionDigits: maxFraction,
        minimumFractionDigits: minFraction,
      }).format(v);
    } catch {
      return v.toLocaleString("en-US", { maximumFractionDigits: 4 });
    }
  };

  const fmtDate = (iso: string) => {
    try {
      const d = new Date(`${iso}T00:00:00Z`);
      return new Intl.DateTimeFormat("en-US", {
        month: "short",
        day: "2-digit",
      }).format(d);
    } catch {
      return iso;
    }
  };

  const fmtPct = (v: number) => {
    if (!Number.isFinite(v)) return "—";
    const sign = v > 0 ? "+" : "";
    return `${sign}${v.toFixed(2)}%`;
  };

  const activeIdx =
    hoverIdx !== null ? clamp(hoverIdx, 0, n - 1) : Math.max(0, n - 1);
  const active = viewPoints?.[activeIdx];
  const activeV = Number(active?.v);
  const activeT = String(active?.t ?? "");

  const startT = String(viewPoints?.[0]?.t ?? "");
  const endT = String(viewPoints?.[n - 1]?.t ?? "");

  const firstV = Number(viewPoints?.[0]?.v);
  const prevV = activeIdx > 0 ? Number(viewPoints?.[activeIdx - 1]?.v) : NaN;

  const changeFromStartPct =
    Number.isFinite(activeV) && Number.isFinite(firstV) && firstV !== 0
      ? ((activeV - firstV) / firstV) * 100
      : NaN;

  const changeFromPrevPct =
    Number.isFinite(activeV) && Number.isFinite(prevV) && prevV !== 0
      ? ((activeV - prevV) / prevV) * 100
      : NaN;

  const idxFromClientX = (clientX: number, rect: DOMRect) => {
    const x = clientX - rect.left;
    const pct = x / Math.max(1, rect.width);
    return clamp(Math.round(pct * (n - 1)), 0, n - 1);
  };

  const onPointerMoveCore = (clientX: number, rect: DOMRect) => {
    const idx = idxFromClientX(clientX, rect);
    setHoverIdx(idx);
    setDrag((prev) => (prev ? { ...prev, cur: idx } : prev));
  };

  const dragLo = drag ? Math.min(drag.start, drag.cur) : null;
  const dragHi = drag ? Math.max(drag.start, drag.cur) : null;

  const isZoomed = view !== null && viewEnd - viewStart < nFull - 1;

  return (
    <div className="w-full">
      <div className="relative">
        {isZoomed ? (
          <button
            type="button"
            className="absolute right-2 top-2 z-10 rounded-md border bg-background/80 px-2 py-1 text-[11px] text-foreground shadow-sm"
            onClick={() => {
              setView(null);
              setDrag(null);
              setHoverIdx(null);
            }}
          >
            Reset
          </button>
        ) : null}

        <svg
          viewBox={`0 0 ${width} ${height}`}
          className="w-full"
          style={{ height: heightPx }}
          preserveAspectRatio="none"
          onPointerLeave={() => {
            if (!drag) setHoverIdx(null);
          }}
          onPointerDown={(e) => {
            try {
              const rect = (e.currentTarget as any).getBoundingClientRect() as
                | DOMRect
                | undefined;
              if (!rect) return;
              const idx = idxFromClientX(e.clientX, rect);
              setHoverIdx(idx);
              setDrag({ start: idx, cur: idx });
              try {
                (e.currentTarget as any).setPointerCapture?.(e.pointerId);
              } catch {}
            } catch {}
          }}
          onPointerMove={(e) => {
            try {
              const rect = (e.currentTarget as any).getBoundingClientRect() as
                | DOMRect
                | undefined;
              if (!rect) return;
              onPointerMoveCore(e.clientX, rect);
            } catch {}
          }}
          onPointerUp={(e) => {
            try {
              const rect = (e.currentTarget as any).getBoundingClientRect() as
                | DOMRect
                | undefined;
              if (!rect) {
                setDrag(null);
                return;
              }
              const idx = idxFromClientX(e.clientX, rect);
              setHoverIdx(idx);

              setDrag((prev) => {
                if (!prev) return null;

                const lo = Math.min(prev.start, idx);
                const hi = Math.max(prev.start, idx);

                // Ignore tiny drags (treat as just "inspect")
                if (hi - lo < 2) {
                  return null;
                }

                const fullLo = viewStart + lo;
                const fullHi = viewStart + hi;
                setView({ start: fullLo, end: fullHi });
                return null;
              });
            } catch {
              setDrag(null);
            }
          }}
          onPointerCancel={() => setDrag(null)}
          onTouchMove={(e) => {
            // Fallback for older touch-only browsers
            try {
              const touch = e.touches?.[0];
              if (!touch) return;
              const rect = (e.currentTarget as any).getBoundingClientRect() as
                | DOMRect
                | undefined;
              if (!rect) return;
              onPointerMoveCore(touch.clientX, rect);
            } catch {}
          }}
        >
          <defs>
            <linearGradient id="fxFill" x1="0" x2="0" y1="0" y2="1">
              <stop
                offset="0%"
                stopColor="hsl(var(--primary))"
                stopOpacity="0.20"
              />
              <stop
                offset="100%"
                stopColor="hsl(var(--primary))"
                stopOpacity="0.02"
              />
            </linearGradient>
          </defs>

          {/* subtle grid */}
          {[0.25, 0.5, 0.75].map((p) => (
            <line
              key={p}
              x1={0}
              x2={width}
              y1={height * p}
              y2={height * p}
              stroke="hsl(var(--border))"
              strokeWidth={0.6}
              opacity={0.6}
            />
          ))}

          {dragLo !== null && dragHi !== null ? (
            <rect
              x={toX(dragLo)}
              y={0}
              width={Math.max(0.01, toX(dragHi) - toX(dragLo))}
              height={height}
              fill="hsl(var(--primary))"
              opacity={0.08}
              stroke="hsl(var(--primary))"
              strokeWidth={0.7}
              strokeOpacity={0.5}
            />
          ) : null}

          <path d={areaD} fill="url(#fxFill)" stroke="none" />

          <path
            d={lineD}
            fill="none"
            stroke="hsl(var(--primary))"
            strokeWidth="2"
            strokeLinejoin="round"
            strokeLinecap="round"
          />

          {Number.isFinite(activeV) ? (
            <>
              <line
                x1={toX(activeIdx)}
                x2={toX(activeIdx)}
                y1={0}
                y2={height}
                stroke="hsl(var(--border))"
                strokeWidth={0.8}
                opacity={0.9}
              />
              <circle
                cx={toX(activeIdx)}
                cy={toY(activeV)}
                r={2.2}
                fill="hsl(var(--primary))"
              />
            </>
          ) : null}
        </svg>

        <div className="pointer-events-none absolute left-2 top-2 rounded-lg border bg-background/80 px-2 py-1 text-[11px] text-foreground tabular-nums shadow-sm">
          <div className="font-medium">
            {activeT ? fmtDate(activeT) : ""} · {fmtRate(activeV)} {quote}
          </div>
          <div className="text-muted-foreground">
            Window {fmtDate(startT)} → {fmtDate(endT)}
          </div>
          <div className="text-muted-foreground">
            Δ start {fmtPct(changeFromStartPct)} · Δ prev{" "}
            {fmtPct(changeFromPrevPct)}
          </div>
          <div className="text-muted-foreground">
            Low {fmtRate(min)} · High {fmtRate(max)}
          </div>
        </div>
      </div>

      <div className="-mt-1 flex items-center justify-between text-[11px] text-muted-foreground tabular-nums">
        <span>{startT ? fmtDate(startT) : ""}</span>
        <span>{endT ? fmtDate(endT) : ""}</span>
      </div>
    </div>
  );
}

function FxPanel({
  quote,
  onChangeQuote,
  latestLabel,
  changePct,
  points,
  loading,
  refreshing,
  hasError,
  fetchedAt,
  days,
  onChangeDays,
}: {
  quote: FxQuote;
  onChangeQuote: (q: FxQuote) => void;
  latestLabel: string;
  changePct: number;
  points: Array<{ t: string; v: number }>;
  loading: boolean;
  refreshing: boolean;
  hasError: boolean;
  fetchedAt?: string | Date | null;
  days: number;
  onChangeDays: (d: number) => void;
}) {
  const quotes: FxQuote[] = ["CHF", "EUR", "GBP", "JPY", "CNY"];
  const ranges = [7, 30, 90];

  const updatedLabel = React.useMemo(() => {
    if (!fetchedAt) return null;
    try {
      const d = new Date(fetchedAt);
      const ageMin = Math.max(
        0,
        Math.round((Date.now() - d.getTime()) / 60000),
      );
      if (!Number.isFinite(ageMin)) return null;
      if (ageMin <= 1) return "Updated just now";
      if (ageMin < 60) return `Updated ${ageMin} min ago`;
      const ageH = Math.round(ageMin / 60);
      return `Updated ${ageH}h ago`;
    } catch {
      return null;
    }
  }, [fetchedAt]);

  return (
    <div className="rounded-2xl border bg-card p-2.5 sm:p-3 shadow-sm">
      <div className="flex items-start justify-between gap-3">
        <div className="min-w-0">
          <div className="text-xs font-semibold">USD live rate</div>
          <div className="mt-0.5 text-[11px] text-muted-foreground tabular-nums">
            1 USD ≈ {latestLabel} ({quote})
            {refreshing ? <span className="ml-2">Updating…</span> : null}
          </div>
          {updatedLabel ? (
            <div className="mt-0.5 text-[11px] text-muted-foreground">
              {updatedLabel}
            </div>
          ) : null}
        </div>

        <div className="text-right shrink-0 text-[11px] tabular-nums">
          {Number.isFinite(changePct) ? (
            <span
              className={
                changePct >= 0 ? "text-emerald-600" : "text-destructive"
              }
            >
              {changePct >= 0 ? "+" : ""}
              {changePct.toFixed(2)}%
            </span>
          ) : (
            <span className="text-muted-foreground">—</span>
          )}
          <div className="mt-0.5 text-[10px] text-muted-foreground">
            {days}d
          </div>
        </div>
      </div>

      <div className="mt-2 grid gap-1.5">
        <div className="flex flex-wrap gap-1">
          {ranges.map((d) => (
            <Button
              key={d}
              type="button"
              size="sm"
              variant={d === days ? "default" : "secondary"}
              className="h-7 px-2.5 text-xs"
              onClick={() => onChangeDays(d)}
            >
              {d}d
            </Button>
          ))}
        </div>

        <div className="flex flex-nowrap gap-1 overflow-x-auto pb-0.5">
          {quotes.map((q) => (
            <Button
              key={q}
              type="button"
              size="sm"
              variant={q === quote ? "default" : "secondary"}
              className="h-7 px-2.5 text-xs"
              onClick={() => onChangeQuote(q)}
            >
              {q}
            </Button>
          ))}
        </div>
      </div>

      <div className="mt-2">
        {loading ? (
          <div className="text-xs text-muted-foreground">Loading chart…</div>
        ) : hasError ? (
          <div className="text-xs text-muted-foreground">
            FX chart temporarily unavailable.
          </div>
        ) : (
          <FxSparkline points={points} quote={quote} heightPx={96} />
        )}
      </div>

      <div className="mt-1 text-[11px] text-muted-foreground">
        Tip: drag to zoom · move to see details · use Reset to zoom out
      </div>

      <div className="mt-1 text-[11px] text-muted-foreground">
        PPc ≈ 1 USD (reference only)
      </div>
    </div>
  );
}

function PPCoinTopup({
  redirectToWallet,
  onClose,
  variant = "inline",
  amountUnit = "USD",
  confirmLabel,
  showFx = true,
  uiStyle = "default",
}: {
  redirectToWallet?: boolean;
  onClose?: () => void;
  variant?: "inline" | "keypad";
  amountUnit?: "USD" | "PPc";
  confirmLabel?: string;
  showFx?: boolean;
  uiStyle?: "default" | "tour";
}) {
  const { toast } = useToast();
  const supa = useSupabase();
  const isGuest = useIsGuest();
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const deviceId = React.useContext(DeviceIdContext);
  const hasSupabaseSession = !!supa.user && !!supa.accessToken;

  const [amount, setAmount] = useState<string>("");
  const [successOverlay, setSuccessOverlay] = useState(false);
  const [inlineError, setInlineError] = useState<string>("");

  const parsed = React.useMemo(() => {
    const s = (amount || "").replace(/[^0-9.,]/g, "").replace(",", ".");
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }, [amount]);

  const formatBigAmount = React.useCallback(() => {
    const lang =
      (typeof window !== "undefined" && (window as any).__appLang) || "de";
    const locale = lang === "en" ? "en-US" : lang === "es" ? "es-ES" : "de-DE";

    const s = (amount || "").replace(/[^0-9.,]/g, "").replace(",", ".");
    const n = Number(s);
    const isOk = Number.isFinite(n) && n > 0;

    const hasDecimals = s.includes(".");

    try {
      return new Intl.NumberFormat(locale, {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: hasDecimals ? 2 : 0,
        maximumFractionDigits: 2,
      }).format(isOk ? n : 0);
    } catch {
      return isOk ? `${n}` : "$0";
    }
  }, [amount]);

  const addCoins = useMutation(apiClient.addPPCoins, {
    onSuccess: async (res: any) => {
      setInlineError("");
      setSuccessOverlay(true);
      setAmount("");
      await Promise.all([
        queryClient.invalidateQueries(["profile"]),
        queryClient.invalidateQueries(["portfolio"]),
        queryClient.invalidateQueries(["walletSummary"]),
        queryClient.invalidateQueries(["messageCenter"]),
      ]);
      toast({
        title: "PP coins added",
        description: `New balance: ${currencyUSD(res?.balanceUSD ?? 0)}`,
      });
      window.setTimeout(() => {
        setSuccessOverlay(false);
        if (onClose) {
          onClose();
          return;
        }
        if (redirectToWallet) navigate("/portfolio");
      }, 900);
    },
    onError: (e: any) => {
      const msg = String(e?.message || "Top up failed.");
      setInlineError(msg);
      toast({ title: "Top up failed", description: msg });
    },
  });

  const commitTopup = () => {
    if (addCoins.isLoading) return;
    if (isGuest) {
      setInlineError("Please sign in to add PP coins.");
      toast({
        title: "Sign in required",
        description: "Please sign in to add PP coins.",
      });
      return;
    }
    if (!(parsed > 0)) {
      setInlineError("Please enter a valid amount.");
      return;
    }
    addCoins.mutate({
      amountUSD: parsed,
      // Prefer logged-in identity (Supabase). Fall back to device id for guest flows.
      accessToken: hasSupabaseSession
        ? (supa.accessToken ?? undefined)
        : undefined,
      deviceId: !hasSupabaseSession ? deviceId : undefined,
    });
  };

  const keypadAdd = (ch: string) => {
    setAmount((prev) => {
      const p = (prev || "").replace(/[^0-9.]/g, "");
      if (ch === ".") {
        if (!p) return "0.";
        if (p.includes(".")) return p;
        return `${p}.`;
      }
      if (!/^[0-9]$/.test(ch)) return p;

      const next = p === "0" ? ch : `${p}${ch}`;
      if (next.length > 12) return p;
      return next;
    });
  };

  const keypadBackspace = () => {
    setAmount((prev) => (prev || "").slice(0, -1));
  };

  const keypadClear = () => setAmount("");

  const keypadDisabled = isGuest || addCoins.isLoading;
  const ctaDisabled = keypadDisabled || !(parsed > 0);

  const [fxQuote, setFxQuote] = useState<FxQuote>("CHF");
  const [fxDays, setFxDays] = useState<number>(30);
  const {
    data: fxSeries,
    isInitialLoading: isFxInitialLoading,
    isFetching: isFxFetching,
    error: fxError,
  } = useQuery<FxSeriesOutput>(
    ["fxSeries", "USD", fxQuote, fxDays],
    () => apiClient.getFxSeries({ base: "USD", quote: fxQuote, days: fxDays }),
    {
      enabled: !!showFx,
      keepPreviousData: true,
      refetchOnWindowFocus: false,
      refetchInterval: 2 * 60 * 1000,
    },
  );

  const fxPoints = fxSeries?.points ?? [];
  const fxLatest = fxPoints.length
    ? Number(fxPoints[fxPoints.length - 1]?.v)
    : NaN;
  const fxFirst = fxPoints.length ? Number(fxPoints[0]?.v) : NaN;
  const fxChangePct =
    Number.isFinite(fxLatest) && Number.isFinite(fxFirst) && fxFirst !== 0
      ? ((fxLatest - fxFirst) / fxFirst) * 100
      : NaN;

  const fxFormatted = React.useMemo(() => {
    if (!Number.isFinite(fxLatest)) return "—";
    try {
      const maxFraction = fxQuote === "JPY" ? 2 : 4;
      const minFraction = fxQuote === "JPY" ? 0 : Math.min(2, maxFraction);
      return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: fxQuote,
        maximumFractionDigits: maxFraction,
        minimumFractionDigits: minFraction,
      }).format(fxLatest);
    } catch {
      return fxLatest.toLocaleString("en-US", { maximumFractionDigits: 4 });
    }
  }, [fxLatest, fxQuote]);

  return (
    <>
      {successOverlay ? (
        <div className="fixed inset-0 z-50 flex items-center justify-center pp-topup-overlay backdrop-blur">
          <div className="flex flex-col items-center gap-3">
            <CoinIcon className="h-20 w-20 animate-spin" />
            <div className="text-sm font-semibold text-white">
              PP coins are being credited…
            </div>
          </div>
        </div>
      ) : null}

      {variant === "inline" ? (
        <div className="grid gap-2 w-full">
          <div className="grid gap-1">
            <Label
              className={`text-[11px] ${
                uiStyle === "tour" ? "text-primary-foreground/80" : ""
              }`}
            >
              {amountUnit === "PPc" ? "Amount (PPc)" : "Amount (USD)"}
            </Label>
            <div className="flex items-center gap-2">
              <Input
                className={`flex-1 ${
                  uiStyle === "tour"
                    ? "h-11 rounded-full bg-white/10 text-primary-foreground placeholder:text-primary-foreground/60 border-white/20"
                    : ""
                }`}
                inputMode="decimal"
                type="tel"
                placeholder={amountUnit === "PPc" ? "e.g. 100" : "e.g. 37"}
                value={amount}
                onChange={(e) => {
                  setAmount(e.target.value);
                  setInlineError("");
                }}
                disabled={keypadDisabled}
              />
              <Button
                variant={uiStyle === "tour" ? "secondary" : "default"}
                className={`shrink-0 px-3 ${
                  uiStyle === "tour"
                    ? "h-11 rounded-full bg-white/15 text-primary-foreground border border-white/20 hover:bg-white/20"
                    : ""
                }`}
                disabled={ctaDisabled}
                onClick={commitTopup}
              >
                {addCoins.isLoading
                  ? "Adding…"
                  : (confirmLabel ??
                    (amountUnit === "PPc" ? "CONFIRM" : "Add"))}
              </Button>
            </div>

            {inlineError ? (
              <div
                className={`text-[11px] ${
                  uiStyle === "tour"
                    ? "text-primary-foreground/70"
                    : "text-muted-foreground"
                }`}
              >
                {inlineError}
              </div>
            ) : amount && !(parsed > 0) ? (
              <div
                className={`text-[11px] ${
                  uiStyle === "tour"
                    ? "text-primary-foreground/70"
                    : "text-muted-foreground"
                }`}
              >
                Invalid amount.
              </div>
            ) : null}

            {isGuest ? (
              <div
                className={`text-[11px] ${
                  uiStyle === "tour"
                    ? "text-primary-foreground/70"
                    : "text-muted-foreground"
                }`}
              >
                Top up is not available without login.
              </div>
            ) : null}
          </div>

          {showFx ? (
            <FxPanel
              quote={fxQuote}
              onChangeQuote={setFxQuote}
              latestLabel={fxFormatted}
              changePct={fxChangePct}
              points={fxPoints}
              loading={isFxInitialLoading}
              refreshing={isFxFetching}
              hasError={!!fxError}
              fetchedAt={fxSeries?.fetchedAt}
              days={fxDays}
              onChangeDays={setFxDays}
            />
          ) : null}
        </div>
      ) : (
        <div className="w-full max-w-[440px] mx-auto px-2 sm:px-0">
          <div className="pp-topup-shell rounded-[28px] p-5 sm:p-6 md:p-7">
            <div className="flex items-center justify-between">
              <button
                type="button"
                className="pp-topup-chip pp-press-blue h-10 w-10 rounded-full inline-flex items-center justify-center"
                onClick={() => {
                  try {
                    if (window.history.length > 1) navigate(-1);
                    else navigate("/portfolio");
                  } catch {
                    navigate("/portfolio");
                  }
                }}
                aria-label="Back"
              >
                <ArrowLeft className="h-5 w-5" />
              </button>

              <div className="pp-topup-chip h-10 px-3 rounded-full inline-flex items-center gap-2 text-sm">
                <span>USD</span>
                <span className="text-xs opacity-70">▼</span>
              </div>
            </div>

            <div className="mt-6 text-center">
              <div className="text-[36px] sm:text-[44px] md:text-[48px] leading-none font-semibold tracking-tight tabular-nums">
                {formatBigAmount()}
              </div>
              <div className="mt-2 text-sm pp-topup-muted">
                {parsed > 0 && Number.isFinite(parsed)
                  ? `${parsed.toFixed(2)} PPc`
                  : "Enter an amount"}
              </div>
            </div>

            <div className="mt-5">
              <div className="pp-topup-asset rounded-2xl px-4 py-3.5 flex items-center justify-between gap-3">
                <div className="flex items-center gap-3 min-w-0">
                  <div className="pp-topup-asset-icon rounded-full h-9 w-9 flex items-center justify-center shrink-0">
                    <CoinIcon className="h-5 w-5" />
                  </div>
                  <div className="min-w-0">
                    <div className="font-medium truncate">PP Coin</div>
                    <div className="text-xs pp-topup-muted truncate">PPc</div>
                  </div>
                </div>
                <div className="text-right">
                  <div className="font-medium">
                    {parsed > 0 && Number.isFinite(parsed)
                      ? currencyUSD(parsed)
                      : "$0"}
                  </div>
                  <div className="text-xs pp-topup-muted">
                    {parsed > 0 && Number.isFinite(parsed)
                      ? parsed.toFixed(2)
                      : "0"}
                  </div>
                </div>
              </div>
            </div>

            <div className="mt-4">
              <FxPanel
                quote={fxQuote}
                onChangeQuote={setFxQuote}
                latestLabel={fxFormatted}
                changePct={fxChangePct}
                points={fxPoints}
                loading={isFxInitialLoading}
                refreshing={isFxFetching}
                hasError={!!fxError}
                fetchedAt={fxSeries?.fetchedAt}
                days={fxDays}
                onChangeDays={setFxDays}
              />
            </div>

            <div className="mt-5 flex items-center justify-center gap-3">
              <button
                type="button"
                className="pp-topup-pill pp-press-blue flex-1 max-w-[180px] rounded-full px-5 h-11 text-sm"
                onClick={keypadClear}
                disabled={keypadDisabled}
              >
                CLEAR
              </button>
              <button
                type="button"
                className="pp-topup-pill pp-press-blue flex-1 max-w-[180px] rounded-full px-5 h-11 text-sm"
                onClick={() => {
                  // Visual-only (kept simple): no conversion, just a friendly hint.
                  toast({
                    title: "USD",
                    description: "Top-ups are entered in USD.",
                  });
                }}
                disabled={keypadDisabled}
              >
                USD ⇄
              </button>
            </div>

            <div className="mt-6 grid grid-cols-3 gap-2 sm:gap-3">
              {["1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "0", "⌫"].map(
                (k) => (
                  <button
                    key={k}
                    type="button"
                    className="pp-topup-key pp-press-blue h-14 sm:h-16 rounded-2xl text-[24px] sm:text-3xl"
                    onClick={() => {
                      if (k === "⌫") keypadBackspace();
                      else keypadAdd(k);
                    }}
                    disabled={keypadDisabled}
                    aria-label={k === "⌫" ? "Backspace" : k}
                  >
                    {k}
                  </button>
                ),
              )}
            </div>

            <div className="mt-6">
              <button
                type="button"
                className="pp-topup-cta pp-press-blue w-full h-14 sm:h-16 rounded-full text-base font-medium"
                onClick={commitTopup}
                disabled={ctaDisabled}
              >
                {addCoins.isLoading ? "Adding…" : "Continue"}
              </button>

              {amount && !(parsed > 0) && (
                <div className="mt-3 text-xs pp-topup-muted text-center">
                  Invalid amount.
                </div>
              )}
            </div>
          </div>

          {isGuest && (
            <div className="mt-3 text-xs text-muted-foreground text-center">
              Top up is not available without login.
            </div>
          )}
        </div>
      )}
    </>
  );
}

void PPCoinTopup;

function TopupScreen() {
  const { t } = useLang();
  const navigate = useNavigate();

  return (
    <ScreenContainer
      title={t("topupTitle") || "Add PP coins"}
      right={
        <Button
          variant="secondary"
          size="icon"
          className="h-11 w-11 md:h-8 md:w-8 rounded-full"
          onClick={() => {
            try {
              if (window.history.length > 1) navigate(-1);
              else navigate("/");
            } catch {
              navigate("/");
            }
          }}
          aria-label="Close"
          title="Close"
        >
          <X className="h-5 w-5 md:h-4 md:w-4" />
        </Button>
      }
    >
      <div className="mt-6 w-full flex justify-center">
        <div className="w-full max-w-[360px] px-3">
          <div className="rounded-2xl border bg-card p-5 sm:p-6">
            <div className="text-center">
              <div className="text-base sm:text-lg font-semibold tracking-tight">
                Add PP coins
              </div>
              <div className="mt-1 text-[11px] text-muted-foreground">
                PP coins ≈ 1 USD (reference only, not redeemable)
              </div>
            </div>

            <div className="mt-5">
              <PPCoinTopup
                variant="inline"
                amountUnit="PPc"
                confirmLabel="CONFIRM"
                showFx={false}
                redirectToWallet
              />
            </div>
          </div>
        </div>
      </div>
    </ScreenContainer>
  );
}

function QuickBuyScreen() {
  return <QuickBuyInnerScreen mode="buy" />;
}

function QuickSellScreen() {
  return <QuickBuyInnerScreen mode="sell" />;
}

type QuickMode = "buy" | "sell";

function QuickBuyInnerScreen({ mode }: { mode: QuickMode }) {
  const isGuest = useIsGuest();
  const { toast } = useToast();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const supa = useSupabase();

  const accessToken =
    supa.accessToken ??
    (typeof window !== "undefined"
      ? (window as any).__supaAccessToken
      : undefined) ??
    undefined;

  const [qty, setQty] = useState<string>("");
  const [price, setPrice] = useState<string>("");
  const [useCustomPrice, setUseCustomPrice] = useState(true);
  const [perM2Prices, setPerM2Prices] = useState<string[]>([]);

  const [quickBuySuccessOpen, setQuickBuySuccessOpen] = useState(false);
  const [quickBuySuccessM2, setQuickBuySuccessM2] = useState(0);
  const [quickBuySuccessFocus, setQuickBuySuccessFocus] = useState<{
    x: number;
    y: number;
  } | null>(null);

  const [quickBuyInfo, setQuickBuyInfo] = useState<{
    m2: number;
    totalUSD: string;
  } | null>(null);
  const [quickBuyConfirm, setQuickBuyConfirm] = useState<{
    m2: number;
    totalUSD: string;
  } | null>(null);

  const [showSuccessOverlay, setShowSuccessOverlay] = useState(false);
  const triggerSuccess = () => {
    setShowSuccessOverlay(true);
    window.setTimeout(() => setShowSuccessOverlay(false), 3000);
  };

  const quickBuyMutation = useMutation(apiClient.quickBuy, {
    onSuccess: async (res: any) => {
      setQty("");
      await Promise.all([
        queryClient.invalidateQueries(["market"]),
        queryClient.invalidateQueries(["portfolio"]),
        queryClient.invalidateQueries(["certificates"]),
        // Also refresh owned plots so freshly bought Main Market m² can be listed immediately.
        queryClient.invalidateQueries(["myPlots"]),
        queryClient.invalidateQueries(["myPlots_2nd"]),
      ]);
      const placed = (res as any)?.placed as
        | Array<{ x: number; y: number }>
        | undefined;
      if (!placed || placed.length === 0) {
        toast({
          title: "No purchase executed",
          description: "Server returned no placed tiles. Buy did not happen.",
        });
        return;
      }

      const m2 = Math.max(0, Number(placed?.length ?? 0));
      setQuickBuySuccessM2(m2);
      setQuickBuySuccessFocus(placed?.[0] ?? null);
      setQuickBuySuccessOpen(true);
      window.setTimeout(() => triggerSuccess(), 50);
      setPerM2Prices([]);
    },
    onError: (e: any) =>
      toast({ title: "Purchase failed", description: e?.message }),
  });

  const { data: market } = useQuery<MarketOutput>(["market"], () =>
    apiClient.getMarket(),
  );

  const quickSellMutation = useMutation(apiClient.quickSellOwnedPlots, {
    onSuccess: async (res: any) => {
      const created = Number(res?.created ?? 0);
      setQty("");
      setPrice("");
      await Promise.all([
        queryClient.invalidateQueries(["secondaryListings"]),
        queryClient.invalidateQueries(["activeListings"]),
        queryClient.invalidateQueries(["myPlots"]),
      ]);
      toast({
        title: created > 0 ? "Quick Sell created" : "Nothing listed",
        description:
          created > 0
            ? `${created} m² were listed on the 2nd Market.`
            : "No free m² could be found.",
      });
      if (created > 0) {
        navigate("/second-market?viewFilter=MINE");
      }
    },
    onError: (e: any) =>
      toast({ title: "Quick sell failed", description: e?.message }),
  });

  const proceedAfterQuickBuySuccess = () => {
    setQuickBuySuccessOpen(false);
    const f = quickBuySuccessFocus;
    if (f) {
      navigate(`/map?focusX=${f.x}&focusY=${f.y}`);
    } else {
      navigate("/map");
    }
  };

  const handleSubmit = () => {
    const n = parseInt(qty || "1", 10);

    if (!Number.isFinite(n) || n < 1) return;

    if (mode === "buy") {
      // kein direktes Weiterleiten hier!
      // QuickBuy entscheidet in quickBuyMutation.onSuccess anhand von placed[]
      quickBuyMutation.mutate({
        m2: n,
        accessToken: accessToken ?? undefined,
      });

      return;
    }

    const m2 = Math.floor(n);

    // If you sell more than 1 m², each m² can have its own price
    const pricesArr = perM2Prices.length
      ? perM2Prices
      : Array.from({ length: m2 }, () => price);

    if (pricesArr.length !== m2) {
      toast({
        title: "Missing price",
        description: "Please enter a sale price for each m².",
      });
      return;
    }

    const parsed = pricesArr.map((p) =>
      Number(
        String(p || "0")
          .replace(/[^0-9.,]/g, "")
          .replace(",", "."),
      ),
    );

    if (parsed.some((v) => !Number.isFinite(v) || v <= 0)) {
      toast({
        title: "Invalid price",
        description: "All prices per m² must be greater than 0.",
      });
      return;
    }

    if (isGuest) {
      try {
        window.dispatchEvent(new Event("openSignIn"));
      } catch {}
      return;
    }

    quickSellMutation.mutate({
      pricesEUR: parsed.map((v) => Math.round(v * 100) / 100),
      accessToken,
    });
  };

  const disabled =
    !qty ||
    (mode === "sell" && isGuest) ||
    quickBuyMutation.isLoading ||
    quickSellMutation.isLoading ||
    (mode === "sell" && !market);

  return (
    <ScreenContainer title={mode === "buy" ? "Quick Buy" : "Quick Sell"}>
      {/* Quick Buy success info */}
      <Dialog
        open={quickBuySuccessOpen}
        onOpenChange={(v) => {
          // If user closes it, we still take them to the map (same as Weiter)
          if (!v && quickBuySuccessOpen) {
            proceedAfterQuickBuySuccess();
            return;
          }
          setQuickBuySuccessOpen(!!v);
        }}
      >
        <DialogContent className="w-[calc(100vw-20px)] max-w-[440px] p-4 sm:p-6 max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="text-lg sm:text-xl font-extrabold tracking-tight">
              <span className="text-muted-foreground">NEW</span>{" "}
              {quickBuySuccessM2.toLocaleString()} m² (Main Market)
            </DialogTitle>
            <DialogDescription className="text-sm sm:text-base leading-snug text-foreground">
              <ol className="mt-3 list-decimal pl-5 space-y-1.5">
                <li>Build islands (from +2 m²)</li>
                <li>Usable instantly &amp; sellable</li>
                <li>Fully flexible: buy / sell / build</li>
                <li>For expansion &amp; growth</li>
                <li>Faster progress</li>
              </ol>
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="mt-4">
            <Button
              className="w-full rounded-full text-sm sm:text-base py-5"
              onClick={proceedAfterQuickBuySuccess}
            >
              Continue
            </Button>{" "}
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {showSuccessOverlay && (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/40 backdrop-blur-sm">
          <div className="success-pop rounded-full w-28 h-28 bg-background border-4 border-green-500 flex items-center justify-center shadow-xl">
            <CheckCircle2 className="h-16 w-16 text-green-500" />
          </div>
        </div>
      )}

      {/* Quick Buy info popup (before buy confirmation) */}
      <AlertDialog
        open={!!quickBuyInfo}
        onOpenChange={(v) => !v && setQuickBuyInfo(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Main Market m²</AlertDialogTitle>
            <AlertDialogDescription>
              {quickBuyInfo ? (
                <div className="space-y-3 text-base">
                  <div className="rounded-lg border bg-muted/30 p-3 text-sm">
                    <ul className="list-disc pl-5 space-y-2">
                      <li>
                        Main Market m² is usable instantly after you buy it.
                      </li>
                      <li>
                        You can create islands only with{" "}
                        <span className="font-medium">2 new m²</span> bought
                        directly from the Main Market.
                      </li>
                      <li>
                        Newly bought Main Market m² can be listed immediately on
                        the 2nd Market.
                      </li>
                    </ul>
                  </div>
                  <div>
                    You are about to buy{" "}
                    <span className="font-medium">
                      {quickBuyInfo.m2.toLocaleString()} m²
                    </span>{" "}
                    for{" "}
                    <span className="font-medium">{quickBuyInfo.totalUSD}</span>
                    .
                  </div>
                </div>
              ) : (
                ""
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setQuickBuyInfo(null)}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                if (!quickBuyInfo) return;
                setQuickBuyConfirm({ ...quickBuyInfo });
                setQuickBuyInfo(null);
              }}
            >
              Continue
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Quick Buy confirmation (before final purchase) */}
      <AlertDialog
        open={!!quickBuyConfirm}
        onOpenChange={(v) => !v && setQuickBuyConfirm(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm purchase</AlertDialogTitle>
            <AlertDialogDescription>
              {quickBuyConfirm
                ? `You are about to buy ${quickBuyConfirm.m2.toLocaleString()} m² for ${quickBuyConfirm.totalUSD}. This will be deducted from your balance.`
                : ""}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setQuickBuyConfirm(null)}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                if (!quickBuyConfirm) return;
                if (isGuest) {
                  setQuickBuyConfirm(null);
                  try {
                    window.dispatchEvent(new Event("openSignIn"));
                  } catch {}
                  return;
                }
                quickBuyMutation.mutate({
                  m2: quickBuyConfirm.m2,
                  accessToken,
                });
                setQuickBuyConfirm(null);
              }}
            >
              Confirm purchase
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <div className="mt-6 w-full max-w-lg mx-auto">
        <Card className="py-8">
          <CardHeader className="text-center pb-2">
            <CardTitle className="text-2xl font-extrabold tracking-wide">
              {mode === "buy" ? "QUICK BUY" : "QUICK SELL"}
            </CardTitle>
          </CardHeader>
          <CardContent className="grid gap-4">
            <div className="w-full flex items-center gap-2">
              <Input
                type="tel"
                inputMode="numeric"
                pattern="[0-9]*"
                value={qty}
                onChange={(e) => setQty(e.target.value.replace(/\D+/g, ""))}
                placeholder="m² amount"
                className="flex-1"
              />
            </div>
            {mode === "sell" && (
              <div className="grid gap-2 text-sm">
                <div className="flex items-center justify-between gap-2">
                  <Label className="text-xs">Price per m²</Label>{" "}
                  <div className="text-[11px] text-muted-foreground">
                    Current market price:{" "}
                    {currencyUSD(market?.pricePerM2CHF ?? 0)}
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <Switch
                    checked={useCustomPrice}
                    onCheckedChange={(v) => setUseCustomPrice(!!v)}
                    id="qs-custom-price"
                  />
                  <Label
                    htmlFor="qs-custom-price"
                    className="text-xs cursor-pointer"
                  >
                    Set a custom price
                  </Label>{" "}
                </div>
                {useCustomPrice ? (
                  <div className="grid gap-1">
                    <Input
                      type="tel"
                      inputMode="decimal"
                      value={price}
                      onChange={(e) =>
                        setPrice(
                          e.target.value
                            .replace(/[^0-9.,]/g, "")
                            .replace(",", "."),
                        )
                      }
                      placeholder="e.g. 150 (USD per m²)"
                    />
                    {Number(qty || 0) > 1 && (
                      <div className="grid gap-1 border rounded-md p-2 max-h-40 overflow-y-auto text-xs">
                        <div className="font-medium">
                          Individual prices per m² (optional override):
                        </div>{" "}
                        {Array.from({
                          length: Math.min(20, Number(qty || 0)),
                        }).map((_v, idx) => (
                          <div
                            key={idx}
                            className="flex items-center gap-1 text-xs"
                          >
                            <span className="w-8 shrink-0">m² {idx + 1}</span>
                            <Input
                              type="tel"
                              inputMode="decimal"
                              className="h-7 text-xs flex-1"
                              value={perM2Prices[idx] ?? ""}
                              placeholder={price || "e.g. 150"}
                              onChange={(e) => {
                                const v = e.target.value;
                                setPerM2Prices((prev) => {
                                  const next = prev.slice();
                                  next[idx] = v;
                                  return next;
                                });
                              }}
                            />
                          </div>
                        ))}
                        {Number(qty || 0) > 20 && (
                          <div className="text-[10px] text-muted-foreground">
                            Note: For more than 20 m², the remaining m² will be
                            listed using the default price above.
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    If you don’t set a custom price, we will automatically pick
                    a price up to 50 USD below the current m² price.
                  </div>
                )}
              </div>
            )}
            <Button
              onClick={handleSubmit}
              disabled={disabled}
              className="rounded-full bg-primary text-primary-foreground hover:bg-primary/90 px-6 sm:px-8 py-3 sm:py-4 text-sm sm:text-base font-extrabold tracking-wide shadow-md"
            >
              {mode === "buy"
                ? quickBuyMutation.isLoading
                  ? "Buying..."
                  : "QUICK BUY"
                : quickSellMutation.isLoading
                  ? "Selling..."
                  : "QUICK SELL"}
            </Button>
            <div className="text-[11px] text-muted-foreground text-center">
              {mode === "buy"
                ? "Your m² will be placed automatically on available tiles."
                : "Each listing corresponds to exactly 1 m² at your chosen price."}{" "}
            </div>{" "}
          </CardContent>
        </Card>
      </div>
    </ScreenContainer>
  );
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function PriceHistoryButton_UNUSED() {
  // Redesigned chart modal to closely match the provided reference
  const [open, setOpen] = useState(false);
  useEffect(() => {
    console.log(open ? "Charts: opened" : "Charts: closed");
  }, [open]);

  // Dynamic chart that reacts to real market data
  type RangeKey = "WEEK" | "MONTH" | "MAX";
  const [range, setRange] = useState<RangeKey>("MAX");
  const width = 320;
  const height = 140;
  const minutesForRange = (r: RangeKey) =>
    r === "WEEK" ? 60 * 24 * 7 : r === "MONTH" ? 60 * 24 * 30 : 60 * 24 * 365;

  const { data: history } = useQuery<PriceHistoryOutput>(
    ["priceHistory_card", range, open],
    () => apiClient.getPriceHistory({ minutes: minutesForRange(range) }),
    { enabled: open, retry: 1 },
  );
  const { data: marketNow } = useQuery<MarketOutput>(
    ["market", "chart", open],
    () => apiClient.getMarket(),
    { enabled: open, retry: 1 },
  );

  const prices = (history ?? []).map((d) => d.price);
  const n = Math.max(2, prices.length || 2);
  const pmin = prices.length ? Math.min(...prices) : 0;
  const pmax = prices.length ? Math.max(...prices) : 1;
  const step = width / (n - 1);
  const normalize = (p: number) => (p - pmin) / Math.max(1e-9, pmax - pmin);
  const padTop = 12;
  const usable = height - padTop;
  const toY = (p: number) => padTop + usable * (1 - normalize(p));
  const eps = 1e-6;
  const isFlat =
    prices.length >= 2 ? Math.abs(pmax - pmin) < eps : prices.length === 1;
  const yBase = Math.round(height * 0.62);

  const points: Array<[number, number]> =
    prices.length >= 2 && !isFlat
      ? prices.map((p, i) => [i * step, toY(p)] as [number, number])
      : prices.length >= 1
        ? ([
            [0, yBase],
            [width, yBase],
          ] as Array<[number, number]>)
        : ([
            [0, yBase],
            [width, yBase],
          ] as Array<[number, number]>);

  const path = "M " + points.map(([x, y]) => `${x},${y}`).join(" L ");
  const end = points[points.length - 1]!;

  const openP = prices[0] ?? marketNow?.pricePerM2CHF ?? 0;
  const last = prices.length
    ? prices[prices.length - 1]!
    : (marketNow?.pricePerM2CHF ?? 0);
  const change = last - openP;
  const changePct = openP ? (change / openP) * 100 : 0;

  // Extended helpers for the (legacy) detailed section below
  const min = pmin;
  const max = pmax;
  const formatSwiss = (num: number, digits = 2) => {
    const s = num.toFixed(digits);
    const parts = s.split(".");
    const intRaw = parts[0] ?? "0";
    const dec = parts[1] ?? "";
    const intFmt = intRaw.replace(/\B(?=(\d{3})+(?!\d))/g, "'");
    return dec ? `${intFmt}.${dec}` : intFmt;
  };
  const formatSwiss2 = (num: number) => formatSwiss(num, 2);
  const isError = false;
  const isFetching = false;
  const refetch = () => {
    /* no-op */
  };
  const RangeTabs = null as unknown as React.ReactNode;
  const linePath = "";
  const areaPath = "";
  const high52 = undefined as unknown as number;
  const low52 = undefined as unknown as number;

  return (
    <Drawer open={open} onOpenChange={setOpen}>
      <DrawerTrigger asChild>
        <Button variant="secondary" size="sm" aria-label="Charts">
          Charts
        </Button>
      </DrawerTrigger>
      <DrawerContent>
        <DrawerHeader className="text-left">
          <DrawerTitle>Chart</DrawerTitle>
          <DrawerDescription>Overview</DrawerDescription>
        </DrawerHeader>
        <div className="px-4 pb-6 flex justify-center">
          {/* Card styled like the screenshot */}
          <div className="w-[360px] rounded-2xl border bg-[#0e1011] text-white relative overflow-hidden shadow-lg">
            {/* green bottom gradient */}
            <div
              className="absolute inset-0 pointer-events-none"
              style={{
                background:
                  "linear-gradient(180deg, rgba(0,0,0,0) 55%, rgba(0, 130, 80, 0.25) 100%)",
              }}
            />
            <div className="p-4 pb-2 flex items-start justify-between">
              <div className="text-sm font-semibold text-zinc-200">Chart</div>
              <button className="text-zinc-400" aria-label="settings">
                ⚙️
              </button>
            </div>

            {/* Segmented control */}
            <div className="px-4 mt-3">
              <div className="bg-zinc-800/70 rounded-xl p-1 inline-flex gap-1">
                <button
                  onClick={() => setRange("WEEK")}
                  className={`px-3 py-1 rounded-lg text-xs ${range === "WEEK" ? "bg-zinc-900 text-white border border-zinc-700" : "text-zinc-400"}`}
                >
                  Week
                </button>
                <button
                  onClick={() => setRange("MONTH")}
                  className={`px-3 py-1 rounded-lg text-xs ${range === "MONTH" ? "bg-zinc-900 text-white border border-zinc-700" : "text-zinc-400"}`}
                >
                  Month
                </button>
                <button
                  onClick={() => setRange("MAX")}
                  className={`px-3 py-1 rounded-lg text-xs ${range === "MAX" ? "bg-zinc-900 text-white border border-zinc-700" : "text-zinc-400"}`}
                >
                  Max
                </button>
              </div>
            </div>

            {/* Chart */}
            <div className="px-2 pt-2">
              <svg
                viewBox={`0 0 ${width} ${height}`}
                className="w-full h-[140px]"
              >
                {/* grid lines */}
                {Array.from({ length: 6 }).map((_, i) => {
                  const x = (i + 1) * (width / 7);
                  return (
                    <line
                      key={i}
                      x1={x}
                      y1={12}
                      x2={x}
                      y2={height}
                      stroke="#c7d2fe"
                      strokeWidth={1}
                    />
                  );
                })}
                {/* baseline gradient */}
                <defs>
                  <linearGradient id="lineGrad" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stopColor="#78f5c9" stopOpacity="1" />
                    <stop offset="100%" stopColor="#78f5c9" stopOpacity="1" />
                  </linearGradient>
                  <filter
                    id="glow"
                    x="-100%"
                    y="-100%"
                    width="300%"
                    height="300%"
                  >
                    <feDropShadow
                      dx="0"
                      dy="0"
                      stdDeviation="4.5"
                      floodColor="#78f5c9"
                      floodOpacity="1"
                    />
                    <feDropShadow
                      dx="0"
                      dy="0"
                      stdDeviation="7"
                      floodColor="#78f5c9"
                      floodOpacity="0.75"
                    />
                  </filter>
                </defs>
                {/* dark outline for contrast */}
                <path
                  d={path}
                  fill="none"
                  stroke="#050812"
                  strokeWidth={6}
                  strokeLinejoin="round"
                  strokeLinecap="round"
                  opacity={1}
                />
                {/* bright line with glow (solid fallback + gradient overlay) */}
                <path
                  d={path}
                  fill="none"
                  stroke="#78f5c9"
                  strokeWidth={6.5}
                  strokeLinejoin="round"
                  strokeLinecap="round"
                  filter="url(#glow)"
                  opacity={0.95}
                  shapeRendering="geometricPrecision"
                />
                <path
                  d={path}
                  fill="none"
                  stroke="url(#lineGrad)"
                  strokeWidth={4}
                  strokeLinejoin="round"
                  strokeLinecap="round"
                  filter="url(#glow)"
                />
                {/* thin inner highlight */}
                <path
                  d={path}
                  fill="none"
                  stroke="#ffffff"
                  strokeOpacity={0.8}
                  strokeWidth={1.4}
                  strokeLinejoin="round"
                  strokeLinecap="round"
                />
                {/* end point circle */}{" "}
                <circle
                  cx={end[0]}
                  cy={end[1]}
                  r={6}
                  fill="#0b1511"
                  stroke="#78f5c9"
                  strokeWidth={4}
                  filter="url(#glow)"
                />
              </svg>
            </div>

            {/* Bottom metrics tied to live price */}
            <div className="px-4 pb-4 flex items-end justify-between">
              <div>
                <div className="text-[11px] text-zinc-400">Current price</div>
                <div className="text-3xl font-extrabold tracking-tight">
                  {currencyUSD(last)}{" "}
                  <span
                    className={`${change >= 0 ? "text-emerald-400" : "text-red-400"} align-middle text-base`}
                  >
                    {change >= 0 ? "+" : "−"}
                    {currencyUSD(Math.abs(change))}
                  </span>
                </div>
              </div>
              <div
                className={`${change >= 0 ? "text-emerald-400" : "text-red-400"} text-sm font-semibold`}
              >
                {change >= 0 ? "↗" : "↘"} {Math.abs(changePct).toFixed(1)}%
              </div>
            </div>
          </div>
        </div>
        <DrawerFooter className="pt-2">
          <Button variant="secondary" onClick={() => setOpen(false)}>
            Close
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );

  return (
    <Drawer open={open} onOpenChange={setOpen}>
      <DrawerTrigger asChild>
        <Button variant="secondary" size="sm" aria-label="Charts">
          Charts
        </Button>
      </DrawerTrigger>
      <DrawerContent>
        <DrawerHeader className="text-left relative">
          {/* Close controls: prominent Close + top-right X */}
          <DrawerClose asChild>
            <button
              aria-label="Close"
              className="absolute right-2 top-2 rounded-full p-2 hover:bg-secondary active:scale-95 transition-transform"
            >
              <X className="h-4 w-4" />
            </button>
          </DrawerClose>
          <DrawerClose asChild>
            <Button
              size="sm"
              variant="secondary"
              className="absolute right-10 top-2"
              aria-label="Close chart"
            >
              Close
            </Button>
          </DrawerClose>

          <div className="flex items-start justify-between min-h-[64px]">
            <div>
              <div className="text-2xl font-extrabold leading-tight">
                PP15 ESTATES
              </div>
              <div className="text-xs text-muted-foreground">
                Price per m² • USD
              </div>
            </div>
            <div
              className={`${change >= 0 ? "text-green-600" : "text-red-600"} text-right tabular-nums`}
            >
              <div className="text-xl font-bold">
                {formatSwiss2(last as number)}
              </div>
              <div className="text-xs">
                {change >= 0 ? "+" : ""}
                {formatSwiss2(Math.abs(change))} ({change >= 0 ? "+" : ""}
                {changePct.toFixed(2)}%)
              </div>
            </div>
          </div>
          <div className="mt-3 min-h-[36px]">{RangeTabs}</div>
        </DrawerHeader>
        <div className="px-4 pb-4 grid gap-3 min-h-[520px]">
          <div className="rounded-xl border p-3">
            <svg
              viewBox={`0 0 ${width} ${height}`}
              className="w-full h-[220px]"
            >
              {Array.from({ length: 4 }).map((_, i) => {
                const y = (i + 1) * (height / 5);
                const value = min + ((height - y) / height) * (max - min);
                return (
                  <g key={i}>
                    <line
                      x1={0}
                      x2={width}
                      y1={y}
                      y2={y}
                      stroke="hsl(var(--muted-foreground))"
                      opacity={0.2}
                    />
                    <text
                      x={width - 6}
                      y={y - 2}
                      textAnchor="end"
                      fontSize={10}
                      fill="hsl(var(--muted-foreground))"
                    >
                      {formatSwiss(value, 0)}
                    </text>
                  </g>
                );
              })}
              {/* vertical grid lines */}
              {Array.from({ length: 5 }).map((_, i) => {
                const x = (i + 1) * (width / 6);
                return (
                  <line
                    key={`vl-${i}`}
                    x1={x}
                    x2={x}
                    y1={0}
                    y2={height}
                    stroke="hsl(var(--muted-foreground))"
                    opacity={0.15}
                  />
                );
              })}
              {/* bottom baseline */}
              <line
                x1={0}
                x2={width}
                y1={height}
                y2={height}
                stroke="hsl(var(--muted-foreground))"
                strokeDasharray="3 4"
                opacity={0.4}
              />
              {n > 1 ? (
                <>
                  {/* green area & line to match reference */}
                  <path d={areaPath} fill="hsl(var(--owned) / 0.20)" />
                  <path
                    d={linePath}
                    fill="none"
                    stroke="#78f5c9"
                    strokeWidth={6}
                  />
                  {/* micro volume bars */}
                  {prices.map((p, i) => {
                    const prev = i > 0 ? prices[i - 1]! : p;
                    const delta = Math.abs(p - prev);
                    const h = Math.min(
                      16,
                      (delta / Math.max(1, max - min)) * 120,
                    );
                    const x = i * step;
                    return (
                      <rect
                        key={`v-${i}`}
                        x={Math.max(0, x - 1)}
                        y={height - h}
                        width={2}
                        height={h}
                        fill="hsl(var(--muted-foreground))"
                        opacity={0.25}
                      />
                    );
                  })}
                </>
              ) : (
                <path
                  d={`M 0,${height / 2} L ${width},${height / 2}`}
                  fill="none"
                  stroke="hsl(var(--muted-foreground))"
                  strokeDasharray="4 4"
                  strokeWidth={2}
                />
              )}
            </svg>
          </div>

          <div className="grid grid-cols-2 sm:grid-cols-4 gap-x-6 gap-y-2 text-xs tabular-nums">
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">Open</span>
              <span className="font-semibold">
                {formatSwiss2(openP as number)}
              </span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">High</span>
              <span className="font-semibold">{formatSwiss(max, 2)}</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">Low</span>
              <span className="font-semibold">{formatSwiss(min, 2)}</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">Vol.</span>
              <span className="font-semibold">–</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">KGV</span>
              <span className="font-semibold">–</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">Mkt cap</span>
              <span className="font-semibold">–</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">52W-H</span>
              <span className="font-semibold">
                {high52 ? formatSwiss2(high52) : "–"}
              </span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">52W-L</span>
              <span className="font-semibold">
                {low52 ? formatSwiss2(low52) : "–"}
              </span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">Avg vol.</span>
              <span className="font-semibold">–</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">Yield</span>
              <span className="font-semibold">–</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">Beta</span>
              <span className="font-semibold">–</span>
            </div>
            <div className="flex items-center justify-between border-b pb-1">
              <span className="text-muted-foreground">EPS</span>
              <span className="font-semibold">–</span>
            </div>
          </div>

          {isError && (
            <Alert className="mt-1">
              <AlertDescription className="text-xs">
                Could not load chart.
                <Button
                  size="sm"
                  variant="secondary"
                  className="ml-2"
                  onClick={() => refetch()}
                >
                  Reload
                </Button>
              </AlertDescription>
            </Alert>
          )}
          {isFetching && (
            <div className="text-xs text-muted-foreground">Updating…</div>
          )}
        </div>
        <DrawerFooter className="pt-2">
          <Button variant="secondary" onClick={() => setOpen(false)}>
            Close
          </Button>
        </DrawerFooter>
      </DrawerContent>
    </Drawer>
  );
}

// Islands UI (list + create form) — backend follows in next steps
function IslandsScreen() {
  const queryClient = useQueryClient();

  const { toast } = useToast();
  const [searchParams, setSearchParams] = useSearchParams();
  const needCreate = searchParams.get("create") === "1";
  const auth = useAuth();
  const supa = useSupabase();
  const isGuest = useIsGuest();
  const actorId =
    ((supa as any)?.user?.id as string | undefined) ?? auth.userId;
  const isAuthed =
    !!((supa as any)?.user?.id as string | undefined) ||
    (auth as any)?.status === "authenticated";
  const accessToken =
    ((supa as any)?.accessToken as string | null | undefined) ??
    ((window as any).__supaAccessToken as string | null | undefined) ??
    undefined;

  const promptSignIn = () => {
    try {
      window.dispatchEvent(new Event("openSignIn"));
    } catch {}
  };

  // DraftIsland type removed — only real/public islands are shown

  // removed drafts logic – only published islands are displayed

  // drafts removed
  const navigate = useNavigate();
  const {
    data: publishedIslands,
    isInitialLoading: islandsInitialLoading,
    isFetching: islandsIsFetching,
    dataUpdatedAt: islandsUpdatedAt,
    isError: islandsIsError,
    error: islandsError,
    refetch: refetchIslands,
  } = useQuery<any[]>(["islands_list"], () => apiClient.listIslands(), {
    refetchOnWindowFocus: false,
    refetchOnReconnect: true,
    // Keep the list as live as possible while this screen is open.
    refetchOnMount: true,
    retry: 1,
    staleTime: 2_000,
    refetchInterval: 5_000,
    refetchIntervalInBackground: false,
    // Keep previous data while updating to avoid empty/flash states.
    placeholderData: () =>
      (queryClient.getQueryData<any[]>(["islands_list"]) ?? []) as any[],
  });

  const [createDiagId, setCreateDiagId] = useState<string>("");

  // create island mutation
  const createIslandMutation = useMutation(apiClient.createIsland, {
    onSuccess: (res: any) => {
      setCreateDiagId("");
      toast({ title: "Island created" });
      setOpen(false);
      clearParams();
      resetForm();
      queryClient.invalidateQueries(["islands_list"]);
      if (res?.island?.id) navigate(`/islands/${res.island.id}`);
    },
    onError: (err: any) => {
      const diagId = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
      setCreateDiagId(diagId);
      try {
        const msg1 =
          (err?.data?.message && String(err.data.message)) ||
          (err?.message && String(err.message)) ||
          "";
        const name1 = err?.name ? String(err.name) : "";
        const status1 =
          err?.status ?? err?.data?.status ?? err?.response?.status ?? null;
        console.log(
          "[ui:createIsland] failed:",
          msg1.slice(0, 220),
          name1 ? `name=${name1}` : "",
          status1 ? `status=${String(status1)}` : "",
          `diag=${diagId}`,
        );
      } catch {}
      const candidates = [
        err?.data?.message,
        err?.response?.data?.message,
        err?.error?.message,
        err?.cause?.message,
        err?.message,
      ]
        .map((v) => (typeof v === "string" ? v : ""))
        .map((s) => s.trim())
        .filter(Boolean);

      const raw = candidates[0] ?? "";
      const normalized = raw.trim();
      const lower = normalized.toLowerCase();

      const msg = lower.includes("name required")
        ? "Please enter an island name."
        : lower.includes("icon required")
          ? "Please choose an icon image."
          : lower.includes("icon") && lower.includes("upload")
            ? "The icon couldn't be uploaded. Please use a smaller image (max 2MB) and try again."
            : (lower.includes("max") &&
                  lower.includes("5") &&
                  lower.includes("%")) ||
                (lower.includes("step") && lower.includes("5"))
              ? "Please choose a maximum price change of 5%."
              : lower.includes("max") &&
                  (lower.includes("4000") || lower.includes("4,000"))
                ? "A maximum of 4,000 m² per island is allowed."
                : lower.includes("insufficient") || lower.includes("not enough")
                  ? "You need enough balance for the $5 start fee (plus any optional own m²)."
                  : lower.includes("internal server error") ||
                      lower.includes("server error") ||
                      normalized.length === 0
                    ? "Couldn't create the island right now.\n\nPlease quickly check:\n• Island name is set\n• Icon is selected (ideally < 2MB)\n• Start price is > 0\n• Max. 4,000 m²\n• Price change is max. 5%\n• Own m² (if set) is ≤ total m²"
                    : normalized;
      toast({
        title: "Create failed",
        description: `${msg}\n\nDiagnose-ID: ${diagId}`,
      });
    },
  });

  const deleteIslandMutation = useMutation(apiClient.deleteIsland, {
    onSuccess: () => {
      toast({ title: "Island deleted" });
      queryClient.invalidateQueries(["islands_list"]);
    },
    onError: (err: any) => {
      const candidates = [
        err?.data?.message,
        err?.response?.data?.message,
        err?.error?.message,
        err?.cause?.message,
        err?.message,
      ]
        .map((v) => (typeof v === "string" ? v : ""))
        .map((s) => s.trim())
        .filter(Boolean);

      const raw = candidates[0] ?? "";
      const normalized = raw.trim();
      const msg =
        normalized.length === 0
          ? "Couldn't delete the island right now. Please try again."
          : normalized;
      toast({ title: "Delete failed", description: msg });
    },
  });

  // Create drawer state
  const [open, setOpen] = useState<boolean>(needCreate);
  useEffect(() => {
    if (!needCreate) return;
    // If the user is in guest mode, redirect them into sign-in instead of showing the create flow.
    if (isGuest) {
      promptSignIn();
      clearParams();
      return;
    }
    setOpen(true);
  }, [needCreate, isGuest]);

  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [attemptedCreate, setAttemptedCreate] = useState(false);
  const [ticker, setTicker] = useState("");
  const [iconB64, setIconB64] = useState<string | undefined>(undefined);
  const createIconInputRef = useRef<HTMLInputElement | null>(null);
  const [supply, setSupply] = useState<string>("");
  const [ownM2, setOwnM2] = useState<string>("");
  const [price, setPrice] = useState<string>("");
  const [stepUpPct, setStepUpPct] = useState<string>("");
  const [isStepPctValid, setIsStepPctValid] = useState<boolean>(true);
  const [showMine, setShowMine] = useState(false);
  const [islandSearch, setIslandSearch] = useState("");
  const [sortKey, setSortKey] = useState<
    | "newest"
    | "oldest"
    | "m2_desc"
    | "m2_asc"
    | "price_desc"
    | "price_asc"
    | "available_m2_desc"
    | "available_m2_asc"
  >("newest");

  const formatPPC = (value: number | null | undefined) => {
    const n = Number(value ?? 0) || 0;
    const dec = Math.abs(n) < 100 ? 4 : 2;
    return `${n.toLocaleString("en-US", {
      minimumFractionDigits: dec,
      maximumFractionDigits: dec,
    })} PPC`;
  };

  const calcIslandPriceAtSold = (input: {
    startPrice: number;
    stepUpPct: number;
    totalSupplyM2: number;
    soldM2: number;
  }) => {
    const start = Number(input.startPrice || 0);
    const stepUp = Number(input.stepUpPct || 0);
    const supplyN = Math.max(1, Math.floor(Number(input.totalSupplyM2 || 1)));
    const soldN = Math.max(0, Number(input.soldM2 || 0));
    if (!Number.isFinite(start) || start <= 0) return 0;
    if (!Number.isFinite(stepUp) || stepUp === 0) return start;
    const stepUnitM2 = Math.max(1, supplyN / 100);
    const r = 1 + stepUp / 100;
    const exponent = soldN / stepUnitM2;
    const priceN = start * Math.pow(r, exponent);
    return Number.isFinite(priceN) && priceN >= 0 ? priceN : 0;
  };

  // Simple suggestion: more supply → smaller step suggestion
  const allIslands = (publishedIslands as any[]) ?? [];
  const myIslands =
    isAuthed && actorId
      ? allIslands.filter((it: any) => it?.owner?.id === actorId)
      : [];
  const baseIslands = showMine ? myIslands : allIslands;
  const normalizedSearch = islandSearch.trim().toLowerCase();
  const filteredIslands = normalizedSearch
    ? baseIslands.filter((it: any) => {
        const name1 = (it?.name ?? "").toString().toLowerCase();
        const ticker1 = (it?.ticker ?? "").toString().toLowerCase();
        const owner1 = (it?.owner?.handle ?? it?.owner?.name ?? "")
          .toString()
          .toLowerCase();
        return (
          name1.includes(normalizedSearch) ||
          ticker1.includes(normalizedSearch) ||
          owner1.includes(normalizedSearch)
        );
      })
    : baseIslands;

  const islandsToShow = [...filteredIslands].sort((a: any, b: any) => {
    if (sortKey === "newest") {
      const da = a.createdAt ? new Date(a.createdAt as any).getTime() : 0;
      const db = b.createdAt ? new Date(b.createdAt as any).getTime() : 0;
      return db - da;
    }
    if (sortKey === "oldest") {
      const da = a.createdAt ? new Date(a.createdAt as any).getTime() : 0;
      const db = b.createdAt ? new Date(b.createdAt as any).getTime() : 0;
      return da - db;
    }
    const totalA = Number(a.totalSupplyM2 ?? 0);
    const totalB = Number(b.totalSupplyM2 ?? 0);
    const ownedA = Number(a.ownerInitialM2 ?? 0);
    const ownedB = Number(b.ownerInitialM2 ?? 0);
    const availableA = Math.max(0, totalA - ownedA);
    const availableB = Math.max(0, totalB - ownedB);

    if (sortKey === "m2_desc") return totalB - totalA;
    if (sortKey === "m2_asc") return totalA - totalB;

    const priceA = Number(a.currentPriceUSD ?? a.startPriceUSD ?? 0);
    const priceB = Number(b.currentPriceUSD ?? b.startPriceUSD ?? 0);
    if (sortKey === "price_desc") return priceB - priceA;
    if (sortKey === "price_asc") return priceA - priceB;

    if (sortKey === "available_m2_desc") return availableB - availableA;
    if (sortKey === "available_m2_asc") return availableA - availableB;

    return 0;
  });

  const suggestedPct = (() => {
    const s = Number((supply || "").replace(",", "."));
    if (!Number.isFinite(s) || s <= 0) return 0.5; // default 0.5%
    // heuristic: ~ (5% * 10_000 / supply)^0.5 bounded 0.1%..5%
    const val = Math.sqrt((5 * 10000) / Math.max(1, s));
    return Math.max(0.1, Math.min(5, Number(val.toFixed(2))));
  })();

  const clearParams = () => {
    const p = new URLSearchParams(searchParams);
    p.delete("create");
    setSearchParams(p);
  };

  const resetForm = () => {
    setName("");
    setDescription("");
    setAttemptedCreate(false);
    setTicker("");
    setIconB64(undefined);
    setSupply("");
    setOwnM2("");
    setPrice("");
    setStepUpPct("");
    setIsStepPctValid(true);
  };

  const canCreate = () => {
    if (isGuest) return false;

    const nSupply = Number((supply || "").replace(",", "."));
    const nOwn = Number((ownM2 || "").replace(",", "."));
    const nPrice = Number((price || "").replace(",", "."));
    const nStepUp = Number((stepUpPct || "").replace(",", "."));

    const tickerOk =
      !ticker || (ticker.length <= 4 && /^[A-Z0-9]+$/.test(ticker));

    return (
      name.trim().length > 0 &&
      tickerOk &&
      !!iconB64 &&
      Number.isFinite(nSupply) &&
      nSupply > 0 &&
      nSupply <= 4000 &&
      (!ownM2 || (Number.isFinite(nOwn) && nOwn >= 0 && nOwn <= nSupply)) &&
      Number.isFinite(nPrice) &&
      nPrice > 0 &&
      (!stepUpPct || Number.isFinite(nStepUp)) &&
      isStepPctValid
    );
  };

  const createIslandLocal = () => {
    if (isGuest) {
      toast({
        title: "Sign in required",
        description: "Please sign in (Google or email) to create an island.",
      });
      promptSignIn();
      return;
    }

    setAttemptedCreate(true);
    if (!canCreate()) return;
    const nSupply = Number((supply || "").replace(",", "."));
    const nOwnRaw = Math.max(
      0,
      Math.floor(Number((ownM2 || "0").replace(/[^0-9]/g, "")) || 0),
    );
    const nOwn = Math.min(Math.floor(nSupply || 0), nOwnRaw);
    const nPrice = Number((price || "").replace(",", "."));
    const nStepUpRaw = (stepUpPct || "").trim();
    const nStepUp = nStepUpRaw
      ? Number(nStepUpRaw.replace(",", "."))
      : suggestedPct;

    // Auto sell-% should match the buy-% size
    const nStepDown = nStepUp;

    createIslandMutation.mutate({
      name: name.trim(),
      description: description.trim() ? description.trim() : undefined,
      ticker: ticker.trim().toUpperCase(),
      totalSupplyM2: Math.max(1, Math.floor(nSupply || 0)),
      startPriceUSD: nPrice,
      stepUpPct: Number.isFinite(nStepUp) ? nStepUp : suggestedPct,
      stepDownPct: Number.isFinite(nStepDown) ? nStepDown : suggestedPct,
      iconBase64: iconB64,
      ownerInitialM2: nOwn,
      diagId: createDiagId || undefined,
      accessToken,
    } as any);
  };

  return (
    <ScreenContainer title="Islands" right={undefined}>
      <div className="mt-4 grid gap-4">
        <div className="grid gap-2">
          <div className="text-sm text-muted-foreground text-center">
            Start fee: $5 one-time • Revenue split: 80% creator / 20% platform •
            Resale: 5% to island owner{" "}
          </div>
          <div className="flex justify-center">
            {isGuest ? (
              <Button
                variant="secondary"
                onClick={() => {
                  toast({
                    title: "Sign in required",
                    description:
                      "Please sign in (Google or email) to create an island.",
                  });
                  promptSignIn();
                }}
              >
                Sign in to create island
              </Button>
            ) : (
              <Button
                onClick={() => {
                  setOpen(true);
                }}
              >
                Create island{" "}
              </Button>
            )}{" "}
          </div>{" "}
        </div>

        {/* Listings (published) */}
        <div className="grid gap-2">
          <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
              <div className="flex items-center gap-2">
                <div className="text-sm font-semibold">Islands</div>
                <span className="text-[11px] text-muted-foreground">
                  Live updates
                </span>
                {islandsUpdatedAt ? (
                  <span className="text-[11px] text-muted-foreground">
                    • updated {formatDateTime(new Date(islandsUpdatedAt))}
                  </span>
                ) : null}
                {islandsIsFetching && !islandsInitialLoading ? (
                  <span className="text-[11px] text-muted-foreground">
                    • updating…
                  </span>
                ) : null}
              </div>{" "}
              <div className="relative w-full sm:w-[260px]">
                <Input
                  value={islandSearch}
                  onChange={(e) => setIslandSearch(e.target.value)}
                  placeholder="Search: name, ticker, owner…"
                  className="rounded-full pr-10"
                />
                {islandSearch.trim().length > 0 && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    className="absolute right-1 top-1/2 -translate-y-1/2 h-8 w-8 rounded-full px-0"
                    onClick={() => setIslandSearch("")}
                    aria-label="Clear search"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                )}
              </div>
              {/* Sort bar */}
              <div className="flex flex-wrap items-center gap-2 sort-control">
                <span className="text-xs text-muted-foreground uppercase tracking-wide">
                  Sort
                </span>{" "}
                <select
                  className="h-9 min-w-[180px] rounded-full border border-input bg-background px-3 text-xs font-semibold text-foreground shadow-sm focus:outline-none focus:ring-2 focus:ring-ring"
                  value={sortKey}
                  onChange={(e) =>
                    setSortKey(
                      e.target.value as
                        | "newest"
                        | "oldest"
                        | "m2_desc"
                        | "m2_asc"
                        | "price_desc"
                        | "price_asc"
                        | "available_m2_desc"
                        | "available_m2_asc",
                    )
                  }
                >
                  <option value="newest">Newest</option>
                  <option value="oldest">Oldest</option>
                  <option value="m2_desc">Largest size</option>
                  <option value="m2_asc">Smallest size</option>
                  <option value="price_desc">Highest m² price</option>
                  <option value="price_asc">Lowest m² price</option>
                  <option value="available_m2_desc">Most m² available</option>
                  <option value="available_m2_asc">
                    Least m² available
                  </option>{" "}
                </select>
              </div>
            </div>
            <div className="flex items-center gap-2 sm:mt-0">
              {isAuthed && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setShowMine((prev) => !prev)}
                >
                  {showMine ? "All islands" : "My islands"}{" "}
                </Button>
              )}
            </div>
          </div>
          {islandsInitialLoading ? (
            <AppSpinner label="Loading..." />
          ) : islandsIsError ? (
            <Alert>
              <AlertDescription className="text-sm">
                Couldn't load islands.
                <Button
                  className="ml-2"
                  size="sm"
                  variant="secondary"
                  onClick={() => refetchIslands()}
                >
                  Reload{" "}
                </Button>
                <div className="mt-2 text-xs text-muted-foreground break-words">
                  {(() => {
                    const msg =
                      (islandsError as any)?.message ||
                      (islandsError as any)?.data?.message ||
                      "";
                    return msg ? String(msg) : null;
                  })()}
                </div>
              </AlertDescription>
            </Alert>
          ) : islandsToShow && islandsToShow.length > 0 ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
              {islandsToShow.map((it) => (
                <Card
                  key={it.id}
                  className="overflow-hidden cursor-pointer hover:shadow"
                  onClick={() => navigate(`/islands/${it.id}`)}
                >
                  <CardHeader className="flex flex-row items-center gap-3 pb-2">
                    <div className="h-10 w-10 rounded bg-secondary overflow-hidden flex items-center justify-center">
                      {it.iconUrl ? (
                        <img
                          src={it.iconUrl}
                          alt="icon"
                          className="h-full w-full object-cover"
                        />
                      ) : (
                        <span className="text-xs text-muted-foreground">
                          m²
                        </span>
                      )}
                    </div>
                    <div className="flex-1">
                      <CardTitle className="text-base truncate">
                        {it.name}
                      </CardTitle>
                      {it?.description ? (
                        <div className="text-[11px] text-muted-foreground truncate">
                          {String(it.description)}
                        </div>
                      ) : null}
                      <div className="text-xs text-muted-foreground">
                        {it.totalSupplyM2?.toLocaleString?.() ?? "–"} m² •
                        Island m² price{" "}
                        {formatPPC(it.currentPriceUSD ?? it.startPriceUSD)}{" "}
                      </div>
                      {it.owner?.id === actorId && (
                        <div className="text-[11px] text-muted-foreground mt-0.5">
                          My island • created on{" "}
                          {it.createdAt
                            ? formatDateDDMMYY(new Date(it.createdAt as any))
                            : "–"}
                        </div>
                      )}
                    </div>
                    <div className="flex items-center gap-2 ml-2">
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={(e) => {
                          e.stopPropagation();
                          const url = new URL(
                            `/islands/${it.id}`,
                            getBaseUrl(),
                          ).toString();
                          const title = (it?.name ?? "Island").toString();

                          const doCopy = () => {
                            copy(url);
                            toast({ title: "Link copied" });
                          };

                          if (
                            typeof navigator !== "undefined" &&
                            (navigator as any).share
                          ) {
                            (navigator as any)
                              .share({ title, url })
                              .catch(() => doCopy());
                          } else {
                            doCopy();
                          }
                        }}
                        title="Share"
                      >
                        <Share2 className="h-4 w-4" />
                      </Button>

                      {it.owner?.id === actorId && (
                        <Button
                          size="sm"
                          variant="outline"
                          className="text-destructive border-destructive"
                          onClick={(e) => {
                            e.stopPropagation();
                            deleteIslandMutation.mutate({
                              id: it.id,
                              accessToken,
                            } as any);
                          }}
                        >
                          Delete{" "}
                        </Button>
                      )}
                    </div>
                  </CardHeader>
                </Card>
              ))}
            </div>
          ) : (
            <div className="text-sm text-muted-foreground">
              {showMine
                ? "You don't have any islands yet."
                : "No published islands yet."}{" "}
            </div>
          )}
        </div>

        {/* Create Drawer */}
        <Drawer
          open={open}
          onOpenChange={(v) => {
            setOpen(v);
            if (!v) {
              setCreateDiagId("");
              clearParams();
              resetForm();
            }
          }}
        >
          <DrawerContent className="flex flex-col items-center">
            <DrawerHeader className="text-left w-full max-w-xl">
              <DrawerTitle>Create island</DrawerTitle>
              <div className="mt-2 rounded-md border bg-background/50 p-2 text-xs text-muted-foreground">
                <div className="font-medium text-foreground">Requirement</div>
                <div className="mt-1">
                  You can only create an island after buying{" "}
                  <span className="font-semibold">2 m²</span> directly from the{" "}
                  <span className="font-semibold">Main Market</span>.
                </div>
                <div className="mt-1">
                  m² bought on the{" "}
                  <span className="font-semibold">2nd Market</span> does{" "}
                  <span className="font-semibold">not</span> unlock island
                  creation.
                </div>
              </div>
              <DrawerDescription>
                Create your own island market. Requirement: you must have bought
                at least{" "}
                <span className="font-semibold">2 m² from the Main Market</span>{" "}
                (2nd Market m² does not count).
              </DrawerDescription>
            </DrawerHeader>
            <div className="px-4 pb-4 grid gap-3 w-full max-w-xl max-h-[70vh] overflow-y-auto">
              <div className="grid gap-2">
                <Label>Island name</Label>{" "}
                <Input
                  value={name}
                  className={
                    name.trim().length === 0 && attemptedCreate
                      ? "border-destructive focus-visible:ring-destructive"
                      : ""
                  }
                  onChange={(e) => {
                    setName(e.target.value);
                    if (attemptedCreate) setAttemptedCreate(false);
                  }}
                  placeholder="e.g. Greenridge"
                />
                {name.trim().length === 0 && attemptedCreate && (
                  <div className="text-xs text-destructive">
                    Please enter an island name.
                  </div>
                )}
              </div>
              <div className="grid gap-2">
                <Label>Description (optional)</Label>
                <Textarea
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="What is your island about? (optional)"
                  rows={3}
                />
              </div>
              <div className="grid gap-2">
                <Label>Ticker (optional, max 4 characters)</Label>{" "}
                <Input
                  value={ticker}
                  className={
                    ticker && (ticker.length > 4 || !/^[A-Z0-9]+$/.test(ticker))
                      ? "border-destructive focus-visible:ring-destructive"
                      : ""
                  }
                  onChange={(e) => setTicker(e.target.value.toUpperCase())}
                  maxLength={4}
                  placeholder="e.g. ISL (optional)"
                />
                {ticker &&
                  (ticker.length > 4 || !/^[A-Z0-9]+$/.test(ticker)) && (
                    <div className="text-xs text-destructive">
                      Please use only A–Z and 0–9 (max 4 characters).
                    </div>
                  )}
              </div>
              <div className="grid gap-2">
                <Label>Island‑Icon (required)</Label>{" "}
                <div className="flex items-center gap-3">
                  <div
                    className={`h-12 w-12 rounded-xl bg-secondary overflow-hidden flex items-center justify-center shrink-0 ${
                      attemptedCreate && !iconB64
                        ? "ring-2 ring-destructive"
                        : ""
                    }`}
                  >
                    {iconB64 ? (
                      <img
                        src={iconB64}
                        alt="Icon preview"
                        className="h-full w-full object-cover"
                      />
                    ) : (
                      <span className="text-xs text-muted-foreground">m²</span>
                    )}
                  </div>
                  <div className="flex-1 grid gap-1">
                    <div className="flex flex-wrap items-center gap-2">
                      <Button
                        type="button"
                        variant="secondary"
                        size="sm"
                        onClick={() => createIconInputRef.current?.click()}
                      >
                        {iconB64 ? "Change image" : "Choose image"}
                      </Button>
                      {iconB64 && (
                        <Button
                          type="button"
                          size="sm"
                          variant="outline"
                          onClick={() => setIconB64(undefined)}
                        >
                          Remove
                        </Button>
                      )}
                    </div>
                    <div className="text-[11px] text-muted-foreground">
                      Tip: best is square and small (e.g. under 2MB).
                    </div>
                  </div>
                </div>
                {attemptedCreate && !iconB64 && (
                  <div className="text-xs text-destructive">
                    Please choose an island icon.
                  </div>
                )}
                <input
                  ref={createIconInputRef}
                  type="file"
                  accept="image/*"
                  className="sr-only"
                  onChange={async (e) => {
                    const f = e.target.files?.[0];
                    if (!f) return;
                    const MAX_ICON_MB = 2;
                    if (f.size > MAX_ICON_MB * 1024 * 1024) {
                      toast({
                        title: "Image is too large",
                        description: `Please use a smaller image (max ${MAX_ICON_MB}MB).`,
                      });
                      try {
                        (e.target as any).value = "";
                      } catch {}
                      return;
                    }
                    const b64 = await encodeFileAsBase64DataURL(f);
                    try {
                      (e.target as any).value = "";
                    } catch {}
                    if (!b64) {
                      toast({
                        title: "Image is too large",
                        description:
                          "Please use a smaller image (e.g. square, under ~5MB).",
                      });
                      return;
                    }
                    setIconB64(b64);
                  }}
                />
              </div>{" "}
              <div className="grid grid-cols-3 items-center gap-3">
                <Label className="col-span-1">Sellable m²</Label>
                <div className="col-span-2 flex flex-col gap-1">
                  <Input
                    inputMode="numeric"
                    type="tel"
                    value={supply}
                    className={
                      attemptedCreate &&
                      (!supply || Number(supply) <= 0 || Number(supply) > 4000)
                        ? "border-destructive focus-visible:ring-destructive"
                        : ""
                    }
                    onChange={(e) => {
                      const raw = e.target.value.replace(/[^0-9]/g, "");
                      if (!raw) {
                        setSupply("");
                        return;
                      }
                      const n = Math.min(
                        4000,
                        Math.max(0, Math.floor(Number(raw) || 0)),
                      );
                      setSupply(String(n));
                    }}
                    placeholder="Max 4000 m²"
                  />
                  {attemptedCreate &&
                    (!supply ||
                      Number(supply) <= 0 ||
                      Number(supply) > 4000) && (
                      <div className="text-xs text-destructive">
                        Please enter an m² amount between 1 and 4000.
                      </div>
                    )}
                  <Input
                    inputMode="numeric"
                    type="tel"
                    value={ownM2}
                    className={
                      attemptedCreate &&
                      !!ownM2 &&
                      Number(ownM2 || 0) > Number(supply || 0)
                        ? "border-destructive focus-visible:ring-destructive"
                        : ""
                    }
                    onChange={(e) =>
                      setOwnM2(e.target.value.replace(/[^0-9]/g, ""))
                    }
                    placeholder="Of which you own immediately"
                  />{" "}
                  {attemptedCreate &&
                    !!ownM2 &&
                    Number(ownM2 || 0) > Number(supply || 0) && (
                      <div className="text-xs text-destructive">
                        Your own m² cannot be greater than total m².
                      </div>
                    )}
                  <div className="flex items-center justify-between text-[11px] text-muted-foreground">
                    <span>Your own m² (owned immediately)</span>{" "}
                    <span>
                      {(() => {
                        const total = Math.max(
                          0,
                          Math.floor(
                            Number((supply || "0").replace(/[^0-9]/g, "")) || 0,
                          ),
                        );
                        const mine = Math.max(
                          0,
                          Math.min(
                            total,
                            Math.floor(
                              Number((ownM2 || "0").replace(/[^0-9]/g, "")) ||
                                0,
                            ),
                          ),
                        );
                        const pct =
                          total > 0
                            ? Math.round((mine / total) * 1000) / 10
                            : 0;
                        return `${mine.toLocaleString()} m² (${pct.toFixed(1)}%)`;
                      })()}
                    </span>
                  </div>
                </div>
              </div>{" "}
              <div className="grid grid-cols-3 items-center gap-3">
                <Label className="col-span-1">Starting price (USD/m²)</Label>
                <Input
                  className={`col-span-2 ${
                    attemptedCreate &&
                    (!price ||
                      !Number.isFinite(Number(price)) ||
                      Number(price) <= 0)
                      ? "border-destructive focus-visible:ring-destructive"
                      : ""
                  }`}
                  inputMode="decimal"
                  type="tel"
                  value={price}
                  onChange={(e) =>
                    setPrice(
                      e.target.value
                        .replace(/[^0-9.,-]/g, "")
                        .replace(",", "."),
                    )
                  }
                  placeholder="e.g. 1.00"
                />
                {attemptedCreate &&
                  (!price ||
                    !Number.isFinite(Number(price)) ||
                    Number(price) <= 0) && (
                    <div className="col-span-3 text-xs text-destructive">
                      Please enter a starting price greater than 0.
                    </div>
                  )}
              </div>
              <div className="grid gap-2">
                <Label>Curve templates</Label>
                <div className="flex flex-wrap gap-2">
                  <Button
                    type="button"
                    variant={
                      Number(stepUpPct) === 1.6 ? "secondary" : "outline"
                    }
                    size="sm"
                    onClick={() => {
                      setStepUpPct("1.6");
                      setIsStepPctValid(true);
                    }}
                  >
                    Soft (+1.6% / buy)
                  </Button>
                  <Button
                    type="button"
                    variant={Number(stepUpPct) === 3 ? "secondary" : "outline"}
                    size="sm"
                    onClick={() => {
                      setStepUpPct("3");
                      setIsStepPctValid(true);
                    }}
                  >
                    Medium (+3% / buy)
                  </Button>
                  <Button
                    type="button"
                    variant={Number(stepUpPct) === 5 ? "secondary" : "outline"}
                    size="sm"
                    onClick={() => {
                      setStepUpPct("5");
                      setIsStepPctValid(true);
                    }}
                  >
                    Strong (+5% / buy)
                  </Button>
                </div>
                <div className="text-[11px] text-muted-foreground">
                  These templates set the maximum curve speed. The actual price
                  change per m² depends on island size.
                </div>
              </div>
              <div className="grid grid-cols-3 items-center gap-3">
                <Label className="col-span-1">
                  Max price increase on buy (0–5%)
                </Label>
                <div className="col-span-2 flex flex-col gap-1">
                  <div className="flex items-center gap-2">
                    <Input
                      className={`flex-1 ${
                        !isStepPctValid && (stepUpPct || attemptedCreate)
                          ? "border-destructive focus-visible:ring-destructive"
                          : ""
                      }`}
                      inputMode="decimal"
                      type="tel"
                      value={stepUpPct}
                      onChange={(e) => {
                        const cleaned = e.target.value
                          .replace(/[^0-9.,-]/g, "")
                          .replace(",", ".");
                        setStepUpPct(cleaned);
                        if (!cleaned) {
                          setIsStepPctValid(true);
                          return;
                        }
                        const n = Number(cleaned);
                        // Max. 5% erlaubt
                        setIsStepPctValid(
                          Number.isFinite(n) && n > 0 && n <= 5,
                        );
                      }}
                      placeholder={`${suggestedPct.toFixed(2)} (suggestion)`}
                    />
                    {isStepPctValid && (
                      <CheckCircle2 className="h-4 w-4 text-emerald-500 shrink-0" />
                    )}
                  </div>
                  {!isStepPctValid && (stepUpPct || attemptedCreate) && (
                    <div className="text-xs text-destructive">
                      Please choose a value between 0 and 5.
                    </div>
                  )}
                </div>
              </div>{" "}
              <div className="text-xs text-muted-foreground">
                Suggestion based on your m² amount:{" "}
                <span className="font-medium">{suggestedPct.toFixed(2)}%</span>{" "}
                (max 5%). The final change adjusts automatically as m² are sold.
              </div>{" "}
              {/* Live preview of the green m² tiles based on the entered amount */}
              <div className="grid gap-2">
                <div className="text-xs text-muted-foreground">Preview</div>
                {(() => {
                  const mapW = 600,
                    mapH = 300,
                    tile = 22,
                    gap = 3;
                  const rows = [5, 7, 9, 11, 9, 7, 5];
                  const positions: Array<{ x: number; y: number }> = [];
                  const totalRows = rows.length;
                  const silhouetteHeight =
                    totalRows * tile + Math.max(0, totalRows - 1) * gap;
                  const startY = Math.max(
                    0,
                    Math.floor((mapH - silhouetteHeight) / 2),
                  );
                  for (let r = 0; r < totalRows; r++) {
                    const cols = rows[r]!;
                    const rowWidth = cols * tile + Math.max(0, cols - 1) * gap;
                    const startX = Math.max(
                      0,
                      Math.floor((mapW - rowWidth) / 2),
                    );
                    for (let c = 0; c < cols; c++) {
                      const x = startX + c * (tile + gap);
                      const y = startY + r * (tile + gap);
                      positions.push({ x, y });
                    }
                  }
                  const capacity = positions.length;
                  const n = Math.max(
                    0,
                    Math.min(
                      capacity,
                      Math.floor(
                        Number((supply || "0").replace(/[^0-9]/g, "")) || 0,
                      ),
                    ),
                  );
                  return (
                    <div className="w-full flex justify-center">
                      <svg
                        viewBox={`0 0 ${mapW} ${mapH}`}
                        className="w-full h-[220px] rounded-lg overflow-hidden"
                      >
                        {" "}
                        <defs>
                          <linearGradient
                            id="grass-new"
                            x1="0%"
                            y1="0%"
                            x2="0%"
                            y2="100%"
                          >
                            <stop offset="0%" stopColor="hsl(122 40% 50%)" />
                            <stop
                              offset="100%"
                              stopColor="hsl(116 34% 42%)"
                            />{" "}
                          </linearGradient>
                          <linearGradient
                            id="highlight-new"
                            x1="0%"
                            y1="0%"
                            x2="100%"
                            y2="100%"
                          >
                            <stop
                              offset="0%"
                              stopColor="#ffffff"
                              stopOpacity="0.25"
                            />
                            <stop
                              offset="100%"
                              stopColor="#ffffff"
                              stopOpacity="0"
                            />
                          </linearGradient>
                        </defs>
                        <rect
                          x={0}
                          y={0}
                          width={mapW}
                          height={mapH}
                          fill="hsl(206 85% 58%)"
                        />
                        {positions.slice(0, n).map((p, i) => (
                          <g key={`new-${i}`}>
                            <rect
                              x={p.x + 2}
                              y={p.y + 3}
                              width={tile - 2}
                              height={tile - 2}
                              rx={2}
                              ry={2}
                              fill="#000"
                              opacity={0}
                            />
                            <rect
                              x={p.x - 0.5}
                              y={p.y - 0.5}
                              width={tile + 1}
                              height={tile + 1}
                              rx={2}
                              ry={2}
                              fill="none"
                            />
                            <rect
                              x={p.x}
                              y={p.y}
                              width={tile - 1.5}
                              height={tile - 1.5}
                              rx={2}
                              ry={2}
                              fill="url(#grass-new)"
                            />
                            <rect
                              x={p.x + 2}
                              y={p.y + 2}
                              width={Math.max(0, tile - 6)}
                              height={Math.max(0, (tile - 6) / 2)}
                              rx={4}
                              ry={4}
                              fill="url(#highlight-new)"
                              opacity={0}
                            />
                          </g>
                        ))}
                      </svg>
                    </div>
                  );
                })()}
              </div>
              <div className="rounded-md border p-3 text-xs grid gap-1 mt-2">
                <div>
                  Start fee: <span className="font-semibold">$5</span>{" "}
                  (one-time)
                </div>

                <div className="mt-1">
                  {(() => {
                    const nSupply = Math.max(
                      0,
                      Math.floor(
                        Number((supply || "0").replace(/[^0-9]/g, "")) || 0,
                      ),
                    );
                    const nOwn = Math.max(
                      0,
                      Math.min(
                        nSupply,
                        Math.floor(
                          Number((ownM2 || "0").replace(/[^0-9]/g, "")) || 0,
                        ),
                      ),
                    );
                    const nPrice = Number((price || "").replace(",", "."));
                    const stepRaw = (stepUpPct || "").trim();
                    const nStep = stepRaw
                      ? Number(stepRaw.replace(",", "."))
                      : suggestedPct;

                    if (!Number.isFinite(nSupply) || nSupply <= 0) return null;
                    if (!Number.isFinite(nPrice) || nPrice <= 0) return null;

                    const effectiveStep = Number.isFinite(nStep) ? nStep : 0;
                    const publicStart = calcIslandPriceAtSold({
                      startPrice: nPrice,
                      stepUpPct: effectiveStep,
                      totalSupplyM2: nSupply,
                      soldM2: nOwn,
                    });

                    if (!Number.isFinite(publicStart) || publicStart <= 0)
                      return null;

                    // If nOwn is 0, publicStart == start price.
                    return (
                      <div className="text-muted-foreground">
                        Public starting m² price (after your own m²):{" "}
                        <span className="font-semibold text-foreground">
                          {formatPPC(publicStart)}
                        </span>
                        {nOwn > 0 ? (
                          <span className="ml-1">(you pre-own {nOwn} m²)</span>
                        ) : null}
                      </div>
                    );
                  })()}
                </div>

                <div>
                  Revenue split: <span className="font-semibold">80%</span> to
                  you, <span className="font-semibold">20%</span> to the
                  platform.
                </div>
                <div>
                  Resale: <span className="font-semibold">5%</span> goes to you
                  as the island owner.
                </div>
              </div>
              {createDiagId && (
                <div className="rounded-md border bg-background/50 p-2 text-xs text-muted-foreground">
                  Diagnose-ID: <span className="font-mono">{createDiagId}</span>
                </div>
              )}
              <div className="flex justify-end gap-2 mt-2">
                <DrawerClose asChild>
                  <Button
                    variant="secondary"
                    onClick={() => {
                      setCreateDiagId("");
                      resetForm();
                      clearParams();
                    }}
                  >
                    Cancel{" "}
                  </Button>
                </DrawerClose>
                <Button
                  onClick={createIslandLocal}
                  disabled={!canCreate() || createIslandMutation.isLoading}
                >
                  {createIslandMutation.isLoading ? "Creating…" : "Create"}
                </Button>
              </div>
            </div>
            <DrawerFooter>
              <div />
            </DrawerFooter>
          </DrawerContent>
        </Drawer>
      </div>
    </ScreenContainer>
  );
}

// Island detail page with a simple chart and map button
function IslandDetailScreen() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const auth = useAuth();
  const supa = useSupabase();
  const isGuest = useIsGuest();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const promptSignIn = () => {
    try {
      window.dispatchEvent(new Event("openSignIn"));
    } catch {}
  };

  const myUserId =
    ((supa as any)?.user?.id as string | undefined) ?? (auth as any)?.userId;
  // IMPORTANT: All buying/selling requires the in-app login (Supabase).
  // Platform auth alone must not allow trading, otherwise users can get stuck with "failed".
  const isAuthed = !!((supa as any)?.user?.id as string | undefined);
  const accessToken =
    ((supa as any)?.accessToken as string | null | undefined) ??
    ((window as any).__supaAccessToken as string | null | undefined) ??
    undefined;

  const [buyAmount, setBuyAmount] = React.useState<string>("");
  // Read URL params (?sell or ?buy) to predefine requested m² for preview
  const location = useLocation();
  const _params = React.useMemo(
    () => new URLSearchParams(location.search),
    [location.search],
  );
  const sellParam = Math.max(0, Math.floor(Number(_params.get("sell") || 0)));
  const buyParam = Math.max(0, Math.floor(Number(_params.get("buy") || 0)));
  // Last tapped tile (for the info bar and blue ring)
  const [focusedIdx, setFocusedIdx] = React.useState<number | null>(null);
  // Trade mode + sell form state
  const [isSellMode, setIsSellMode] = React.useState<boolean>(false);
  const [sellAmount, setSellAmount] = React.useState<string>("");
  const [sellPrice, setSellPrice] = React.useState<string>("");
  const [hoverIndex, setHoverIndex] = React.useState<number | null>(null);
  const mapContainerRef = React.useRef<HTMLDivElement | null>(null);
  const mapSvgRef = React.useRef<SVGSVGElement | null>(null);

  const iconFileInputRef = React.useRef<HTMLInputElement | null>(null);
  const [iconPreviewUrl, setIconPreviewUrl] = React.useState<string | null>(
    null,
  );

  const makeSquareIconPng = React.useCallback(
    async (file: File, size: number) => {
      const readAsDataUrl = () =>
        new Promise<string>((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(new Error("Couldn't read the file."));
          reader.onload = () => resolve(String(reader.result || ""));
          reader.readAsDataURL(file);
        });

      const dataUrl = await readAsDataUrl();
      const img = new Image();
      img.crossOrigin = "anonymous";

      await new Promise<void>((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = () =>
          reject(
            new Error("Unsupported image format. Please choose JPG or PNG."),
          );
        img.src = dataUrl;
      });

      const w = img.naturalWidth || img.width || 0;
      const h = img.naturalHeight || img.height || 0;
      if (!w || !h) {
        throw new Error("The image couldn't be loaded.");
      }

      const side = Math.min(w, h);
      const sx = Math.floor((w - side) / 2);
      const sy = Math.floor((h - side) / 2);

      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error("Canvas is not available.");
      ctx.drawImage(img, sx, sy, side, side, 0, 0, size, size);

      const out = canvas.toDataURL("image/png");
      if (!out || !out.startsWith("data:image")) {
        throw new Error("Couldn't process the image.");
      }
      return out;
    },
    [],
  );

  const updateIslandIconMutation = useMutation(apiClient.updateIslandIcon, {
    onSuccess: async () => {
      toast({ title: "Icon saved" });
      await Promise.all([
        queryClient.invalidateQueries(["island", id]),
        queryClient.invalidateQueries(["islands_list"]),
      ]);
    },
    onError: (err: any) => {
      toast({
        title: "Couldn't save icon",
        description: err?.message || "Please try again with a smaller image.",
      });
    },
  });

  const handlePickIslandIcon = () => {
    if (isGuest) {
      toast({
        title: "Sign in required",
        description: "Please sign in (Google or email) to change the icon.",
      });
      promptSignIn();
      return;
    }
    iconFileInputRef.current?.click();
  };

  const buyExactMutation = useMutation(apiClient.buyAndClaimPlots, {
    onSuccess: async () => {
      toast({
        title: "Purchase successful",
        description: "Your m² have been purchased.",
      });
      await Promise.all([
        queryClient.invalidateQueries(["wallet"]),
        queryClient.invalidateQueries({
          queryKey: ["island-detail-chunk"],
          exact: false,
        }),
        queryClient.invalidateQueries(["island", id]),
        queryClient.invalidateQueries(["islands_list"]),
        queryClient.invalidateQueries(["market"]),
        queryClient.invalidateQueries(["profile"]),
        queryClient.invalidateQueries(["walletSummary"]),
      ]);
    },
    onError: (err: any) => {
      toast({
        title: "Error",
        description: err?.message || "Purchase failed",
      });
    },
  });

  const buySecondaryListingMutation = useMutation(
    apiClient.buySecondaryListing,
    {
      onSuccess: async () => {
        toast({
          title: "Purchase successful",
          description: "Your m² have been purchased.",
        });
        await Promise.all([
          queryClient.invalidateQueries(["wallet"]),
          queryClient.invalidateQueries(["secondaryListings"]),
          queryClient.invalidateQueries(["activeListings"]),
          queryClient.invalidateQueries({
            queryKey: ["island-detail-chunk"],
            exact: false,
          }),
          queryClient.invalidateQueries(["island", id]),
          queryClient.invalidateQueries(["islands_list"]),
          queryClient.invalidateQueries(["market"]),
          queryClient.invalidateQueries(["profile"]),
          queryClient.invalidateQueries(["portfolio"]),
          queryClient.invalidateQueries(["walletSummary"]),
          queryClient.invalidateQueries(["walletRangeSummary"]),
          queryClient.invalidateQueries(["messageCenter"]),
          queryClient.invalidateQueries(["messageCenterUnreadCount"]),
        ]);
      },
      onError: (err: any) => {
        const msg = err?.message || "Purchase failed";
        toast({ title: "Error", description: msg });
      },
    },
  );
  const { data: topHolders } = useQuery<any>(
    ["islandTopHolders", id],
    () =>
      apiClient.getIslandTopHolders({
        islandId: id as string,
        limit: 10,
      }),
    {
      enabled: !!id,
      // This endpoint scans recent transactions; keep it live but not too aggressive.
      staleTime: 8_000,
      refetchOnMount: true,
      refetchOnWindowFocus: false,
      refetchInterval: 15_000,
      refetchIntervalInBackground: false,
      refetchOnReconnect: true,
      retry: 1,
    },
  );

  const {
    data: earningsSummary,
    isFetching: earningsIsFetching,
    dataUpdatedAt: earningsUpdatedAt,
  } = useQuery<any>(
    ["myIslandEarningsSummary", id],
    () =>
      apiClient.getMyIslandEarningsSummary({
        islandId: id as string,
        accessToken,
      } as any),
    {
      enabled: isAuthed && !!id,
      // Keep it reasonably live without overloading the server.
      staleTime: 8_000,
      refetchOnMount: true,
      refetchOnWindowFocus: false,
      refetchInterval: 15_000,
      refetchIntervalInBackground: false,
      refetchOnReconnect: true,
      retry: 1,
      // Avoid brief "empty" states between refreshes.
      placeholderData: () =>
        (queryClient.getQueryData<any>(["myIslandEarningsSummary", id]) ??
          null) as any,
    },
  );

  const holderName = React.useCallback((u: any) => {
    if (!u) return "Unknown";
    const dn = u.displayNameLocal || u.name;
    if (dn) return String(dn);
    if (u.handle) return "@" + String(u.handle);
    if (u.id) return "User " + String(u.id).slice(0, 6);
    return "Unknown";
  }, []);

  const holderAvatar = React.useCallback((u: any) => {
    return u?.profileImageUrl || u?.image || null;
  }, []);

  // Create listings directly from island (batch)
  const createListings = useMutation(
    async (input: { amountM2: number; priceEUR: number; islandId: string }) => {
      return await apiClient.quickSellIslandHoldingsByAmount({
        islandId: input.islandId,
        amountM2: input.amountM2,
        priceEUR: input.priceEUR,
        accessToken,
      } as any);
    },
    {
      onSuccess: async (res: any) => {
        setSellAmount("");
        setSellPrice("");
        const created = Math.max(0, Math.floor(Number(res?.created ?? 0)));
        const requested = Math.max(0, Math.floor(Number(res?.requested ?? 0)));
        const available = Math.max(0, Math.floor(Number(res?.available ?? 0)));
        if (created > 0 && created < requested) {
          toast({
            title: "Partially listed",
            description: `Listed ${created}/${requested} m² (available: ${available}).`,
          });
        } else {
          toast({
            title: "Listings created",
            description: `Listed ${created} m².`,
          });
        }
        await Promise.all([
          queryClient.invalidateQueries(["activeListings"]),
          queryClient.invalidateQueries(["secondaryListings"] as any),
          queryClient.invalidateQueries(["island", id]),
          queryClient.invalidateQueries(["islands_list"]),
          queryClient.invalidateQueries({
            queryKey: ["island-detail-chunk"],
            exact: false,
          }),
        ]);
      },
      onError: (e: any) => {
        toast({
          title: "Listing failed",
          description: (e?.message || "").toLowerCase().includes("too many")
            ? "Please enter a smaller amount (max 500 m² at once)."
            : e?.message || "Please try again.",
        });
      },
    },
  );
  // buyAmount bleibt immer genau das, was der User eingibt (kein Auto-Override durch Tap-Auswahl)

  const { data, isLoading, isError, refetch } = useQuery<any>(
    ["island", id],
    () => apiClient.getIsland({ id: id as string }),
    {
      enabled: !!id,
      // Keep island stats (price/sold/available) fresh while the detail screen is open.
      refetchOnMount: true,
      staleTime: 2_000,
      refetchInterval: 5_000,
      refetchIntervalInBackground: false,
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      retry: 1,
    },
  );
  // Wallet balance for pre-check
  const { data: profile, isInitialLoading: profileInitialLoading } =
    useQuery<any>(
      ["profile", accessToken ?? null],
      () =>
        apiClient.getProfile(
          accessToken ? ({ accessToken } as any) : (undefined as any),
        ),
      {
        // If a user is signed in via Supabase, we must pass the access token so the wallet balance resolves correctly.
        enabled: isAuthed,
        staleTime: 20_000,
        refetchOnWindowFocus: false,
        refetchOnReconnect: true,
        retry: 1,
      },
    );

  const island = (data as any)?.island;
  const isOwner = !isGuest && isAuthed && island?.owner?.id === myUserId;
  const samples: Array<{ priceUSD: number; createdAt?: string | Date }> = ((
    data as any
  )?.priceSamples ?? []) as Array<{
    priceUSD: number;
    createdAt?: string | Date;
  }>;
  const [chartRange, setChartRange] = React.useState<"24H" | "7D" | "30D">(
    "24H",
  );
  const [chartWindowPos, setChartWindowPos] = React.useState<number>(1);
  const chartSamples = React.useMemo(() => {
    const base = [...samples];
    const windowMs =
      chartRange === "24H"
        ? 24 * 60 * 60 * 1000
        : chartRange === "7D"
          ? 7 * 24 * 60 * 60 * 1000
          : 30 * 24 * 60 * 60 * 1000;

    if (!base.length) {
      return [] as Array<{ priceUSD: number; createdAt?: string | Date }>;
    }

    const timeValues = base
      .map((s) => (s?.createdAt ? new Date(s.createdAt as any).getTime() : NaN))
      .filter((t) => Number.isFinite(t));

    if (!timeValues.length) {
      const now = new Date();
      const startPrice = island?.startPriceUSD ?? 0;
      if (base.length === 1) {
        const s0 = base[0]!;
        return [{ ...s0, createdAt: new Date(now.getTime() - windowMs) }, s0];
      }
      if (base.length >= 2) return base;
      return [
        {
          priceUSD: startPrice,
          createdAt: new Date(now.getTime() - windowMs),
        },
        {
          priceUSD: startPrice,
          createdAt: now,
        },
      ];
    }

    const oldest = Math.min(...timeValues);
    const newest = Math.max(...timeValues);
    const totalSpan = Math.max(newest - oldest, 1);
    const effectiveWindowMs = Math.min(windowMs, totalSpan);

    const minStart = oldest;
    const maxStart = newest - effectiveWindowMs;

    let startMs = minStart;
    if (maxStart > minStart + 60 * 1000) {
      const pos = Math.min(Math.max(chartWindowPos, 0), 1);
      startMs = minStart + (maxStart - minStart) * pos;
    } else {
      startMs = maxStart;
    }
    const endMs = startMs + effectiveWindowMs;

    const filtered = base.filter((s) => {
      if (!s?.createdAt) return false;
      const t = new Date(s.createdAt as any).getTime();
      if (!Number.isFinite(t)) return false;
      return t >= startMs && t <= endMs;
    });

    let use = filtered.length > 1 ? filtered : base;
    if (use.length >= 2) return use;

    const now = new Date();
    const startPrice = island?.startPriceUSD ?? 0;
    if (use.length === 1) {
      const s0 = use[0]!;
      const fallbackStart = new Date(
        Math.min(startMs, now.getTime() - windowMs),
      );
      return [{ ...s0, createdAt: fallbackStart }, s0];
    }
    return [
      {
        priceUSD: startPrice,
        createdAt: new Date(now.getTime() - windowMs),
      },
      {
        priceUSD: startPrice,
        createdAt: now,
      },
    ];
  }, [samples, chartRange, chartWindowPos, island?.startPriceUSD]);

  const chartSliderEnabled = React.useMemo(() => {
    const base = [...samples];
    const timeValues = base
      .map((s) => (s?.createdAt ? new Date(s.createdAt as any).getTime() : NaN))
      .filter((t) => Number.isFinite(t));
    if (timeValues.length < 2) return false;
    const oldest = Math.min(...timeValues);
    const newest = Math.max(...timeValues);
    const totalSpan = Math.max(newest - oldest, 0);
    return totalSpan > 0;
  }, [samples, chartRange]);

  const [utcNowLabel, setUtcNowLabel] = React.useState<string>(
    () => new Date().toISOString().slice(11, 19) + "Z",
  );
  React.useEffect(() => {
    const id = window.setInterval(() => {
      setUtcNowLabel(new Date().toISOString().slice(11, 19) + "Z");
    }, 1000);
    return () => window.clearInterval(id);
  }, []);

  const timelineRef = React.useRef<HTMLDivElement | null>(null);
  const timelineDragRef = React.useRef({
    dragging: false,
    startX: 0,
    startPos: 1,
  });

  const onTimelinePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    timelineDragRef.current.dragging = true;
    timelineDragRef.current.startX = e.clientX;
    timelineDragRef.current.startPos = chartWindowPos;
    try {
      (e.currentTarget as any).setPointerCapture?.(e.pointerId);
    } catch {}
  };

  const onTimelinePointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!timelineDragRef.current.dragging) return;
    const el = timelineRef.current;
    if (!el) return;
    const width = el.clientWidth || 1;
    const dx = e.clientX - timelineDragRef.current.startX;
    const delta = dx / Math.max(width, 1);
    const next = Math.min(
      1,
      Math.max(0, timelineDragRef.current.startPos + delta),
    );
    setChartWindowPos(next);
  };

  const onTimelinePointerUp = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!timelineDragRef.current.dragging) return;
    timelineDragRef.current.dragging = false;
    try {
      (e.currentTarget as any).releasePointerCapture?.(e.pointerId);
    } catch {}
  };

  // Derived metrics
  const prices = samples.map((s) => s.priceUSD);
  // Island m² price: prefer the start price set by the island creator,
  // then the latest island price sample; no global market-cap price.
  const currentPrice = prices.length
    ? prices[prices.length - 1]!
    : (island?.startPriceUSD ?? 0);

  const formatPPC = (value: number) =>
    `${Number(value || 0).toLocaleString(undefined, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })} PPC`;

  const mapW = 640,
    mapH = 360,
    tile = 22,
    gap = 0,
    edgePad = 16,
    waterRadius = 16;

  // World polygon and helpers (same shape/logic as main map)
  const ISLAND_W = 800;
  const ISLAND_H = 500;
  const ISLAND_X0 = 0;
  const ISLAND_Y0 = 0;
  const ISLAND_POLY = React.useMemo(() => {
    const norm: Array<[number, number]> = [
      [0.02, 0.52],
      [0.04, 0.44],
      [0.08, 0.36],
      [0.14, 0.3],
      [0.22, 0.26],
      [0.32, 0.23],
      [0.45, 0.2],
      [0.55, 0.16],
      [0.62, 0.1],
      [0.67, 0.06],
      [0.72, 0.05],
      [0.78, 0.08],
      [0.82, 0.14],
      [0.84, 0.22],
      [0.88, 0.28],
      [0.94, 0.3],
      [0.97, 0.36],
      [0.96, 0.44],
      [0.92, 0.5],
      [0.88, 0.56],
      [0.86, 0.62],
      [0.88, 0.68],
      [0.92, 0.74],
      [0.94, 0.8],
      [0.92, 0.86],
      [0.86, 0.9],
      [0.78, 0.92],
      [0.7, 0.92],
      [0.62, 0.9],
      [0.54, 0.88],
      [0.46, 0.86],
      [0.38, 0.86],
      [0.3, 0.88],
      [0.22, 0.88],
      [0.16, 0.86],
      [0.1, 0.82],
      [0.06, 0.76],
      [0.04, 0.68],
      [0.03, 0.6],
    ];
    return norm.map(([nx, ny]) => ({
      x: Math.floor(ISLAND_X0 + nx * ISLAND_W),
      y: Math.floor(ISLAND_Y0 + ny * ISLAND_H),
    }));
  }, []);
  const pointInPolygon = React.useCallback(
    (wx: number, wy: number) => {
      let inside = false;
      for (
        let i = 0, j = ISLAND_POLY.length - 1;
        i < ISLAND_POLY.length;
        j = i++
      ) {
        const xi = ISLAND_POLY[i]!.x,
          yi = ISLAND_POLY[i]!.y;
        const xj = ISLAND_POLY[j]!.x,
          yj = ISLAND_POLY[j]!.y;
        const intersect =
          yi > wy !== yj > wy &&
          wx < ((xj - xi) * (wy - yi)) / (yj - yi + 1e-7) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    },
    [ISLAND_POLY],
  );

  // Secondary listings (this island only)
  const { data: allListings } = useQuery<any>(
    ["secondaryListings"],
    () => apiClient.listSecondaryListings(),
    {
      // Listings can change quickly; keep them reasonably live.
      refetchOnMount: true,
      staleTime: 2_000,
      refetchInterval: 5_000,
      refetchIntervalInBackground: false,
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      retry: 1,
      placeholderData: () =>
        (queryClient.getQueryData<any>(["secondaryListings"]) ?? []) as any,
    },
  );
  const myIdLocal = myUserId;
  const [viewFilterLocal, setViewFilterLocal] = React.useState<"ALL" | "MINE">(
    "ALL",
  );

  const INITIAL_LISTINGS = 5;
  const LISTINGS_STEP = 10;
  const [listingsVisibleCount, setListingsVisibleCount] =
    React.useState<number>(INITIAL_LISTINGS);

  React.useEffect(() => {
    setListingsVisibleCount(INITIAL_LISTINGS);
  }, [viewFilterLocal, island?.id]);
  const islandListings = React.useMemo(() => {
    if (!allListings || !island?.id) return [];
    let arr = (allListings as any[]).filter(
      (l: any) => l.islandId && l.islandId === island.id,
    );
    if (viewFilterLocal === "MINE" && myIdLocal) {
      // In "Mine" nur eigene Inserate
      arr = arr.filter((l: any) => l.sellerId === myIdLocal);
    }
    arr.sort((a: any, b: any) => (a.priceEUR ?? 0) - (b.priceEUR ?? 0));
    return arr;
  }, [allListings, island?.id, viewFilterLocal, myIdLocal]);

  // Bulk buy (ALL tab): buy N cheapest listings in one go
  const [bulkBuyQty, setBulkBuyQty] = React.useState<string>("1");
  const [bulkBuyOpen, setBulkBuyOpen] = React.useState<boolean>(false);
  const [bulkBuying, setBulkBuying] = React.useState<boolean>(false);
  const [bulkBoughtCount, setBulkBoughtCount] = React.useState<number>(0);
  const [bulkBuyTarget, setBulkBuyTarget] = React.useState<number>(0);

  const bulkProgressChannelId = React.useMemo(() => {
    const uid = myUserId;
    const islandId = island?.id;
    if (!uid || !islandId) return "bulkbuy:disabled";
    return `bulkbuy:${uid}:${islandId}`;
  }, [myUserId, island?.id]);
  const [bulkProgress] = useRealtimeStore(bulkProgressChannelId, {
    ts: 0,
    bought: 0,
    target: 0,
  } as any);

  React.useEffect(() => {
    if (!bulkBuying) return;
    const b = Math.max(
      0,
      Math.floor(Number((bulkProgress as any)?.bought ?? 0)),
    );
    if (Number.isFinite(b)) setBulkBoughtCount(b);
    const t = Math.max(
      0,
      Math.floor(Number((bulkProgress as any)?.target ?? 0)),
    );
    if (Number.isFinite(t) && t > 0) setBulkBuyTarget(t);
  }, [(bulkProgress as any)?.ts, bulkBuying]);

  const bulkQty = Math.max(0, Math.floor(Number(bulkBuyQty || 0)));
  const bulkCandidates = React.useMemo(() => {
    if (!islandListings) return [] as any[];
    // In ALL: never include own listings
    return (islandListings as any[]).filter(
      (l: any) => l?.sellerId !== myIdLocal,
    );
  }, [islandListings, myIdLocal]);
  const bulkSelection = React.useMemo(() => {
    if (bulkQty <= 0) return [] as any[];
    return (bulkCandidates as any[]).slice(0, bulkQty);
  }, [bulkCandidates, bulkQty]);
  const bulkTotal = React.useMemo(() => {
    return (bulkSelection as any[]).reduce(
      (acc: number, l: any) => acc + (Number(l?.priceEUR ?? 0) || 0),
      0,
    );
  }, [bulkSelection]);
  const bulkAvg = React.useMemo(() => {
    if (!bulkSelection.length) return 0;
    return bulkTotal / Math.max(1, bulkSelection.length);
  }, [bulkTotal, bulkSelection.length]);

  const runBulkBuy = React.useCallback(async () => {
    if (!isAuthed) {
      toast({
        title: "Sign in required",
        description: "Please sign in to buy collectibles.",
      });
      promptSignIn();
      return;
    }
    if (bulkBuying) return;

    const target = Math.max(0, bulkQty);
    if (!target) {
      toast({
        title: "Enter an amount",
        description: "Enter how many listings you want to buy (e.g. 1, 5, 10).",
      });
      return;
    }

    // If the preview currently shows zero candidates, stop early with a clear message.
    if (bulkSelection.length === 0) {
      toast({
        title: "No listings available",
        description: "Try a smaller amount or check again in a moment.",
      });
      return;
    }

    const islandId = island?.id;
    if (!islandId) {
      toast({ title: "Island not loaded", description: "Please try again." });
      return;
    }

    setBulkBuying(true);
    setBulkBoughtCount(0);
    setBulkBuyTarget(target);

    try {
      const res = await apiClient.buySecondaryListingsBulk({
        islandId,
        quantity: target,
        accessToken,
      } as any);

      const bought = Math.max(0, Math.floor(Number((res as any)?.bought ?? 0)));
      setBulkBoughtCount(bought);

      if (bought <= 0) {
        toast({
          title: "Purchase failed",
          description: "Listings changed too fast. Please try again.",
        });
      } else if (bought < target) {
        toast({
          title: "Partially completed",
          description: `Bought ${bought}/${target} m² (some listings were no longer available).`,
        });
      } else {
        toast({
          title: "Purchase successful",
          description: `Bought ${bought} m².`,
        });
      }

      await Promise.all([
        queryClient.invalidateQueries(["wallet"]),
        queryClient.invalidateQueries(["secondaryListings"]),
        queryClient.invalidateQueries(["activeListings"]),
        queryClient.invalidateQueries({
          queryKey: ["island-detail-chunk"],
          exact: false,
        }),
        queryClient.invalidateQueries(["island", id]),
        queryClient.invalidateQueries(["islands_list"]),
        queryClient.invalidateQueries(["market"]),
        queryClient.invalidateQueries(["profile"]),
        queryClient.invalidateQueries(["portfolio"]),
        queryClient.invalidateQueries(["walletSummary"]),
        queryClient.invalidateQueries(["walletRangeSummary"]),
        queryClient.invalidateQueries(["messageCenter"]),
        queryClient.invalidateQueries(["messageCenterUnreadCount"]),
      ]);
    } catch (err: any) {
      const msg = err?.message || "Purchase failed";
      toast({ title: "Error", description: msg });
      await Promise.all([
        queryClient.invalidateQueries(["secondaryListings"]),
        queryClient.invalidateQueries(["activeListings"]),
        queryClient.invalidateQueries({
          queryKey: ["island-detail-chunk"],
          exact: false,
        }),
      ]);
    } finally {
      setBulkBuying(false);
      setBulkBuyOpen(false);
    }
  }, [
    isAuthed,
    bulkBuying,
    bulkQty,
    bulkSelection.length,
    queryClient,
    id,
    island?.id,
    accessToken,
    toast,
  ]);

  function hash32(s: string): number {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619) >>> 0;
    }
    return h >>> 0;
  }
  function pickStableIslandPoint(seedStr: string): { x: number; y: number } {
    const seed = hash32(seedStr);
    let x = ISLAND_X0 + (seed % ISLAND_W);
    let y = ISLAND_Y0 + (((seed >>> 11) % ISLAND_H) as number);
    if (pointInPolygon(x, y)) return { x, y };
    const maxR = Math.max(ISLAND_W, ISLAND_H);
    for (let r = 1; r < maxR; r++) {
      for (let dx = -r; dx <= r; dx++) {
        const px1 = x + dx;
        const py1 = y - r;
        if (
          px1 >= ISLAND_X0 &&
          py1 >= ISLAND_Y0 &&
          px1 < ISLAND_X0 + ISLAND_W &&
          py1 < ISLAND_Y0 + ISLAND_H &&
          pointInPolygon(px1, py1)
        )
          return { x: px1, y: py1 };
        const py2 = y + r;
        if (
          px1 >= ISLAND_X0 &&
          py2 >= ISLAND_Y0 &&
          px1 < ISLAND_X0 + ISLAND_W &&
          py2 < ISLAND_Y0 + ISLAND_H &&
          pointInPolygon(px1, py2)
        )
          return { x: px1, y: py2 };
      }
      for (let dy = -r + 1; dy <= r - 1; dy++) {
        const py = y + dy;
        const pxL = x - r;
        const pxR = x + r;
        if (
          pxL >= ISLAND_X0 &&
          py >= ISLAND_Y0 &&
          pxL < ISLAND_X0 + ISLAND_W &&
          py < ISLAND_Y0 + ISLAND_H &&
          pointInPolygon(pxL, py)
        )
          return { x: pxL, y: py };
        if (
          pxR >= ISLAND_X0 &&
          py >= ISLAND_Y0 &&
          pxR < ISLAND_X0 + ISLAND_W &&
          py < ISLAND_Y0 + ISLAND_H &&
          pointInPolygon(pxR, py)
        )
          return { x: pxR, y: py };
      }
    }
    return {
      x: ISLAND_X0 + Math.floor(ISLAND_W / 2),
      y: ISLAND_Y0 + Math.floor(ISLAND_H / 2),
    };
  }

  // Removed auto-fill effect to ensure the preview shows exactly what the user enters
  // (no fallbacks to owned or total supply)

  // Preview should match exactly the entered amount (sell or buy), no fallbacks

  // Grid layout for unlimited m²: contiguous rows/cols; pannable to explore
  const totalSupply = Math.max(0, Math.floor(island?.totalSupplyM2 ?? 0));
  const cols = Math.max(1, Math.ceil(Math.sqrt(Math.max(1, totalSupply))));
  const rows = Math.max(1, Math.ceil(Math.max(1, totalSupply) / cols));
  // legacy 'scale' removed in favor of scaleVis/originXVis/originYVis
  const gridPositions: Array<{ x: number; y: number }> = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const x = c * (tile + gap);
      const y = r * (tile + gap);
      gridPositions.push({ x, y });
    }
  }

  // Pan state for draggable map
  const [pan, setPan] = React.useState<{ x: number; y: number }>({
    x: 0,
    y: 0,
  });
  const [zoom, setZoom] = React.useState<number>(1);
  const [isInteracting, setIsInteracting] = React.useState<boolean>(false);
  const MIN_ZOOM = 0.6;
  const MAX_ZOOM = 8;

  const panRef = React.useRef({
    dragging: false,
    startX: 0,
    startY: 0,
    originX: 0,
    originY: 0,
    moved: false,
  });
  const clickBlockUntilRef = React.useRef<number>(0);
  const wheelEndTimerRef = React.useRef<number | null>(null);
  const lastTapRef = React.useRef<{ t: number; x: number; y: number } | null>(
    null,
  );

  const pointersRef = React.useRef(new Map<number, { x: number; y: number }>());
  const pinchRef = React.useRef({
    active: false,
    startDist: 1,
    startZoom: 1,
    startCenter: { x: 0, y: 0 },
    startPan: { x: 0, y: 0 },
  });

  const panZoomRafRef = React.useRef<number | null>(null);
  const pendingPanZoomRef = React.useRef<{
    pan?: { x: number; y: number };
    zoom?: number;
  }>({});

  // Keep "live" values updated immediately so wheel/pinch events don't use stale state
  const livePanRef = React.useRef(pan);
  const liveZoomRef = React.useRef(zoom);
  React.useEffect(() => {
    livePanRef.current = pan;
  }, [pan.x, pan.y]);
  React.useEffect(() => {
    liveZoomRef.current = zoom;
  }, [zoom]);

  const flushPanZoom = React.useCallback(() => {
    const nextPan = pendingPanZoomRef.current.pan;
    const nextZoom = pendingPanZoomRef.current.zoom;
    pendingPanZoomRef.current = {};
    panZoomRafRef.current = null;
    if (nextPan) {
      livePanRef.current = nextPan;
      setPan(nextPan);
    }
    if (typeof nextZoom === "number") {
      liveZoomRef.current = nextZoom;
      setZoom(nextZoom);
    }
  }, []);

  const schedulePanZoom = React.useCallback(
    (next: { pan?: { x: number; y: number }; zoom?: number }) => {
      if (next.pan) {
        pendingPanZoomRef.current.pan = next.pan;
        livePanRef.current = next.pan;
      }
      if (typeof next.zoom === "number") {
        pendingPanZoomRef.current.zoom = next.zoom;
        liveZoomRef.current = next.zoom;
      }
      if (panZoomRafRef.current == null) {
        panZoomRafRef.current = window.requestAnimationFrame(flushPanZoom);
      }
    },
    [flushPanZoom],
  );

  const onPanStart = (e: React.PointerEvent<SVGSVGElement>) => {
    const preCount = pointersRef.current.size;
    pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // Mobile: double-tap zoom (because onDoubleClick is unreliable on touch)
    if (e.pointerType === "touch" && preCount === 0) {
      const now = Date.now();
      const prev = lastTapRef.current;
      lastTapRef.current = { t: now, x: e.clientX, y: e.clientY };
      if (
        prev &&
        now - prev.t < 320 &&
        Math.hypot(prev.x - e.clientX, prev.y - e.clientY) < 28
      ) {
        lastTapRef.current = null;
        const rect = (e.currentTarget as SVGSVGElement).getBoundingClientRect();
        const localX = e.clientX - rect.left;
        const localY = e.clientY - rect.top;
        setIsInteracting(true);
        applyZoomAt(localX, localY, 1.35);
        if (wheelEndTimerRef.current)
          window.clearTimeout(wheelEndTimerRef.current);
        wheelEndTimerRef.current = window.setTimeout(
          () => setIsInteracting(false),
          180,
        );
        pointersRef.current.clear();
        panRef.current.dragging = false;
        pinchRef.current.active = false;
        return;
      }
    }

    setIsInteracting(true);

    const count = pointersRef.current.size;
    if (count === 2) {
      panRef.current.dragging = false;
      panRef.current.moved = false;

      const pts = Array.from(pointersRef.current.values());
      if (pts.length >= 2) {
        const a = pts[0]!;
        const b = pts[1]!;
        const dist = Math.hypot(a.x - b.x, a.y - b.y);
        const rect = (e.currentTarget as SVGSVGElement).getBoundingClientRect();
        const centerX = (a.x + b.x) / 2 - rect.left;
        const centerY = (a.y + b.y) / 2 - rect.top;

        const z = liveZoomRef.current;
        const p = livePanRef.current;
        pinchRef.current.active = true;
        pinchRef.current.startDist = Math.max(1, dist);
        pinchRef.current.startZoom = z;
        pinchRef.current.startCenter = { x: centerX, y: centerY };
        pinchRef.current.startPan = { x: p.x, y: p.y };
      } else {
        pinchRef.current.active = false;
      }
    } else {
      const p = livePanRef.current;
      panRef.current.dragging = true;
      panRef.current.moved = false;
      panRef.current.startX = e.clientX;
      panRef.current.startY = e.clientY;
      panRef.current.originX = p.x;
      panRef.current.originY = p.y;
    }
    try {
      (e.currentTarget as any).setPointerCapture?.(e.pointerId);
    } catch {}
  };
  const onPanMove = (e: React.PointerEvent<SVGSVGElement>) => {
    if (pointersRef.current.size > 0) setIsInteracting(true);
    // Update pointer position
    if ((pointersRef.current as any).has(e.pointerId)) {
      pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY });
    }
    if (pinchRef.current.active && pointersRef.current.size >= 2) {
      const pts = Array.from(pointersRef.current.values());
      if (pts.length >= 2) {
        const a = pts[0]!;
        const b = pts[1]!;
        const dist = Math.hypot(a.x - b.x, a.y - b.y);

        const rect = (e.currentTarget as SVGSVGElement).getBoundingClientRect();
        const centerX = (a.x + b.x) / 2 - rect.left;
        const centerY = (a.y + b.y) / 2 - rect.top;

        const targetZoom = Math.max(
          MIN_ZOOM,
          Math.min(
            MAX_ZOOM,
            (pinchRef.current.startZoom * dist) /
              Math.max(1, pinchRef.current.startDist),
          ),
        );

        // Compute pan from the pinch-start reference so zoom + translation feel stable.
        const z0 = pinchRef.current.startZoom;
        const p0 = pinchRef.current.startPan;
        const c0 = pinchRef.current.startCenter;
        const prevScale = Math.max(1e-6, scaleVis * z0);
        const nextScale = Math.max(1e-6, scaleVis * targetZoom);

        const gx0 = (c0.x - (p0.x + originXVis)) / prevScale;
        const gy0 = (c0.y - (p0.y + originYVis)) / prevScale;

        let nx = centerX - originXVis - nextScale * gx0;
        let ny = centerY - originYVis - nextScale * gy0;

        const totalScale = nextScale;
        const minPanX = edgePad + waterRadius - originXVis;
        const maxPanX =
          mapW - edgePad - waterRadius - originXVis - gridWidth2 * totalScale;
        const minPanY = edgePad + waterRadius - originYVis;
        const maxPanY =
          mapH - edgePad - waterRadius - originYVis - gridHeight2 * totalScale;

        const clampedX =
          minPanX <= maxPanX ? Math.min(Math.max(nx, minPanX), maxPanX) : 0;
        const clampedY =
          minPanY <= maxPanY ? Math.min(Math.max(ny, minPanY), maxPanY) : 0;

        schedulePanZoom({
          pan: { x: clampedX, y: clampedY },
          zoom: targetZoom,
        });
        return;
      }
      // if fewer than two pointers, fall back to pan
    }
    if (!panRef.current.dragging) return;
    const dx = e.clientX - panRef.current.startX;
    const dy = e.clientY - panRef.current.startY;
    if (!panRef.current.moved && Math.hypot(dx, dy) > 6) {
      panRef.current.moved = true;
    }

    const candidateX = panRef.current.originX + dx;
    const candidateY = panRef.current.originY + dy;

    const totalScale = scaleVis * zoom;
    const minPanX = edgePad + waterRadius - originXVis;
    const maxPanX =
      mapW - edgePad - waterRadius - originXVis - gridWidth2 * totalScale;
    const minPanY = edgePad + waterRadius - originYVis;
    const maxPanY =
      mapH - edgePad - waterRadius - originYVis - gridHeight2 * totalScale;

    const clampedX =
      minPanX <= maxPanX ? Math.min(Math.max(candidateX, minPanX), maxPanX) : 0; // grid smaller than area -> keep centered
    const clampedY =
      minPanY <= maxPanY ? Math.min(Math.max(candidateY, minPanY), maxPanY) : 0;

    schedulePanZoom({ pan: { x: clampedX, y: clampedY } });
  };
  const onPanEnd = (e: React.PointerEvent<SVGSVGElement>) => {
    pointersRef.current.delete(e.pointerId);

    if (panRef.current.moved) {
      clickBlockUntilRef.current = Date.now() + 260;
    }

    if (pointersRef.current.size < 2) pinchRef.current.active = false;
    panRef.current.dragging = false;

    if (pointersRef.current.size === 0) {
      setIsInteracting(false);
    }

    try {
      (e.currentTarget as any).releasePointerCapture?.(e.pointerId);
    } catch {}
  };

  /* applyZoomAt moved below after origin/scale vars */

  const onWheel = (e: React.WheelEvent<SVGSVGElement>) => {
    e.preventDefault();

    // Smooth zoom curve (trackpad + wheel)
    const mult = Math.max(0.6, Math.min(1.6, Math.exp(-e.deltaY * 0.0012)));

    const rect = (e.currentTarget as SVGSVGElement).getBoundingClientRect();
    const localX = e.clientX - rect.left;
    const localY = e.clientY - rect.top;

    setIsInteracting(true);
    applyZoomAt(localX, localY, mult);

    if (wheelEndTimerRef.current) window.clearTimeout(wheelEndTimerRef.current);
    wheelEndTimerRef.current = window.setTimeout(() => {
      setIsInteracting(false);
    }, 160);
  };

  // Determine how many tiles to show: ONLY explicit URL params (?sell or ?buy) override; otherwise show sold m²
  const requestedTiles = sellParam || buyParam || 0;
  const islandSupply = Math.max(
    0,
    Math.floor(Number((island as any)?.totalSupplyM2 ?? 0)),
  );
  // Use island-specific sales only; no global fallback
  const soldCount = Math.max(
    0,
    Math.min(
      islandSupply,
      Math.floor(Number(((data as any)?.island as any)?.soldM2 ?? 0)),
    ),
  );
  const effectiveTiles =
    requestedTiles > 0 ? Math.max(requestedTiles, soldCount) : islandSupply;
  const totalTiles = Math.min(effectiveTiles, islandSupply);
  // Map each preview tile to a stable world coordinate inside the island polygon
  const start = React.useMemo(
    () => pickStableIslandPoint(`island:${id}`),
    [id],
  );
  const side = Math.max(4, Math.ceil(Math.sqrt(Math.max(1, totalTiles))) + 6);
  const worldPositions = React.useMemo(() => {
    const out: Array<{ x: number; y: number }> = [];
    let half = Math.floor(side / 2);
    let minX = start.x - half;
    let minY = start.y - half;
    const maxIter = 5; // expand if not enough inside land
    let iter = 0;
    while (out.length < totalTiles && iter < maxIter) {
      for (let r = 0; r < side && out.length < totalTiles; r++) {
        for (let c = 0; c < side && out.length < totalTiles; c++) {
          const wx = minX + c;
          const wy = minY + r;
          if (
            wx < ISLAND_X0 ||
            wy < ISLAND_Y0 ||
            wx >= ISLAND_X0 + ISLAND_W ||
            wy >= ISLAND_Y0 + ISLAND_H
          )
            continue;
          if (!pointInPolygon(wx, wy)) continue;
          out.push({ x: wx, y: wy });
        }
      }
      // expand search window
      iter++;
      half += 4;
      minX = start.x - half;
      minY = start.y - half;
    }
    return out.slice(0, totalTiles);
  }, [start.x, start.y, totalTiles, side, pointInPolygon]);

  // Fetch ownership state for this area to color tiles like the main map
  const bbox = React.useMemo(() => {
    if (!worldPositions.length) return { x0: 0, y0: 0, w: 1, h: 1 };
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const p of worldPositions) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return {
      x0: Math.floor(minX),
      y0: Math.floor(minY),
      w: Math.floor(maxX - minX + 1),
      h: Math.floor(maxY - minY + 1),
    };
  }, [worldPositions]);
  // Visual layout derived from actual world rows so click selects the exact m²
  const sortedWorld = React.useMemo(
    () => [...worldPositions].sort((a, b) => a.y - b.y || a.x - b.x),
    [worldPositions],
  );
  const groupedRows = React.useMemo(() => {
    const out: Array<{ y: number; start: number; count: number }> = [];
    let i = 0;
    while (i < sortedWorld.length) {
      const y = sortedWorld[i]!.y;
      let j = i + 1;
      while (j < sortedWorld.length && sortedWorld[j]!.y === y) j++;
      out.push({ y, start: i, count: j - i });
      i = j;
    }
    return out;
  }, [sortedWorld]);
  const islandIndexByCoord = React.useMemo(() => {
    const map = new Map<string, number>();
    sortedWorld.forEach((p, idx) => {
      map.set(`${p.x}:${p.y}`, idx + 1);
    });
    return map;
  }, [sortedWorld]);

  // For primary sales on islands we should NOT look at global plot ownership.
  // Availability is determined by the island's sold m² + active island listings.
  const islandListingKeySet = React.useMemo(() => {
    return new Set<string>(
      (islandListings ?? []).map((l: any) => `${l.x}:${l.y}`),
    );
  }, [islandListings]);

  const isFreeIslandPrimary = React.useCallback(
    (wp: { x: number; y: number }) => {
      // In island view, "ownedKeys" reflects global map ownership and is not relevant
      // for island primary sales. We rely on a stable local index and island counters.
      const key = `${wp.x}:${wp.y}`;
      const localIndex = islandIndexByCoord.get(key);
      if (localIndex == null) return false;
      if (localIndex <= soldCount) return false;
      if (islandListingKeySet.has(key)) return false;
      return true;
    },
    [islandIndexByCoord, soldCount, islandListingKeySet],
  );

  const rowWidths = React.useMemo(
    () => groupedRows.map((g) => g.count),
    [groupedRows],
  );
  const rowsCount = rowWidths.length;
  const colsCount = Math.max(
    1,
    rowWidths.reduce((m, c) => Math.max(m, c), 0),
  );
  // Using sortedWorld directly for index→world mapping to ensure exact selection
  const gridWidth2 = colsCount * tile;
  const gridHeight2 = rowsCount * tile;
  const availW2 = mapW - edgePad * 2;
  const availH2 = mapH - edgePad * 2;
  const scaleVis = Math.min(
    1,
    availW2 / Math.max(1, gridWidth2),
    availH2 / Math.max(1, gridHeight2),
  );
  const originXVis = Math.floor(
    edgePad + (availW2 - gridWidth2 * scaleVis) / 2,
  );
  const originYVis = Math.floor(
    edgePad + (availH2 - gridHeight2 * scaleVis) / 2,
  );

  // Clamp pan so the map never leaves the rounded blue water on load and when layout changes
  React.useEffect(() => {
    const totalScale = Math.max(1e-6, scaleVis * zoom);
    const minPanX = edgePad + waterRadius - originXVis;
    const maxPanX =
      mapW - edgePad - waterRadius - originXVis - gridWidth2 * totalScale;
    const minPanY = edgePad + waterRadius - originYVis;
    const maxPanY =
      mapH - edgePad - waterRadius - originYVis - gridHeight2 * totalScale;
    setPan((prev) => {
      const cx =
        minPanX <= maxPanX ? Math.min(Math.max(prev.x, minPanX), maxPanX) : 0;
      const cy =
        minPanY <= maxPanY ? Math.min(Math.max(prev.y, minPanY), maxPanY) : 0;
      if (cx === prev.x && cy === prev.y) return prev;
      return { x: cx, y: cy };
    });
  }, [
    scaleVis,
    zoom,
    originXVis,
    originYVis,
    gridWidth2,
    gridHeight2,
    edgePad,
    waterRadius,
    mapW,
    mapH,
  ]);

  // Build clip path points for island silhouette in local grid coordinates
  const islandClipPoints = React.useMemo(() => {
    const norm: Array<[number, number]> = [
      [0.02, 0.52],
      [0.04, 0.44],
      [0.08, 0.36],
      [0.14, 0.3],
      [0.22, 0.26],
      [0.32, 0.23],
      [0.45, 0.2],
      [0.55, 0.16],
      [0.62, 0.1],
      [0.67, 0.06],
      [0.72, 0.05],
      [0.78, 0.08],
      [0.82, 0.14],
      [0.84, 0.22],
      [0.88, 0.28],
      [0.94, 0.3],
      [0.97, 0.36],
      [0.96, 0.44],
      [0.92, 0.5],
      [0.88, 0.56],
      [0.86, 0.62],
      [0.88, 0.68],
      [0.92, 0.74],
      [0.94, 0.8],
      [0.92, 0.86],
      [0.86, 0.9],
      [0.78, 0.92],
      [0.7, 0.92],
      [0.62, 0.9],
      [0.54, 0.88],
      [0.46, 0.86],
      [0.38, 0.86],
      [0.3, 0.88],
      [0.22, 0.88],
      [0.16, 0.86],
      [0.1, 0.82],
      [0.06, 0.76],
      [0.04, 0.68],
      [0.03, 0.6],
    ];
    return norm
      .map(([nx, ny]) => `${nx * gridWidth2},${ny * gridHeight2}`)
      .join(" ");
  }, [gridWidth2, gridHeight2]);

  const applyZoomAt = React.useCallback(
    (localX: number, localY: number, mult: number) => {
      const prevZoom = liveZoomRef.current;
      const prevPan = livePanRef.current;

      const nextZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, prevZoom * mult));
      if (Math.abs(nextZoom - prevZoom) < 1e-4) return;

      const prevScale = Math.max(1e-6, scaleVis * prevZoom);
      const nextScale = Math.max(1e-6, scaleVis * nextZoom);

      // content coordinates under cursor before zoom
      const gx = (localX - (prevPan.x + originXVis)) / prevScale;
      const gy = (localY - (prevPan.y + originYVis)) / prevScale;

      // pan to keep the same content point under the cursor
      let nx = localX - originXVis - nextScale * gx;
      let ny = localY - originYVis - nextScale * gy;

      // clamp pan within drawable bounds
      const totalScale = nextScale;
      const minPanX = edgePad + waterRadius - originXVis;
      const maxPanX =
        mapW - edgePad - waterRadius - originXVis - gridWidth2 * totalScale;
      const minPanY = edgePad + waterRadius - originYVis;
      const maxPanY =
        mapH - edgePad - waterRadius - originYVis - gridHeight2 * totalScale;

      const clampedX =
        minPanX <= maxPanX ? Math.min(Math.max(nx, minPanX), maxPanX) : 0;
      const clampedY =
        minPanY <= maxPanY ? Math.min(Math.max(ny, minPanY), maxPanY) : 0;

      schedulePanZoom({ pan: { x: clampedX, y: clampedY }, zoom: nextZoom });
    },
    [
      originXVis,
      originYVis,
      scaleVis,
      gridWidth2,
      gridHeight2,
      edgePad,
      mapW,
      mapH,
      schedulePanZoom,
    ],
  );

  const { data: chunk } = useQuery<any>(
    ["island-detail-chunk", id, bbox.x0, bbox.y0, bbox.w, bbox.h],
    () =>
      apiClient.getMapChunk({
        x0: bbox.x0,
        y0: bbox.y0,
        width: bbox.w,
        height: bbox.h,
        islandId: island?.id,
        accessToken,
      } as any),
    {
      enabled: bbox.w > 0 && bbox.h > 0,
      // This powers the tile ownership colors; keep it live while viewing the island.
      refetchOnMount: true,
      staleTime: 2_000,
      refetchInterval: 5_000,
      refetchIntervalInBackground: false,
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      retry: 1,
      placeholderData: () =>
        (queryClient.getQueryData<any>([
          "island-detail-chunk",
          id,
          bbox.x0,
          bbox.y0,
          bbox.w,
          bbox.h,
        ]) ?? null) as any,
    },
  );
  const ownedKeys = React.useMemo(() => {
    const set = new Set<string>();
    (chunk?.cells ?? []).forEach(
      (c: any) => c?.ownerId && set.add(`${c.x}:${c.y}`),
    );
    return set;
  }, [chunk]);
  const mineKeys = React.useMemo(() => {
    const set = new Set<string>();
    (chunk?.cells ?? []).forEach(
      (c: any) => c?.ownedByMe && set.add(`${c.x}:${c.y}`),
    );
    return set;
  }, [chunk]);

  // Take the first N preview positions for layout only (visual positions)
  const layoutTiles = React.useMemo(() => {
    const arr: Array<{ x: number; y: number }> = [];
    for (let r = 0; r < rowWidths.length; r++) {
      const rowTiles = Math.max(
        0,
        Math.min(colsCount, rowWidths[r] ?? colsCount),
      );
      const offsetTiles = Math.max(0, (colsCount - rowTiles) / 2);
      for (let c = 0; c < rowTiles; c++) {
        arr.push({ x: (c + offsetTiles) * tile, y: r * tile });
      }
    }
    return arr;
  }, [rowWidths, colsCount, tile]);
  const highlightTiles = layoutTiles;
  const rowStartIndices = React.useMemo(() => {
    const out: number[] = [];
    let acc = 0;
    for (let r = 0; r < rowWidths.length; r++) {
      out.push(acc);
      acc += Math.max(0, Math.min(colsCount, rowWidths[r] ?? colsCount));
    }
    return out;
  }, [rowWidths, colsCount]);

  // Map tap is now only for info/focus (buy/sell happens via the Quick Buy/Sell inputs)
  const handleTileTap = React.useCallback(
    (idx: number) => {
      setFocusedIdx(idx);
    },
    [setFocusedIdx],
  );

  const priceChartPoints = (() => {
    const sorted = [...chartSamples].filter(
      (s) => typeof s.priceUSD === "number" && !Number.isNaN(s.priceUSD),
    );
    if (!sorted.length)
      return [] as Array<{
        x: number;
        y: number;
        price: number;
        t?: string | Date;
      }>;
    sorted.sort((a, b) => {
      const ta = a?.createdAt ? new Date(a.createdAt as any).getTime() : 0;
      const tb = b?.createdAt ? new Date(b.createdAt as any).getTime() : 0;
      return ta - tb;
    });
    const pricesOnly = sorted.map((s) => s.priceUSD);
    const min = Math.min(...pricesOnly);
    const max = Math.max(...pricesOnly);
    const width = 280;
    const height = 220;
    const padX = 1;
    const padY = 40;
    const innerW = width - padX * 2;
    const innerH = height - padY * 2;
    const denom = Math.max(max - min, 1e-6);
    const n = sorted.length;

    const timeValues = sorted
      .map((s) => (s?.createdAt ? new Date(s.createdAt as any).getTime() : NaN))
      .filter((t) => Number.isFinite(t));
    const hasTime = timeValues.length >= 2;
    const minTime = hasTime ? Math.min(...timeValues) : 0;
    const maxTime = hasTime ? Math.max(...timeValues) : 0;
    const timeSpan = Math.max(maxTime - minTime, 1);

    return sorted.map((s, idx) => {
      let ts = s?.createdAt ? new Date(s.createdAt as any).getTime() : NaN;
      if (!Number.isFinite(ts)) {
        ts = hasTime ? minTime : 0;
      }
      const tNorm = hasTime
        ? (ts - minTime) / timeSpan
        : n > 1
          ? idx / (n - 1)
          : 0.5;
      const x = padX + tNorm * innerW;
      const norm = (s.priceUSD - min) / denom;
      const y = padY + (1 - norm) * innerH;
      return { x, y, price: s.priceUSD, t: s.createdAt };
    });
  })();
  const priceChartMin =
    priceChartPoints.length > 0
      ? (priceChartPoints as any[]).reduce(
          (m, p) => (p.price < m ? p.price : m),
          priceChartPoints[0]!.price,
        )
      : 0;
  const priceChartMax =
    priceChartPoints.length > 0
      ? (priceChartPoints as any[]).reduce(
          (m, p) => (p.price > m ? p.price : m),
          priceChartPoints[0]!.price,
        )
      : 0;
  const hoverPoint =
    hoverIndex != null &&
    hoverIndex >= 0 &&
    hoverIndex < priceChartPoints.length
      ? ((priceChartPoints as any[])[hoverIndex] as any)
      : null;

  const hoverDateLabel =
    hoverPoint && hoverPoint.t
      ? new Date(hoverPoint.t as any).toISOString().replace(".000Z", "Z")
      : "";
  const chartYBounds = (() => {
    if (!priceChartPoints.length) {
      return { min: 0, max: 220 };
    }
    const ys = (priceChartPoints as any[]).map((p) => p.y as number);
    const rawMin = Math.min(...ys);
    const rawMax = Math.max(...ys);
    return {
      min: Math.max(0, rawMin - 16),
      max: Math.min(220, rawMax + 16),
    };
  })();
  const timeAxisLabels = (() => {
    if (!chartSamples.length || !priceChartPoints.length) {
      return [] as Array<{ label: string; index: number; x: number }>;
    }

    const timeIndexArr: Array<{ time: number; index: number }> = [];
    chartSamples.forEach((s, idx) => {
      if (!s?.createdAt) return;
      const t = new Date(s.createdAt as any).getTime();
      if (Number.isFinite(t)) timeIndexArr.push({ time: t, index: idx });
    });

    const width = 280;
    const padX = 1;
    const innerW = width - padX * 2;

    const baseStepMs =
      chartRange === "24H"
        ? 10 * 60 * 1000
        : chartRange === "7D"
          ? 60 * 60 * 1000
          : 6 * 60 * 60 * 1000;

    const labelCount = chartRange === "24H" ? 4 : chartRange === "7D" ? 7 : 7;

    const nowMs = Date.now();

    const out: Array<{ label: string; index: number; x: number }> = [];
    for (let i = 0; i < labelCount; i++) {
      const tNorm = labelCount > 1 ? i / (labelCount - 1) : 0.5;
      const targetTime = nowMs - (labelCount - 1 - i) * baseStepMs;

      let nearestIndex = 0;
      if (timeIndexArr.length > 0) {
        let nearest = timeIndexArr[0]!;
        let bestDist = Math.abs(nearest.time - targetTime);
        for (let j = 1; j < timeIndexArr.length; j++) {
          const cand = timeIndexArr[j]!;
          const dist = Math.abs(cand.time - targetTime);
          if (dist < bestDist) {
            bestDist = dist;
            nearest = cand;
          }
        }
        nearestIndex = nearest.index;
      }

      const labelDate = new Date(targetTime);
      let label: string;
      if (chartRange === "24H") {
        label = labelDate.toISOString().slice(11, 19) + "Z";
      } else {
        label = labelDate.toISOString().replace(".000Z", "Z");
      }

      const x = padX + tNorm * innerW;
      out.push({ label, index: nearestIndex, x });
    }

    return out;
  })();
  const timeGridLines = (() => {
    if (!priceChartPoints.length) return [] as number[];
    const width = 280;
    const padX = 1;
    const innerW = width - padX * 2;
    const count = 17; // more vertical grid lines for smaller cells, almost full width
    const lines: number[] = [];
    for (let i = 0; i < count; i++) {
      const t = count > 1 ? i / (count - 1) : 0.5;
      lines.push(padX + t * innerW);
    }
    return lines;
  })();
  const horizontalGridLines = priceChartPoints.length
    ? (() => {
        const lines: number[] = [];
        const count = 9; // more horizontal grid lines for finer raster
        const span = chartYBounds.max - chartYBounds.min;
        for (let i = 0; i < count; i++) {
          const t = count > 1 ? i / (count - 1) : 0.5;
          lines.push(chartYBounds.min + t * span);
        }
        return lines;
      })()
    : [];

  return (
    <ScreenContainer
      title={island?.name ?? "Island"}
      right={
        island ? (
          <Button
            size="sm"
            variant="secondary"
            onClick={() => {
              const url = new URL(`/islands/${id}`, getBaseUrl()).toString();
              const title = (island?.name ?? "Island").toString();

              const doCopy = () => {
                copy(url);
                toast({ title: "Link copied" });
              };

              if (
                typeof navigator !== "undefined" &&
                (navigator as any).share
              ) {
                (navigator as any).share({ title, url }).catch(() => doCopy());
              } else {
                doCopy();
              }
            }}
          >
            <Share2 className="h-4 w-4 mr-2" />
            Share
          </Button>
        ) : undefined
      }
    >
      <div className="mt-4 grid gap-4">
        {(isLoading || profileInitialLoading) && (
          <AppSpinner label="Loading..." />
        )}
        {isError && (
          <Alert>
            <AlertDescription className="text-sm">
              Island not found or error while loading.
              <div className="mt-2 flex gap-2">
                <Button size="sm" variant="secondary" onClick={() => refetch()}>
                  Reload
                </Button>
                <Button size="sm" onClick={() => navigate("/islands")}>
                  Back to list
                </Button>
              </div>
            </AlertDescription>
          </Alert>
        )}
        {!isLoading && !isError && !island && (
          <Alert>
            <AlertDescription className="text-sm">
              Island not found.
              <div className="mt-2">
                <Button size="sm" onClick={() => navigate("/islands")}>
                  Back to list
                </Button>
              </div>
            </AlertDescription>
          </Alert>
        )}

        {island && (
          <>
            <div className="grid grid-cols-1 md:grid-cols-[2.2fr_1fr] gap-4">
              {/* Left: Chart & stats */}
              <Card className="overflow-hidden">
                <CardHeader className="flex items-center justify-between pl-0 pr-4 md:pr-6">
                  <div className="flex items-center gap-4 -ml-4 md:-ml-6">
                    <div className="relative inline-block p-1.5 rounded-2xl ring-2 ring-accent border-0">
                      <div className="h-20 w-20 rounded-xl bg-secondary ring-2 ring-background overflow-hidden flex items-center justify-center">
                        {iconPreviewUrl || island.iconUrl ? (
                          <img
                            src={(iconPreviewUrl || island.iconUrl) as any}
                            alt="icon"
                            className="h-full w-full object-cover"
                            onError={() => {
                              // If a previously saved URL is broken, don't keep showing a broken image.
                              setIconPreviewUrl(null);
                            }}
                          />
                        ) : (
                          <span className="text-xs text-muted-foreground">
                            m²
                          </span>
                        )}
                      </div>
                      {isOwner && (
                        <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 flex items-center gap-1">
                          <Button
                            size="sm"
                            variant="secondary"
                            className="h-7 px-2 rounded-full"
                            onClick={(e) => {
                              e.preventDefault();
                              e.stopPropagation();
                              handlePickIslandIcon();
                            }}
                            disabled={updateIslandIconMutation.isLoading}
                          >
                            {updateIslandIconMutation.isLoading
                              ? "Saving…"
                              : island.iconUrl
                                ? "Change"
                                : "Icon"}{" "}
                          </Button>
                          {island.iconUrl && (
                            <Button
                              size="sm"
                              variant="outline"
                              className="h-7 px-2 rounded-full"
                              onClick={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                if (!id) return;
                                updateIslandIconMutation.mutate({
                                  islandId: id as string,
                                  remove: true,
                                  accessToken,
                                } as any);
                              }}
                              disabled={updateIslandIconMutation.isLoading}
                            >
                              Remove
                            </Button>
                          )}
                        </div>
                      )}
                    </div>
                    <input
                      ref={iconFileInputRef}
                      type="file"
                      accept="image/*"
                      className="sr-only"
                      onChange={async (e) => {
                        const f = e.target.files?.[0];
                        if (!f || !id) return;

                        // Reset value so selecting the same file again works
                        try {
                          (e.target as any).value = "";
                        } catch {}

                        const MAX_ICON_MB = 20;
                        if (f.size > MAX_ICON_MB * 1024 * 1024) {
                          toast({
                            title: "Image is too large",
                            description: `Please use a smaller image (max ${MAX_ICON_MB}MB).`,
                          });
                          return;
                        }

                        try {
                          const b64 = await makeSquareIconPng(f, 256);
                          setIconPreviewUrl(b64);
                          updateIslandIconMutation.mutate({
                            islandId: id as string,
                            iconBase64: b64,
                            accessToken,
                          } as any);
                        } catch (err: any) {
                          setIconPreviewUrl(null);
                          toast({
                            title: "Couldn't use this image",
                            description:
                              err?.message || "Please pick a JPG or PNG image.",
                          });
                        }
                      }}
                    />
                    <div className="min-w-0">
                      <CardTitle className="text-3xl">{island.name}</CardTitle>
                      {island?.description ? (
                        <div className="mt-1 text-sm text-muted-foreground truncate max-w-[520px]">
                          {String(island.description)}
                        </div>
                      ) : null}
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-3xl font-semibold">
                      {formatPPC(currentPrice || 0)}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      m² price (PP Coins, based on user trades)
                    </div>
                  </div>
                </CardHeader>
                <CardContent className="grid gap-3 px-0 pb-0">
                  {/* Market Cap header bar */}
                  <div className="text-xs text-muted-foreground">Sold area</div>
                  <div className="flex items-center gap-2">
                    <div className="flex-1">
                      <Progress
                        value={
                          islandSupply > 0
                            ? Math.max(
                                0,
                                Math.min(
                                  100,
                                  Math.round((soldCount / islandSupply) * 100),
                                ),
                              )
                            : 0
                        }
                      />
                    </div>
                    <div className="text-xs">
                      {soldCount.toLocaleString()} m² of{" "}
                      {islandSupply.toLocaleString()} m² sold{" "}
                    </div>
                  </div>
                  {/* Toolbar moved into chart card to mirror reference design */}{" "}
                  <div className="text-xs text-muted-foreground">
                    Price: {formatPPC(currentPrice || 0)}
                    <span className="ml-3">
                      Amount: {Math.max(0, Math.floor(Number(buyAmount) || 0))}{" "}
                      m²
                    </span>{" "}
                    <span className="ml-3">
                      Cost:{" "}
                      {formatPPC(
                        Math.max(0, Math.floor(Number(buyAmount) || 0)) *
                          (currentPrice || 0),
                      )}
                    </span>
                    {profile && (
                      <span className="ml-3">
                        Wallet:{" "}
                        {formatPPC(
                          Math.max(0, Number((profile as any).balance ?? 0)),
                        )}
                      </span>
                    )}
                    <span className="ml-3">
                      Sold: {soldCount.toLocaleString()} m² • Available:{" "}
                      {Math.max(0, islandSupply - soldCount).toLocaleString()}{" "}
                      m²
                    </span>{" "}
                  </div>{" "}
                  {/* Market-style chart (same look as Market tab) */}
                  <MarketStylePPCChart
                    currentPrice={Number(currentPrice || 0)}
                    range={
                      chartRange === "24H"
                        ? "1H"
                        : chartRange === "7D"
                          ? "5H"
                          : "1W"
                    }
                    onRangeChange={(r) => {
                      if (r === "1H") setChartRange("24H");
                      else if (r === "5H") setChartRange("7D");
                      else if (r === "1W") setChartRange("30D");
                      else if (r === "1MO") setChartRange("30D");
                      else setChartRange("30D");
                    }}
                    queryKeyBase={["islandPriceHistory_inline", id]}
                    fetchHistory={async ({ minutes }) => {
                      const now = Date.now();
                      const cutoff = now - minutes * 60 * 1000;
                      const basePrice = Number(
                        currentPrice || island?.startPriceUSD || 0,
                      );
                      const series = (samples ?? [])
                        .map((s) => {
                          const t = s?.createdAt
                            ? new Date(s.createdAt as any).getTime()
                            : NaN;
                          return {
                            t: Number.isFinite(t) ? new Date(t) : null,
                            price: Number(s?.priceUSD ?? NaN),
                          };
                        })
                        .filter(
                          (p) =>
                            p.t &&
                            Number.isFinite(p.price) &&
                            +new Date(p.t as any) >= cutoff,
                        )
                        .sort(
                          (a, b) =>
                            +new Date(a.t as any) - +new Date(b.t as any),
                        ) as Array<{ t: any; price: number }>;

                      if (series.length === 0) {
                        return [
                          { t: new Date(cutoff), price: basePrice },
                          { t: new Date(now), price: basePrice },
                        ];
                      }
                      if (series.length === 1) {
                        return [
                          { t: new Date(cutoff), price: series[0]!.price },
                          series[0]!,
                        ];
                      }
                      return series;
                    }}
                  />
                  {false && priceChartPoints.length > 0 && (
                    <div className="px-4 pt-3 pb-1">
                      <div className="relative rounded-[32px] bg-gradient-to-b from-[#050716] via-[#070B1F] to-[#050716] border border-[#243b72]/60 shadow-[0_0_40px_rgba(37,99,235,0.55)] px-5 pt-4 pb-6 overflow-hidden">
                        <div className="flex items-baseline justify-between mb-6">
                          <div>
                            <div className="text-xs tracking-wide text-slate-300/80 mb-1">
                              m² price (PP Coins, based on user trades)
                            </div>
                            <div className="text-2xl font-semibold text-white">
                              {formatPPC(currentPrice || 0)}
                            </div>
                          </div>
                          <div className="text-right text-[11px] text-slate-300/80">
                            <div className="mb-0.5">24h chart</div>
                          </div>{" "}
                        </div>
                        <div className="flex justify-start mb-4">
                          <div className="inline-flex rounded-full bg-slate-800/80 p-1 text-[11px]">
                            <Button
                              size="sm"
                              variant={
                                chartRange === "24H" ? "default" : "secondary"
                              }
                              className="rounded-full px-4 py-1 h-7 text-xs"
                              onClick={() => {
                                setChartRange("24H");
                                setChartWindowPos(1);
                              }}
                            >
                              {" "}
                              24hr
                            </Button>
                            <Button
                              size="sm"
                              variant={
                                chartRange === "7D" ? "default" : "secondary"
                              }
                              className="rounded-full px-4 py-1 h-7 text-xs"
                              onClick={() => {
                                setChartRange("7D");
                                setChartWindowPos(1);
                              }}
                            >
                              {" "}
                              Weekly
                            </Button>
                            <Button
                              size="sm"
                              variant={
                                chartRange === "30D" ? "default" : "secondary"
                              }
                              className="rounded-full px-4 py-1 h-7 text-xs"
                              onClick={() => {
                                setChartRange("30D");
                                setChartWindowPos(1);
                              }}
                            >
                              {" "}
                              Monthly
                            </Button>
                          </div>
                        </div>
                        <div className="absolute inset-x-0 bottom-[-35%] h-40 bg-gradient-to-t from-[#2563EB]/40 via-[#60A5FA]/20 to-transparent blur-3xl pointer-events-none" />{" "}
                        <div className="mb-2 flex items-center justify-between text-[10px] text-slate-300/80">
                          <span>Low: {priceChartMin.toFixed(2)} PPC</span>
                          <span>High: {priceChartMax.toFixed(2)} PPC</span>
                        </div>
                        <svg
                          viewBox="0 0 280 220"
                          className="relative w-full h-72 text-sky-400"
                          onMouseLeave={() => setHoverIndex(null)}
                        >
                          {" "}
                          <defs>
                            {" "}
                            <linearGradient
                              id={`island-chart-line-${id}`}
                              x1="0"
                              y1="0"
                              x2="0"
                              y2="1"
                            >
                              <stop offset="0%" stopColor="#60A5FA" />
                              <stop offset="50%" stopColor="#3B82F6" />
                              <stop offset="100%" stopColor="#1D4ED8" />
                            </linearGradient>
                            <filter
                              id={`island-chart-glow-${id}`}
                              x="-50%"
                              y="-50%"
                              width="200%"
                              height="200%"
                            >
                              <feDropShadow
                                dx="0"
                                dy="0"
                                stdDeviation="6"
                                floodColor="#60A5FA"
                                floodOpacity="0.85"
                              />
                            </filter>
                          </defs>
                          {timeGridLines.length > 0 && (
                            <g>
                              {timeGridLines.map((xVal, idx) => (
                                <line
                                  key={`v-grid-${idx}`}
                                  x1={xVal}
                                  x2={xVal}
                                  y1={chartYBounds.min}
                                  y2={chartYBounds.max}
                                  stroke="rgba(148, 163, 184, 0.35)"
                                  strokeWidth={0.8}
                                />
                              ))}
                              {horizontalGridLines.map((yVal, idx) => (
                                <line
                                  key={`h-grid-${idx}`}
                                  x1={priceChartPoints[0]?.x ?? 0}
                                  x2={
                                    priceChartPoints[
                                      priceChartPoints.length - 1
                                    ]?.x ?? 0
                                  }
                                  y1={yVal}
                                  y2={yVal}
                                  stroke="rgba(148, 163, 184, 0.25)"
                                  strokeWidth={0.7}
                                />
                              ))}
                            </g>
                          )}
                          <polyline
                            fill="none"
                            stroke={`url(#island-chart-line-${id})`}
                            strokeWidth="4"
                            strokeLinejoin="round"
                            strokeLinecap="round"
                            points={priceChartPoints
                              .map((p) => `${p.x},${p.y}`)
                              .join(" ")}
                            filter={`url(#island-chart-glow-${id})`}
                          />
                          <polyline
                            fill="none"
                            stroke={`url(#island-chart-line-${id})`}
                            strokeWidth="2.4"
                            strokeLinejoin="round"
                            strokeLinecap="round"
                            points={priceChartPoints
                              .map((p) => `${p.x},${p.y}`)
                              .join(" ")}
                          />{" "}
                          {priceChartPoints.map((p, idx) => (
                            <circle
                              key={idx}
                              cx={p.x}
                              cy={p.y}
                              r={4}
                              fill="transparent"
                              onMouseEnter={() => setHoverIndex(idx)}
                              onClick={() => setHoverIndex(idx)}
                              onTouchStart={() => setHoverIndex(idx)}
                            />
                          ))}
                          {hoverPoint && (
                            <g>
                              <line
                                x1={hoverPoint.x}
                                x2={hoverPoint.x}
                                y1={chartYBounds.min}
                                y2={chartYBounds.max}
                                stroke="#60A5FA"
                                strokeWidth={1.5}
                                strokeOpacity={0.7}
                              />
                              <circle
                                cx={hoverPoint.x}
                                cy={hoverPoint.y}
                                r={5}
                                fill="#020617"
                                stroke="#F9FAFB"
                                strokeWidth={2}
                              />
                              <circle
                                cx={hoverPoint.x}
                                cy={hoverPoint.y}
                                r={9}
                                fill="none"
                                stroke="#60A5FA"
                                strokeOpacity={0.7}
                                strokeWidth={1.5}
                              />
                            </g>
                          )}{" "}
                        </svg>
                        {hoverPoint && (
                          <div
                            className="pointer-events-none absolute z-20"
                            style={{
                              left: `${(hoverPoint.x / 280) * 100}%`,
                              top: `${(hoverPoint.y / 220) * 100}%`,
                              transform: "translate(-50%, -130%)",
                            }}
                          >
                            <div className="rounded-2xl bg-slate-900/95 border border-slate-700/70 px-3 py-2 text-[11px] text-slate-100 shadow-[0_18px_45px_rgba(15,23,42,0.7)]">
                              <div className="text-xs font-medium mb-0.5">
                                {hoverDateLabel}
                              </div>
                              <div className="text-[11px] leading-tight">
                                <div className="font-semibold">
                                  {formatPPC(hoverPoint.price)}
                                </div>
                              </div>
                            </div>
                          </div>
                        )}
                        {timeAxisLabels.length > 0 && (
                          <div
                            ref={timelineRef}
                            className="mt-1 relative h-10 text-[11px] text-slate-400 px-5 select-none"
                            onPointerDown={onTimelinePointerDown}
                            onPointerMove={onTimelinePointerMove}
                            onPointerUp={onTimelinePointerUp}
                            onPointerLeave={onTimelinePointerUp}
                            onPointerCancel={onTimelinePointerUp}
                          >
                            {timeAxisLabels.map((l, idx) => (
                              <div
                                key={idx}
                                className="absolute inset-y-0 flex flex-col items-center"
                                style={{
                                  left: `${(l.x / 280) * 100}%`,
                                  transform: "translateX(-50%)",
                                }}
                              >
                                <div className="w-px flex-1 bg-slate-700/60" />
                                <div
                                  className="mt-1 cursor-pointer"
                                  onMouseEnter={() => setHoverIndex(l.index)}
                                  onClick={() => setHoverIndex(l.index)}
                                >
                                  {l.label}
                                </div>
                              </div>
                            ))}
                          </div>
                        )}{" "}
                        {chartSliderEnabled && (
                          <div className="mt-1 flex items-center justify-between text-[10px] text-slate-500 px-1">
                            <span>Earlier</span>
                            <span>Live UTC {utcNowLabel}</span>
                          </div>
                        )}
                      </div>
                    </div>
                  )}{" "}
                  <div className="flex items-center gap-4 text-xs px-4">
                    {" "}
                    <span className="flex items-center gap-1">
                      <span
                        className="inline-block w-3 h-3 rounded-sm"
                        style={{ backgroundColor: "hsl(var(--free))" }}
                      />{" "}
                      Available collectible
                    </span>
                    <span className="flex items-center gap-1">
                      <span
                        className="inline-block w-3 h-3 rounded-sm"
                        style={{ backgroundColor: "hsl(var(--owned))" }}
                      />{" "}
                      Owned by others
                    </span>
                    <span className="flex items-center gap-1">
                      <span
                        className="inline-block w-3 h-3 rounded-sm"
                        style={{ backgroundColor: "hsl(var(--owned-mine))" }}
                      />{" "}
                      My collectible m²
                    </span>
                  </div>
                  <div
                    className="w-full overflow-hidden rounded-lg relative"
                    ref={mapContainerRef}
                  >
                    <div className="absolute right-3 top-3 z-30 flex flex-col gap-2">
                      <Button
                        size="sm"
                        variant="secondary"
                        className="h-10 w-10 rounded-full p-0"
                        onClick={() => {
                          const el = mapSvgRef.current;
                          if (!el) return;
                          const rect = el.getBoundingClientRect();
                          setIsInteracting(true);
                          applyZoomAt(rect.width / 2, rect.height / 2, 1.2);
                          if (wheelEndTimerRef.current)
                            window.clearTimeout(wheelEndTimerRef.current);
                          wheelEndTimerRef.current = window.setTimeout(
                            () => setIsInteracting(false),
                            180,
                          );
                        }}
                        title="Zoom in"
                      >
                        <span className="sr-only">Zoom in</span>
                        <Plus className="h-5 w-5" />
                      </Button>
                      <Button
                        size="sm"
                        variant="secondary"
                        className="h-10 w-10 rounded-full p-0"
                        onClick={() => {
                          const el = mapSvgRef.current;
                          if (!el) return;
                          const rect = el.getBoundingClientRect();
                          setIsInteracting(true);
                          applyZoomAt(rect.width / 2, rect.height / 2, 1 / 1.2);
                          if (wheelEndTimerRef.current)
                            window.clearTimeout(wheelEndTimerRef.current);
                          wheelEndTimerRef.current = window.setTimeout(
                            () => setIsInteracting(false),
                            180,
                          );
                        }}
                        title="Zoom out"
                      >
                        <span className="sr-only">Zoom out</span>
                        <Minus className="h-5 w-5" />
                      </Button>
                      <Button
                        size="sm"
                        variant="secondary"
                        className="h-10 w-10 rounded-full p-0"
                        onClick={() => {
                          clickBlockUntilRef.current = Date.now() + 260;
                          setIsInteracting(true);
                          setIsInteracting(true);
                          schedulePanZoom({ pan: { x: 0, y: 0 }, zoom: 1 });
                          if (wheelEndTimerRef.current)
                            window.clearTimeout(wheelEndTimerRef.current);
                          wheelEndTimerRef.current = window.setTimeout(
                            () => setIsInteracting(false),
                            180,
                          );
                        }}
                        title="Reset view"
                      >
                        <span className="sr-only">Reset view</span>
                        <RefreshCcw className="h-5 w-5" />
                      </Button>
                    </div>
                    <svg
                      ref={mapSvgRef}
                      viewBox={`0 0 ${mapW} ${mapH}`}
                      className="w-full h-[68vh] cursor-grab active:cursor-grabbing select-none"
                      onPointerDown={onPanStart}
                      onPointerMove={onPanMove}
                      onPointerUp={onPanEnd}
                      onPointerCancel={onPanEnd}
                      onPointerLeave={onPanEnd}
                      onWheel={onWheel}
                      style={{ touchAction: "none" }}
                      onDoubleClick={(e) => {
                        e.preventDefault();
                        const rect = (
                          e.currentTarget as SVGSVGElement
                        ).getBoundingClientRect();
                        const localX = e.clientX - rect.left;
                        const localY = e.clientY - rect.top;
                        applyZoomAt(localX, localY, 1.35);
                      }}
                      onClick={(e) => {
                        if (Date.now() < clickBlockUntilRef.current) return;
                        // Tap is now only for info/focus (no selecting to buy/sell)
                        const rect = (
                          e.currentTarget as SVGSVGElement
                        ).getBoundingClientRect();
                        const localX = e.clientX - rect.left;
                        const localY = e.clientY - rect.top;
                        const invScale = 1 / Math.max(1e-6, scaleVis * zoom);
                        const gx = (localX - (pan.x + originXVis)) * invScale;
                        const gy = (localY - (pan.y + originYVis)) * invScale;

                        const row = Math.floor(gy / tile);
                        if (row < 0 || row >= rowsCount) return;

                        const rowTiles = Math.max(
                          0,
                          Math.min(colsCount, rowWidths[row] ?? colsCount),
                        );
                        if (rowTiles <= 0) return;

                        const offsetTiles = Math.max(
                          0,
                          (colsCount - rowTiles) / 2,
                        );
                        const col = Math.floor(gx / tile - offsetTiles);
                        if (col < 0 || col >= rowTiles) return;

                        const idx = (rowStartIndices[row] ?? 0) + col;
                        if (idx >= 0 && idx < highlightTiles.length) {
                          setFocusedIdx(idx);
                        }
                      }}
                    >
                      {" "}
                      <defs>
                        {" "}
                        <linearGradient
                          id={`tileFrame-${id}`}
                          x1="0%"
                          y1="0%"
                          x2="0%"
                          y2="100%"
                        >
                          <stop offset="0%" stopColor={"hsl(118 46% 44%)"} />
                          <stop offset="100%" stopColor={"hsl(118 44% 40%)"} />
                        </linearGradient>
                        <clipPath id={`islandClip-${id}`}>
                          <polygon points={islandClipPoints} />
                        </clipPath>
                      </defs>
                      {/* Map background (same as /map) */}
                      <rect
                        x={0}
                        y={0}
                        width={mapW}
                        height={mapH}
                        rx={waterRadius}
                        ry={waterRadius}
                        fill={"hsl(var(--map-bg))"}
                      />
                      {/* Tiles */}
                      <g
                        transform={`translate(${pan.x + originXVis}, ${pan.y + originYVis}) scale(${scaleVis * zoom})`}
                        style={{
                          transition: isInteracting
                            ? "none"
                            : "transform 120ms ease-out",
                        }}
                      >
                        {" "}
                        {/* Gridlines to match main map grout */}
                        <g>
                          {Array.from({ length: colsCount + 1 }).map(
                            (_, ci) => (
                              <line
                                key={`vline-${ci}`}
                                x1={ci * tile}
                                y1={0}
                                x2={ci * tile}
                                y2={gridHeight2}
                                stroke={`hsl(var(--grout))`}
                                strokeWidth={2.2}
                                strokeLinecap={"round"}
                                strokeLinejoin={"round"}
                                strokeOpacity={0}
                              />
                            ),
                          )}
                          {Array.from({ length: rowsCount + 1 }).map(
                            (_, ri) => (
                              <line
                                key={`hline-${ri}`}
                                x1={0}
                                y1={ri * tile}
                                x2={gridWidth2}
                                y2={ri * tile}
                                stroke={`hsl(var(--grout))`}
                                strokeWidth={2.2}
                                strokeLinecap={"round"}
                                strokeLinejoin={"round"}
                                strokeOpacity={0}
                              />
                            ),
                          )}
                        </g>
                        {highlightTiles.map((p, i) => (
                          <g
                            key={`h-${i}`}
                            onClick={(e) => {
                              e.stopPropagation();
                              handleTileTap(i);
                            }}
                          >
                            {/* Base tile with status color like main map */}
                            {(() => {
                              const wp = worldPositions[i];
                              if (!wp) return null;
                              const key = `${wp.x}:${wp.y}`;
                              let isMine = mineKeys.has(key);
                              let isOwned = ownedKeys.has(key) && !isMine;
                              const hasIslandListing = (
                                islandListings as any[] | undefined
                              )?.some((l: any) => l.x === wp.x && l.y === wp.y);

                              // If there is no real ownership data for this tile,
                              // distribute the island's sold m² virtually across the map.
                              const localIndex = islandIndexByCoord.get(
                                `${wp.x}:${wp.y}`,
                              );
                              const soldVirtual =
                                localIndex != null && localIndex <= soldCount;
                              if (!isMine && !isOwned && soldVirtual) {
                                const isCreator =
                                  !!((supa as any)?.user?.id as
                                    | string
                                    | undefined) &&
                                  (island as any)?.owner?.id ===
                                    ((supa as any)?.user?.id as
                                      | string
                                      | undefined);

                                if (isCreator) {
                                  isMine = true;
                                  isOwned = false;
                                } else {
                                  isOwned = true;
                                }
                              }

                              const fill = hasIslandListing
                                ? `hsl(var(--listing))`
                                : isMine
                                  ? `hsl(var(--owned-mine))`
                                  : isOwned
                                    ? `hsl(var(--owned))`
                                    : `hsl(var(--free))`;
                              const inset = Math.max(
                                2,
                                Math.round(tile * 0.18),
                              );
                              const inner = Math.max(0, tile - 1.5 - inset * 2);
                              const rOuter = Math.max(
                                5,
                                Math.round(tile * 0.22),
                              );
                              const rInner = Math.max(
                                3,
                                Math.round(inner * 0.18),
                              );

                              return (
                                <>
                                  {/* Outer frame (same look as /map tiles) */}
                                  <rect
                                    x={p.x}
                                    y={p.y}
                                    width={tile - 1.5}
                                    height={tile - 1.5}
                                    rx={rOuter}
                                    ry={rOuter}
                                    fill={`url(#tileFrame-${id})`}
                                  />

                                  {/* Inner status color */}
                                  <rect
                                    x={p.x + inset}
                                    y={p.y + inset}
                                    width={inner}
                                    height={inner}
                                    rx={rInner}
                                    ry={rInner}
                                    fill={fill}
                                  />

                                  {/* Inner bevel like /map tiles */}
                                  <rect
                                    x={p.x}
                                    y={p.y}
                                    width={tile - 1.5}
                                    height={tile - 1.5}
                                    rx={rOuter}
                                    ry={rOuter}
                                    fill="none"
                                    stroke="rgba(255,255,255,0.10)"
                                    strokeWidth={0.9}
                                    vectorEffect="non-scaling-stroke"
                                  />
                                </>
                              );
                            })()}{" "}
                            {/* Thin inner border for bevel effect */}
                            <rect
                              x={p.x}
                              y={p.y}
                              width={tile - 1.5}
                              height={tile - 1.5}
                              rx={2}
                              ry={2}
                              fill="none"
                              stroke="none"
                              strokeWidth={0.6}
                              vectorEffect="non-scaling-stroke"
                            />
                            {/* Glanzlicht */}
                            <rect
                              x={p.x + 2}
                              y={p.y + 2}
                              width={Math.max(0, tile - 6)}
                              height={Math.max(0, (tile - 6) / 2)}
                              rx={4}
                              ry={4}
                              fill={`url(#highlight-${id})`}
                              opacity={0}
                            />{" "}
                            {/* Selection blue border */}{" "}
                            {focusedIdx === i && (
                              <rect
                                x={p.x + 0.8}
                                y={p.y + 0.8}
                                width={tile - 1.6}
                                height={tile - 1.6}
                                rx={5}
                                ry={5}
                                fill="none"
                                stroke="rgba(59,130,246,0.9)"
                                strokeWidth={3}
                                vectorEffect="non-scaling-stroke"
                              />
                            )}{" "}
                          </g>
                        ))}
                      </g>
                    </svg>
                    {(() => {
                      if (focusedIdx == null) return null;
                      const p = highlightTiles[focusedIdx];
                      if (!p) return null;
                      const scale = Math.max(1e-6, scaleVis * zoom);
                      const localX =
                        pan.x + originXVis + (p.x + tile / 2) * scale;
                      const localY =
                        pan.y + originYVis + (p.y + tile / 2) * scale;
                      const leftPct = Math.max(
                        5,
                        Math.min(95, (localX / mapW) * 100),
                      );
                      const topPct = Math.max(
                        5,
                        Math.min(95, (localY / mapH) * 100),
                      );
                      const wp = sortedWorld[focusedIdx];
                      if (!wp) return null;
                      const key = `${wp.x}:${wp.y}`;
                      let isMine = mineKeys.has(key);
                      let isOwned = ownedKeys.has(key) && !isMine;
                      const listing = (
                        islandListings as any[] | undefined
                      )?.find((l: any) => l.x === wp.x && l.y === wp.y);
                      const isMineListing =
                        !!listing &&
                        myIdLocal &&
                        listing.sellerId === myIdLocal;
                      // Info-Popup auch ohne Listing anzeigen (frei, dein, besetzt)

                      const localIndex = islandIndexByCoord.get(
                        `${wp.x}:${wp.y}`,
                      );

                      // Sold m² must not appear as "free" and buyable.
                      // If there is no real ownership data, interpret the first soldCount tiles as sold.
                      const soldVirtual =
                        localIndex != null && localIndex <= soldCount;
                      if (!isMine && !isOwned && soldVirtual) {
                        const isCreator =
                          !!((supa as any)?.user?.id as string | undefined) &&
                          (island as any)?.owner?.id ===
                            ((supa as any)?.user?.id as string | undefined);
                        if (isCreator) {
                          isMine = true;
                          isOwned = false;
                        } else {
                          isOwned = true;
                        }
                      }
                      const positionLabel =
                        localIndex != null
                          ? `m² ${localIndex}`
                          : `Pos ${wp.x}:${wp.y}`;
                      // Listing-Info (graue Felder)
                      if (listing) {
                        const priceLabelListing = `${(
                          listing.priceEUR ?? 0
                        ).toFixed(2)} EUR / m²`;
                        return (
                          <div
                            className="pointer-events-auto absolute z-20 bg-popover text-popover-foreground border rounded-md shadow-lg px-3 py-2 text-xs"
                            style={{
                              left: `${leftPct}%`,
                              top: `${topPct}%`,
                              transform: "translate(-50%, -110%)",
                            }}
                          >
                            <div className="font-medium">
                              {isMineListing ? "Your listing" : "For sale"}
                            </div>
                            <div>{priceLabelListing}</div>
                            <div>{positionLabel}</div>
                            {!isMineListing && (
                              <div className="mt-1">
                                <Button
                                  size="sm"
                                  className="pointer-events-auto w-full bg-green-600 text-white hover:bg-green-700"
                                  disabled={
                                    buySecondaryListingMutation.isLoading
                                  }
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    if (!isAuthed) {
                                      toast({
                                        title: "Sign in required",
                                        description:
                                          "Please sign in to buy collectibles.",
                                      });
                                      promptSignIn();
                                      return;
                                    }
                                    buySecondaryListingMutation.mutate({
                                      x: listing.x,
                                      y: listing.y,
                                      accessToken,
                                    } as any);
                                  }}
                                >
                                  {buySecondaryListingMutation.isLoading
                                    ? "Buying..."
                                    : !isAuthed
                                      ? "Sign in to buy"
                                      : "Buy this m²"}
                                </Button>{" "}
                              </div>
                            )}
                            {isMineListing && (
                              <div className="mt-1 text-[11px] text-muted-foreground">
                                Own listing – manage it in 2nd Market under "My
                                listings".
                              </div>
                            )}
                          </div>
                        );
                      }

                      // Kein Listing – immer Info anzeigen (frei, dein, besetzt)
                      const isFreeTile = isFreeIslandPrimary(wp);
                      const statusLabel = isFreeTile
                        ? "Free (available to buy)"
                        : soldVirtual
                          ? "Already sold"
                          : "Not available";
                      const priceLabel = `${formatPPC(currentPrice || 0)} / m²`;
                      let walletBal =
                        profile && typeof (profile as any).balance === "number"
                          ? Number((profile as any).balance)
                          : 0;
                      const effectiveBalance = Number(
                        (profile as any)?.balanceUSD ??
                          (profile as any)?.balance ??
                          walletBal,
                      );
                      walletBal = Number.isFinite(effectiveBalance)
                        ? effectiveBalance
                        : walletBal;
                      const canBuy =
                        isFreeTile && walletBal >= Number(currentPrice || 0);

                      return (
                        <div
                          className="pointer-events-auto absolute z-20 bg-popover text-popover-foreground border rounded-md shadow-lg px-3 py-2 text-xs"
                          style={{
                            left: `${leftPct}%`,
                            top: `${topPct}%`,
                            transform: "translate(-50%, -110%)",
                          }}
                        >
                          <div className="font-medium">{statusLabel}</div>
                          <div>{priceLabel}</div>
                          <div>{positionLabel}</div>
                          <div className="mt-1 space-y-1">
                            <div>
                              <span className="text-muted-foreground">
                                Wallet:
                              </span>{" "}
                              {currencyUSD(walletBal)}{" "}
                              {isFreeTile ? (
                                canBuy ? (
                                  <span className="text-emerald-500 font-semibold">
                                    • You can buy this m²
                                  </span>
                                ) : (
                                  <span className="text-red-500 font-semibold">
                                    • Not enough balance
                                  </span>
                                )
                              ) : (
                                <span className="text-muted-foreground">
                                  • This m² is not available for primary sale
                                </span>
                              )}{" "}
                            </div>
                            {isFreeTile && (
                              <Button
                                size="sm"
                                className="pointer-events-auto w-full bg-green-600 text-white hover:bg-green-700"
                                disabled={!canBuy || buyExactMutation.isLoading}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  if (!isAuthed) {
                                    toast({
                                      title: "Sign in required",
                                      description:
                                        "Please sign in to buy collectibles.",
                                    });
                                    promptSignIn();
                                    return;
                                  }
                                  if (!canBuy) {
                                    toast({
                                      title: "Error",
                                      description:
                                        "Not enough balance for this purchase.",
                                    });
                                    return;
                                  }
                                  buyExactMutation.mutate({
                                    coords: [{ x: wp.x, y: wp.y }],
                                    islandId: island?.id,
                                    accessToken,
                                  } as any);
                                }}
                              >
                                {buyExactMutation.isLoading
                                  ? "Buying..."
                                  : "Buy this m²"}
                              </Button>
                            )}{" "}
                          </div>
                        </div>
                      );
                    })()}{" "}
                  </div>{" "}
                  {(() => {
                    return null;
                  })()}
                  {/* Info-Leiste zu fokussierter Kachel */}
                  {(() => {
                    if (focusedIdx == null) return null;
                    const wp = sortedWorld[focusedIdx];
                    if (!wp) return null;
                    const key = `${wp.x}:${wp.y}`;
                    const isMine = mineKeys.has(key);
                    const isOwned = ownedKeys.has(key) && !isMine;
                    const status = isMine
                      ? "Yours"
                      : isOwned
                        ? "Owned"
                        : "For sale";
                    return (
                      <div className="hidden">
                        <div>
                          <span className="text-muted-foreground">Status:</span>{" "}
                          {status}
                        </div>
                        <div>
                          <span className="text-muted-foreground">Price:</span>{" "}
                          {formatPPC(currentPrice || 0)} / m²
                        </div>
                        <div className="text-muted-foreground">
                          Pos: {wp.x}:{wp.y}
                        </div>
                        {!isMine && !isOwned && (
                          <div className="ml-auto text-xs text-muted-foreground">
                            Tip: Tap to select for purchase
                          </div>
                        )}
                      </div>
                    );
                  })()}
                </CardContent>
              </Card>
              {/* Right: Action panel */}{" "}
              <Card className="overflow-hidden">
                <CardHeader>
                  <CardTitle className="text-base">Trade</CardTitle>
                </CardHeader>
                <CardContent className="grid gap-3">
                  {/* Mode toggle */}
                  <div className="flex items-center gap-2">
                    <Button
                      size="sm"
                      variant="secondary"
                      className="data-[active=true]:bg-green-600 data-[active=true]:text-white"
                      data-active={!isSellMode}
                      onClick={() => setIsSellMode(false)}
                    >
                      Buy Collectible
                    </Button>
                    <Button
                      size="sm"
                      variant="secondary"
                      className="data-[active=true]:bg-red-600 data-[active=true]:text-white"
                      data-active={isSellMode}
                      onClick={() => {
                        if (!isAuthed) {
                          toast({
                            title: "Sign in required",
                            description: "Please sign in to sell collectibles.",
                          });
                          promptSignIn();
                          return;
                        }
                        setIsSellMode(true);
                      }}
                    >
                      Sell Collectible
                    </Button>{" "}
                  </div>

                  {/* Trade tile */}
                  {!isSellMode ? (
                    <div className="rounded-lg border p-3 grid gap-3">
                      {/* Amount */}
                      <div className="grid gap-2">
                        <div className="text-xs text-muted-foreground">
                          Amount (m² collectible)
                        </div>{" "}
                        <Input
                          placeholder="0"
                          inputMode="numeric"
                          value={buyAmount}
                          onChange={(e) =>
                            setBuyAmount(e.target.value.replace(/[^0-9]/g, ""))
                          }
                        />
                        <div className="flex flex-wrap gap-2">
                          {[1, 5, 10].map((v) => (
                            <Button
                              key={v}
                              size="sm"
                              variant="secondary"
                              onClick={() => setBuyAmount(String(v))}
                            >
                              {v} m²
                            </Button>
                          ))}
                          <Button
                            size="sm"
                            variant="secondary"
                            onClick={() => {
                              const freeCount = sortedWorld.reduce(
                                (acc, wp) =>
                                  acc + (isFreeIslandPrimary(wp) ? 1 : 0),
                                0,
                              );
                              setBuyAmount(String(Math.max(0, freeCount)));
                            }}
                          >
                            {" "}
                            Max
                          </Button>
                        </div>
                      </div>

                      {/* Primary action */}
                      <Button
                        className="bg-green-600 text-white"
                        disabled={buyExactMutation.isLoading}
                        onClick={async () => {
                          if (!isAuthed) {
                            toast({
                              title: "Sign in required",
                              description:
                                "Please sign in to buy collectibles.",
                            });
                            promptSignIn();
                            return;
                          }

                          const qty = Math.max(
                            0,
                            Math.floor(Number(buyAmount) || 0),
                          );
                          if (qty <= 0) {
                            toast({
                              title: "Enter an amount",
                              description:
                                "Enter an amount of m² (e.g. 1, 5, 10).",
                            });
                            return;
                          }

                          const pricePer = Number(currentPrice || 0);

                          // Use wallet from profile (PP coins are credited instantly)
                          let wallet = Number((profile as any)?.balance ?? 0);

                          if (!Number.isFinite(wallet) || wallet < 0)
                            wallet = 0;

                          // Find free m² on this island and buy EXACTLY the amount the user entered.
                          // If there aren't enough free m², do not buy a smaller amount.
                          const freeCount = sortedWorld.reduce(
                            (acc, wp) =>
                              acc + (isFreeIslandPrimary(wp) ? 1 : 0),
                            0,
                          );

                          if (freeCount <= 0) {
                            toast({
                              title: "No free m²",
                              description:
                                "There are currently no free m² available on this island.",
                            });
                            return;
                          }

                          if (qty > freeCount) {
                            toast({
                              title: "Not enough available m²",
                              description: `Only ${freeCount.toLocaleString()} m² are available right now. Please reduce the amount (or tap Max).`,
                            });
                            return;
                          }

                          const freeCoords: { x: number; y: number }[] = [];
                          for (let i = 0; i < sortedWorld.length; i++) {
                            const wp = sortedWorld[i]!;
                            if (isFreeIslandPrimary(wp)) {
                              freeCoords.push({ x: wp.x, y: wp.y });
                              if (freeCoords.length >= qty) break;
                            }
                          }

                          // In rare cases the island can change between render and click.
                          if (freeCoords.length !== qty) {
                            toast({
                              title: "Island updated",
                              description:
                                "The available m² changed a moment ago. Please try again.",
                            });
                            return;
                          }

                          const needed = Math.round(qty * pricePer * 100) / 100;
                          if (wallet + 1e-6 < needed) {
                            toast({
                              title: "Error",
                              description: `Insufficient balance. Needed: ${formatPPC(needed)} • Wallet: ${formatPPC(wallet)}`,
                            });
                            return;
                          }

                          buyExactMutation.mutate({
                            coords: freeCoords,
                            islandId: island?.id,
                            accessToken,
                          } as any);
                        }}
                      >
                        {!isAuthed
                          ? "Sign in to buy"
                          : buyExactMutation.isLoading
                            ? "Buying..."
                            : "Buy Collectible"}
                      </Button>
                    </div>
                  ) : (
                    <div className="rounded-lg border p-3 grid gap-3">
                      <div className="text-xs text-muted-foreground">
                        Amount = how many m² you want to sell (e.g. 10). No
                        coordinates needed.
                      </div>
                      <div className="grid gap-2">
                        <div className="text-xs text-muted-foreground">
                          Amount (m² collectible)
                        </div>{" "}
                        <Input
                          placeholder="e.g. 10"
                          inputMode="numeric"
                          value={sellAmount}
                          onChange={(e) => {
                            const raw = e.target.value;
                            // If someone pastes coordinates like "12,34" or "12:34",
                            // interpret it as "12" (amount) instead of "1234".
                            const m = raw.match(/\d+/);
                            setSellAmount(m ? m[0] : "");
                          }}
                        />
                      </div>
                      <div className="grid gap-2">
                        <div className="flex items-center justify-between">
                          <div className="text-xs text-muted-foreground">
                            Price
                          </div>
                        </div>
                        <Input
                          placeholder="0.00"
                          inputMode="decimal"
                          value={sellPrice}
                          onChange={(e) => setSellPrice(e.target.value)}
                        />
                      </div>
                      <Button
                        className="bg-red-600 text-white"
                        disabled={createListings.isLoading}
                        onClick={() => {
                          if (!isAuthed) {
                            toast({
                              title: "Sign in required",
                              description:
                                "Please sign in to sell collectibles.",
                            });
                            promptSignIn();
                            return;
                          }

                          const priceEUR = Math.max(0, Number(sellPrice || 0));
                          if (!priceEUR) {
                            toast({ title: "Price required" });
                            return;
                          }

                          const need = Math.max(
                            0,
                            Math.floor(Number(sellAmount) || 0),
                          );
                          if (need <= 0) {
                            toast({
                              title: "Enter an amount",
                              description:
                                "Enter an amount of m² (e.g. 1, 5, 10).",
                            });
                            return;
                          }

                          const islandId = String(island?.id || "");
                          if (!islandId) {
                            toast({
                              title: "Island not loaded",
                              description: "Please try again in a moment.",
                            });
                            return;
                          }

                          createListings.mutate({
                            amountM2: need,
                            priceEUR,
                            islandId,
                          } as any);
                        }}
                      >
                        {" "}
                        {createListings.isLoading
                          ? "Listing…"
                          : "Sell Collectible"}{" "}
                      </Button>
                    </div>
                  )}

                  {/* Island listings (secondary market, compact) */}
                  <div className="rounded-lg border p-3">
                    <div className="flex items-center justify-between gap-2 mb-2">
                      <div className="text-sm font-medium">
                        Listings on this island
                      </div>
                      <div className="inline-flex rounded-full border p-1 bg-secondary/60 shadow-sm">
                        <Button
                          size="sm"
                          variant={
                            viewFilterLocal === "ALL" ? "default" : "secondary"
                          }
                          onClick={() => setViewFilterLocal("ALL")}
                          aria-pressed={viewFilterLocal === "ALL"}
                        >
                          All
                        </Button>
                        <Button
                          size="sm"
                          variant={
                            viewFilterLocal === "MINE" ? "default" : "secondary"
                          }
                          onClick={() => setViewFilterLocal("MINE")}
                          aria-pressed={viewFilterLocal === "MINE"}
                          disabled={!isAuthed}
                        >
                          Mine
                        </Button>
                      </div>
                    </div>

                    {/* Bulk buy only on ALL */}
                    {viewFilterLocal === "ALL" && (
                      <div className="mb-3 rounded-md border bg-secondary/30 p-2">
                        <div className="text-xs text-muted-foreground mb-2">
                          Buy multiple listings at once
                        </div>
                        <div className="flex items-center gap-2">
                          <Input
                            className="h-9"
                            inputMode="numeric"
                            placeholder="Quantity"
                            value={bulkBuyQty}
                            onChange={(e) =>
                              setBulkBuyQty(
                                e.target.value.replace(/[^0-9]/g, ""),
                              )
                            }
                            disabled={bulkBuying}
                          />
                          <AlertDialog
                            open={bulkBuyOpen}
                            onOpenChange={setBulkBuyOpen}
                          >
                            <AlertDialogTrigger asChild>
                              <Button
                                size="sm"
                                className="h-9"
                                disabled={
                                  bulkBuying ||
                                  bulkQty <= 0 ||
                                  bulkSelection.length === 0
                                }
                                onClick={(e) => {
                                  if (!isAuthed) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    toast({
                                      title: "Sign in required",
                                      description:
                                        "Please sign in to buy collectibles.",
                                    });
                                    promptSignIn();
                                  }
                                }}
                              >
                                {!isAuthed
                                  ? "Sign in to buy"
                                  : bulkBuying
                                    ? `Buying ${bulkBoughtCount}/${Math.max(1, bulkBuyTarget || bulkSelection.length || bulkQty)}…`
                                    : `Buy ${bulkSelection.length || 0} m²`}
                              </Button>
                            </AlertDialogTrigger>{" "}
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>
                                  {`Buy ${bulkSelection.length} m²?`}
                                </AlertDialogTitle>
                                <AlertDialogDescription>
                                  You will buy the cheapest{" "}
                                  {bulkSelection.length} listings in one go.
                                  <div className="mt-2 text-sm">
                                    <div>
                                      <span className="font-medium">
                                        Total:
                                      </span>{" "}
                                      {formatPPC(bulkTotal)}
                                    </div>
                                    <div>
                                      <span className="font-medium">
                                        Avg / m²:
                                      </span>{" "}
                                      {formatPPC(bulkAvg)}
                                    </div>
                                  </div>
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel disabled={bulkBuying}>
                                  Cancel
                                </AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={(e) => {
                                    e.preventDefault();
                                    void runBulkBuy();
                                  }}
                                  disabled={bulkBuying}
                                >
                                  {bulkBuying
                                    ? `Buying ${bulkBoughtCount}/${Math.max(
                                        1,
                                        bulkBuyTarget ||
                                          bulkSelection.length ||
                                          bulkQty,
                                      )}…`
                                    : "Yes, buy"}
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>
                        </div>
                        <div className="mt-2 text-[11px] text-muted-foreground">
                          {bulkSelection.length > 0 ? (
                            <span>
                              Total:{" "}
                              <span className="font-medium">
                                {formatPPC(bulkTotal)}
                              </span>
                              {bulkCandidates.length > bulkSelection.length ? (
                                <span>
                                  {" "}
                                  • available: {bulkCandidates.length}
                                </span>
                              ) : null}
                            </span>
                          ) : (
                            <span>No matching listings found.</span>
                          )}
                        </div>
                      </div>
                    )}

                    {islandListings && islandListings.length > 0 ? (
                      <div className="grid gap-2">
                        {islandListings
                          .slice(0, listingsVisibleCount)
                          .map((l: any, i: number) => {
                            const localIndex = islandIndexByCoord.get(
                              `${l.x}:${l.y}`,
                            );
                            const isMineListing = l.sellerId === myIdLocal;
                            return (
                              <details
                                key={`${l.x}:${l.y}:${i}`}
                                className="group rounded-md border bg-card px-2 py-1.5"
                              >
                                <summary className="flex items-center justify-between text-sm cursor-pointer list-none">
                                  <div className="flex items-center gap-3 min-w-0">
                                    <div className="text-xs text-muted-foreground shrink-0">
                                      m² {localIndex ?? "?"}
                                    </div>
                                    <div className="font-semibold truncate">
                                      {formatPPC(l.priceEUR ?? 0)}{" "}
                                    </div>
                                  </div>
                                  {viewFilterLocal === "MINE" &&
                                  isMineListing ? (
                                    <Button
                                      size="sm"
                                      variant="secondary"
                                      onClick={(e) => {
                                        e.preventDefault();
                                        navigate(
                                          `/secondary?viewFilter=MINE&coord=${encodeURIComponent(
                                            `${l.x},${l.y}`,
                                          )}`,
                                        );
                                      }}
                                    >
                                      Info
                                    </Button>
                                  ) : (
                                    <Button
                                      size="sm"
                                      variant="secondary"
                                      disabled={
                                        isMineListing ||
                                        buySecondaryListingMutation.isLoading
                                      }
                                      onClick={(e) => {
                                        e.preventDefault();
                                        if (isMineListing) return;
                                        if (!isAuthed) {
                                          toast({
                                            title: "Sign in required",
                                            description:
                                              "Please sign in to buy collectibles.",
                                          });
                                          promptSignIn();
                                          return;
                                        }
                                        buySecondaryListingMutation.mutate({
                                          x: l.x,
                                          y: l.y,
                                          accessToken,
                                        } as any);
                                      }}
                                    >
                                      {!isAuthed
                                        ? "Sign in to buy"
                                        : "Buy Collectible"}
                                    </Button>
                                  )}
                                </summary>
                                <div className="mt-1 text-xs text-muted-foreground space-y-0.5">
                                  <div>
                                    Price: {formatPPC(l.priceEUR ?? 0)} / m²
                                    collectible
                                  </div>
                                  <div>Coordinate: m² {localIndex ?? "?"}</div>
                                  {viewFilterLocal !== "MINE" &&
                                    isMineListing && <div>Own listing</div>}
                                </div>
                              </details>
                            );
                          })}

                        {islandListings.length > INITIAL_LISTINGS && (
                          <div className="pt-1">
                            <Button
                              size="sm"
                              variant="outline"
                              className="w-full"
                              onClick={() => {
                                setListingsVisibleCount((prev) => {
                                  if (prev >= islandListings.length)
                                    return INITIAL_LISTINGS;
                                  return Math.min(
                                    islandListings.length,
                                    prev + LISTINGS_STEP,
                                  );
                                });
                              }}
                            >
                              {listingsVisibleCount >= islandListings.length
                                ? "Show less"
                                : `Show ${Math.min(
                                    LISTINGS_STEP,
                                    Math.max(
                                      0,
                                      islandListings.length -
                                        listingsVisibleCount,
                                    ),
                                  )} more`}
                            </Button>
                          </div>
                        )}
                      </div>
                    ) : (
                      <div className="text-xs text-muted-foreground">
                        No listings on this island.
                      </div>
                    )}
                  </div>

                  {/* Top holders */}
                  <div className="rounded-lg border p-3">
                    <div className="grid gap-2">
                      <div className="flex items-center justify-between">
                        <div className="text-sm font-medium">Top holders</div>
                        <div className="text-[11px] text-muted-foreground">
                          Live
                        </div>
                      </div>
                      <div className="grid gap-1">
                        {((topHolders as any)?.holders ?? [])
                          .slice(0, 5)
                          .map((row: any, idx: number) => {
                            const total =
                              Number((topHolders as any)?.totalOwnedM2 ?? 0) ||
                              1;
                            const pct =
                              ((Number(row?.ownedM2 ?? 0) || 0) / total) * 100;
                            const user = row?.user;
                            return (
                              <div
                                key={row?.userId ?? idx}
                                className="flex items-center justify-between gap-3 text-xs"
                              >
                                <div className="flex items-center gap-2 min-w-0">
                                  <div className="h-6 w-6 rounded-full bg-secondary overflow-hidden shrink-0">
                                    {holderAvatar(user) ? (
                                      <img
                                        src={holderAvatar(user) as any}
                                        alt="avatar"
                                        className="h-full w-full object-cover"
                                      />
                                    ) : null}
                                  </div>
                                  <div className="truncate">
                                    {holderName(user)}
                                  </div>
                                </div>
                                <div className="text-right shrink-0">
                                  <div className="font-medium">
                                    {(
                                      Number(row?.ownedM2 ?? 0) || 0
                                    ).toLocaleString()}{" "}
                                    m²
                                  </div>
                                  <div className="text-muted-foreground">
                                    {pct.toFixed(2)}%
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        {(((topHolders as any)?.holders ?? []).length || 0) ===
                          0 && (
                          <div className="text-xs text-muted-foreground">
                            No data available.
                          </div>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* My live stats */}
                  {isAuthed && (
                    <div className="rounded-lg border p-3">
                      <div className="flex items-center justify-between gap-2">
                        <div className="text-sm font-medium">My stats</div>
                        <div className="text-[11px] text-muted-foreground text-right">
                          Live
                          {earningsUpdatedAt ? (
                            <span>
                              {" "}
                              • updated{" "}
                              {formatDateTime(new Date(earningsUpdatedAt))}
                            </span>
                          ) : null}
                          {earningsIsFetching ? (
                            <span> • updating…</span>
                          ) : null}
                        </div>
                      </div>
                      <div className="mt-2 grid gap-2 text-xs">
                        <div className="flex items-center justify-between">
                          <span className="text-muted-foreground">
                            Owned (current)
                          </span>
                          <span className="font-medium">
                            {(
                              Number(
                                (earningsSummary as any)?.currentOwnedM2 ?? 0,
                              ) || 0
                            ).toLocaleString()}{" "}
                            m²
                          </span>
                        </div>
                        <div className="flex items-center justify-between">
                          <span className="text-muted-foreground">
                            Bought (total)
                          </span>
                          <span>
                            {(
                              Number((earningsSummary as any)?.boughtM2 ?? 0) ||
                              0
                            ).toLocaleString()}{" "}
                            m²
                          </span>
                        </div>
                        <div className="flex items-center justify-between">
                          <span className="text-muted-foreground">
                            Sold (total)
                          </span>
                          <span>
                            {(
                              Number((earningsSummary as any)?.soldM2 ?? 0) || 0
                            ).toLocaleString()}{" "}
                            m²
                          </span>
                        </div>
                        <div className="h-px w-full bg-border" />
                        <div className="flex items-center justify-between">
                          <span className="text-muted-foreground">
                            Earned (net)
                          </span>
                          <span
                            className={
                              Number((earningsSummary as any)?.netPPC ?? 0) >= 0
                                ? "text-emerald-500 font-semibold"
                                : "text-red-500 font-semibold"
                            }
                          >
                            {formatPPC(
                              Number((earningsSummary as any)?.netPPC ?? 0) ||
                                0,
                            )}
                          </span>
                        </div>
                        <div className="flex items-center justify-between">
                          <span className="text-muted-foreground">
                            From resale
                          </span>
                          <span>
                            {formatPPC(
                              Number(
                                (earningsSummary as any)?.proceedsPPC ?? 0,
                              ) || 0,
                            )}
                          </span>
                        </div>
                        <div className="flex items-center justify-between">
                          <span className="text-muted-foreground">
                            Commission received
                          </span>
                          <span>
                            {formatPPC(
                              Number(
                                (earningsSummary as any)?.commissionEarnedPPC ??
                                  0,
                              ) || 0,
                            )}
                          </span>
                        </div>
                        <div className="flex items-center justify-between">
                          <span className="text-muted-foreground">Spent</span>
                          <span>
                            {formatPPC(
                              Number((earningsSummary as any)?.spentPPC ?? 0) ||
                                0,
                            )}
                          </span>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Island info */}
                  <div className="rounded-lg border p-3">
                    <div className="flex items-center justify-between gap-2">
                      <div className="text-sm font-medium">Island info</div>
                      <div className="text-[11px] text-muted-foreground text-right">
                        Overview
                      </div>
                    </div>

                    <div className="mt-2 grid gap-2 text-xs">
                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">Created</span>
                        <span className="text-right">
                          {island?.createdAt
                            ? formatDateTime(new Date(island.createdAt as any))
                            : "–"}
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">Creator</span>
                        <span className="text-right">
                          {holderName(island?.owner)}
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">Ticker</span>
                        <span className="text-right">
                          {String(island?.ticker || "–")}
                        </span>
                      </div>

                      <div className="h-px w-full bg-border" />

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">
                          Total supply
                        </span>
                        <span className="text-right">
                          {Math.max(
                            0,
                            Math.floor(Number(island?.totalSupplyM2 ?? 0)),
                          ).toLocaleString()}{" "}
                          m²
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">Sold</span>
                        <span className="text-right">
                          {soldCount.toLocaleString()} m²
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">Available</span>
                        <span className="text-right">
                          {Math.max(
                            0,
                            islandSupply - soldCount,
                          ).toLocaleString()}{" "}
                          m²
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">
                          Listings (2nd market)
                        </span>
                        <span className="text-right">
                          {Math.max(
                            0,
                            (islandListings as any[])?.length ?? 0,
                          ).toLocaleString()}
                        </span>
                      </div>

                      <div className="h-px w-full bg-border" />

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">
                          Start price
                        </span>
                        <span className="text-right">
                          {formatPPC(Number(island?.startPriceUSD ?? 0) || 0)}
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">
                          Current price
                        </span>
                        <span className="text-right">
                          {formatPPC(Number(currentPrice || 0) || 0)}
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">Step up</span>
                        <span className="text-right">
                          {Number(island?.stepUpPct ?? 0).toFixed(2)}%
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">
                          Owner commission
                        </span>
                        <span className="text-right">
                          {Number(island?.commissionPct ?? 0).toFixed(2)}%
                        </span>
                      </div>

                      <div className="flex items-center justify-between gap-3">
                        <span className="text-muted-foreground">
                          Revenue split
                        </span>
                        <span className="text-right">
                          {Number(island?.ownerSharePct ?? 0).toFixed(0)}% /{" "}
                          {Number(island?.platformSharePct ?? 0).toFixed(0)}%
                        </span>
                      </div>
                    </div>
                  </div>
                </CardContent>
              </Card>{" "}
            </div>
            <div className="mt-6 text-[11px] text-muted-foreground text-center">
              Smaller reference only. Not a financial product.
            </div>
          </>
        )}
      </div>
    </ScreenContainer>
  );
}

function NewsDetailScreen() {
  const { id } = useParams<{ id: string }>();
  const { toast } = useToast();
  const navigate = useNavigate();

  const isSampleLink = String(id ?? "") === "sample";

  const postQuery = useQuery(
    ["newsPost", id],
    () => apiClient.getNewsPost({ id: String(id ?? "") }),
    {
      enabled: !!id && !isSampleLink,
      staleTime: 10_000,
    },
  );

  const p = postQuery.data as
    | {
        id: string;
        title: string;
        body: string;
        createdAt: any;
      }
    | undefined;

  return (
    <ScreenContainer title="News">
      <div className="max-w-[820px] mx-auto">
        <>
          {postQuery.isInitialLoading && <AppSpinner label="Loading…" />}

          {(isSampleLink || postQuery.error) && (
            <Alert>
              <AlertTitle>News not found</AlertTitle>
              <AlertDescription>
                This news post may have been deleted or the link is invalid.
                <div className="mt-3 flex gap-2">
                  <Button
                    size="sm"
                    variant="secondary"
                    onClick={() => navigate("/general")}
                  >
                    Back
                  </Button>
                  {!isSampleLink && (
                    <Button size="sm" onClick={() => postQuery.refetch()}>
                      Retry
                    </Button>
                  )}
                </div>
              </AlertDescription>
            </Alert>
          )}

          {!postQuery.isInitialLoading && !postQuery.error && p && (
            <Card className="overflow-hidden">
              <CardHeader className="pb-3">
                <CardTitle className="text-xl">{p.title}</CardTitle>
                <div className="text-xs text-muted-foreground">
                  {p.createdAt
                    ? `Published ${formatDateTime(new Date(p.createdAt as any))}`
                    : ""}
                </div>
              </CardHeader>
              <CardContent>
                <div className="text-sm text-muted-foreground leading-relaxed whitespace-pre-wrap">
                  {p.body}
                </div>
              </CardContent>
              <div className="px-6 pb-6 flex items-center justify-end gap-2">
                <Button
                  size="sm"
                  variant="secondary"
                  onClick={() => navigate("/general")}
                >
                  Back to General
                </Button>
                <Button
                  size="sm"
                  onClick={() => {
                    const url = new URL(
                      `/news/${p.id}`,
                      getBaseUrl(),
                    ).toString();
                    const title = p.title;

                    const doCopy = () => {
                      copy(url);
                      toast({ title: "Link copied" });
                    };

                    if (
                      typeof navigator !== "undefined" &&
                      (navigator as any).share
                    ) {
                      (navigator as any)
                        .share({ title, url })
                        .catch(() => doCopy());
                    } else {
                      doCopy();
                    }
                  }}
                >
                  <Share2 className="h-4 w-4 mr-2" />
                  Share
                </Button>
              </div>
            </Card>
          )}
        </>
      </div>
    </ScreenContainer>
  );
}

function GeneralScreen() {
  type TopicKey =
    | "pp15"
    | "ppc"
    | "market"
    | "map"
    | "islands"
    | "secondary"
    | "wallet"
    | "news";

  const supa = useSupabase();

  const { data: profile } = useQuery<GetProfileOutput>(
    ["profile", supa.accessToken ?? ""],
    () => apiClient.getProfile({ accessToken: supa.accessToken ?? undefined }),
    {
      staleTime: 30_000,
    },
  );

  const isOwner = !!profile?.isOwner;

  // Owner can manage news either via in-app sign-in (Supabase) or via platform session.
  // Everyone else can only view/share.
  const canManageNews = isOwner;

  const topics: Array<{ key: TopicKey; label: string; icon: React.ReactNode }> =
    [
      { key: "pp15", label: "PP15.ONE", icon: <Info className="h-4 w-4" /> },
      {
        key: "ppc",
        label: "PPC (PP coins)",
        icon: (
          <div
            className="relative inline-block"
            style={{ transform: "rotate(-18deg)" }}
          >
            <CoinIcon className="h-4 w-4" />
          </div>
        ),
      },
      { key: "market", label: "Market", icon: <Home className="h-4 w-4" /> },
      { key: "map", label: "Map", icon: <Building2 className="h-4 w-4" /> },
      {
        key: "islands",
        label: "Islands",
        icon: <Search className="h-4 w-4" />,
      },
      {
        key: "secondary",
        label: "2nd Market",
        icon: <ArrowLeftRight className="h-4 w-4" />,
      },
      { key: "wallet", label: "Wallet", icon: <Wallet2 className="h-4 w-4" /> },
      {
        key: "news" as const,
        label: "News",
        icon: <TrendingUp className="h-4 w-4" />,
      },
    ];

  const [topic, setTopic] = React.useState<TopicKey>("pp15");

  const active = topics.find((t) => t.key === topic) ?? topics[0]!;

  const Chip = ({
    t,
  }: {
    t: { key: TopicKey; label: string; icon: React.ReactNode };
  }) => {
    const isActive = t.key === topic;
    return (
      <button
        type="button"
        onClick={() => setTopic(t.key)}
        className={`shrink-0 inline-flex items-center gap-2 rounded-full px-3 py-1.5 text-xs font-bold border transition-colors ${
          isActive
            ? "bg-primary text-primary-foreground border-white/10"
            : "bg-background/10 text-foreground border-border hover:bg-accent"
        }`}
      >
        {t.icon}
        <span>{t.label}</span>
      </button>
    );
  };

  const MenuItem = ({
    t,
  }: {
    t: { key: TopicKey; label: string; icon: React.ReactNode };
  }) => {
    const isActive = t.key === topic;
    return (
      <button
        type="button"
        onClick={() => setTopic(t.key)}
        className={`w-full flex items-center gap-3 rounded-xl px-3 py-2 text-sm font-semibold transition-colors ${
          isActive
            ? "bg-accent text-primary"
            : "text-foreground hover:bg-accent"
        }`}
      >
        <span className="opacity-90">{t.icon}</span>
        <span className="truncate">{t.label}</span>
      </button>
    );
  };

  const NewsContent = () => {
    const { toast } = useToast();
    const queryClient = useQueryClient();
    const navigate = useNavigate();

    const postsQuery = useQuery(
      ["newsPosts"],
      () => apiClient.listNewsPosts({ limit: 30 }),
      {
        staleTime: 10_000,
      },
    );

    const statsQuery = useQuery(
      ["newsStats", "24h"],
      () => apiClient.getNewsStats({ range: "24h" }),
      {
        enabled: canManageNews,
        staleTime: 15_000,
      },
    );

    const createMutation = useMutation(apiClient.createNewsPost, {
      onSuccess: async () => {
        await queryClient.invalidateQueries(["newsPosts"]);
        toast({ title: "News published" });
      },
      onError: (e: unknown) => {
        const msg = e instanceof Error ? e.message : "";
        const low = (msg || "").toLowerCase();
        toast({
          title: "Couldn't publish",
          description: low.includes("not allowed")
            ? "Only the owner can publish news."
            : low.includes("sign in")
              ? "Sign in (as the owner) to publish news."
              : msg || "Please try again.",
        });
      },
    });

    const deleteMutation = useMutation(apiClient.deleteNewsPost, {
      onSuccess: async () => {
        await queryClient.invalidateQueries(["newsPosts"]);
        toast({ title: "News deleted" });
      },
      onError: (e: unknown) => {
        const msg = e instanceof Error ? e.message : "";
        const low = (msg || "").toLowerCase();
        toast({
          title: "Couldn't delete",
          description: low.includes("not allowed")
            ? "Only the owner can delete news."
            : low.includes("sign in")
              ? "Sign in (as the owner) to delete news."
              : msg || "Please try again.",
        });
      },
    });

    const [draftTitle, setDraftTitle] = React.useState<string>("");
    const [draftBody, setDraftBody] = React.useState<string>("");

    const doShare = (post: { id: string; title: string }) => {
      const url = new URL(`/news/${post.id}`, getBaseUrl()).toString();
      const title = post.title;

      const doCopy = () => {
        copy(url);
        toast({ title: "Link copied" });
      };

      if (typeof navigator !== "undefined" && (navigator as any).share) {
        (navigator as any).share({ title, url }).catch(() => doCopy());
      } else {
        doCopy();
      }
    };

    const posts = (postsQuery.data ?? []) as Array<{
      id: string;
      title: string;
      body: string;
      createdAt: any;
      createdById: string;
    }>;

    const isEmpty = postsQuery.isFetched && posts.length === 0;

    const canPublish =
      draftTitle.trim().length >= 3 && draftBody.trim().length >= 5;

    return (
      <>
        <div className="flex items-start gap-3">
          <div className="text-2xl font-extrabold tracking-tight">News</div>
          <div className="ml-auto" />
        </div>

        <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
          Official announcements from PP15.ONE. Anyone can open and share.
        </div>

        {canManageNews && (
          <div className="mt-6 rounded-2xl border bg-background/10 p-4">
            <div className="text-xs font-extrabold tracking-wide text-muted-foreground">
              PUBLISH
            </div>

            <div className="mt-3 grid gap-2">
              <div className="flex flex-wrap items-center gap-2">
                <div className="text-[11px] font-semibold text-muted-foreground mr-1">
                  Quick templates:
                </div>

                <Button
                  size="sm"
                  variant="secondary"
                  className="h-8 px-3"
                  disabled={!statsQuery.data}
                  onClick={() => {
                    const s: any = statsQuery.data;
                    const fmt = (n: any) =>
                      `${Number(n ?? 0).toFixed(2)} PPC/m²`;

                    const ath = fmt(s?.allTimeHigh);
                    const cur = fmt(s?.currentPricePerM2);

                    setDraftTitle("All-time high m² price");
                    setDraftBody(
                      `New record: ${ath}.\nCurrent: ${cur}.\n\nOpen Market to explore.`,
                    );
                  }}
                >
                  All-time high
                </Button>

                <Button
                  size="sm"
                  variant="secondary"
                  className="h-8 px-3"
                  disabled={!statsQuery.data}
                  onClick={() => {
                    const s: any = statsQuery.data;
                    const fmt = (n: any) =>
                      `${Number(n ?? 0).toFixed(2)} PPC/m²`;
                    const fmtAbs = (n: any) =>
                      `${Number(n ?? 0).toFixed(2)} PPC`;
                    const fmtPct = (n: any) => {
                      const v = Number(n ?? 0);
                      const sign = v > 0 ? "+" : v < 0 ? "" : "";
                      return `${sign}${v.toFixed(2)}%`;
                    };

                    setDraftTitle("24h market move");
                    setDraftBody(
                      `Last 24h: ${fmtPct(s?.changePct)} (${fmtAbs(s?.changeAbs)}).\nHigh/Low: ${fmt(s?.rangeHigh)} / ${fmt(s?.rangeLow)}.\n\nOpen Market to explore.`,
                    );
                  }}
                >
                  24h move
                </Button>

                <Button
                  size="sm"
                  variant="secondary"
                  className="h-8 px-3"
                  onClick={() => {
                    setDraftTitle("Update");
                    setDraftBody(
                      "We just shipped an update.\n\nOpen the app to explore what's new.",
                    );
                  }}
                >
                  App update
                </Button>

                <Button
                  size="sm"
                  variant="secondary"
                  className="h-8 px-3"
                  onClick={() => {
                    setDraftTitle("New islands");
                    setDraftBody(
                      "New islands are live.\n\nOpen Islands to explore performance and buy or sell shares.",
                    );
                  }}
                >
                  New islands
                </Button>
              </div>

              <Input
                placeholder="Title"
                value={draftTitle}
                onChange={(e) => setDraftTitle(e.target.value)}
              />
              <Textarea
                placeholder="Description"
                value={draftBody}
                onChange={(e) => setDraftBody(e.target.value)}
                className="min-h-[90px]"
              />
              <div className="flex items-center gap-2">
                <Button
                  size="sm"
                  disabled={!canPublish || createMutation.isLoading}
                  onClick={() => {
                    createMutation.mutate({
                      title: draftTitle,
                      body: draftBody,
                      accessToken: supa.accessToken ?? undefined,
                    });
                    setDraftTitle("");
                    setDraftBody("");
                  }}
                >
                  {createMutation.isLoading ? "Publishing…" : "Publish"}
                </Button>
                <Button
                  size="sm"
                  variant="secondary"
                  disabled={createMutation.isLoading}
                  onClick={() => {
                    setDraftTitle("");
                    setDraftBody("");
                  }}
                >
                  Clear
                </Button>
              </div>
              <div className="text-[11px] text-muted-foreground">
                This area is only visible to you. Everyone can open and share.
              </div>
            </div>
          </div>
        )}

        <div className="mt-6">
          <div className="flex items-center gap-2">
            <div className="text-xs font-extrabold tracking-wide text-muted-foreground">
              UPDATES
            </div>
            <div className="ml-auto text-xs text-muted-foreground">
              {postsQuery.isFetching && !postsQuery.isInitialLoading
                ? "refreshing"
                : ""}
            </div>
          </div>

          {postsQuery.error ? (
            <div className="mt-3">
              <Alert>
                <AlertTitle>Couldn’t load updates</AlertTitle>
                <AlertDescription>Please try again.</AlertDescription>
              </Alert>
            </div>
          ) : postsQuery.isInitialLoading ? (
            <div className="mt-3 space-y-2">
              <Skeleton className="h-16 rounded-xl" />
              <Skeleton className="h-16 rounded-xl" />
              <Skeleton className="h-16 rounded-xl" />
            </div>
          ) : (
            <div className="mt-3 space-y-3">
              {isEmpty ? (
                <div className="text-sm text-muted-foreground">
                  {canManageNews
                    ? "No news yet. Publish your first update above."
                    : isOwner
                      ? "No news yet. Sign in to publish."
                      : "No news yet."}
                </div>
              ) : (
                posts.map((p) => (
                  <div
                    key={p.id}
                    className="rounded-2xl border bg-background/10 p-4"
                  >
                    <div className="flex items-start gap-3">
                      <div className="min-w-0">
                        <div className="text-sm font-extrabold truncate">
                          {p.title}
                        </div>
                        <div className="mt-1 text-xs text-muted-foreground leading-relaxed">
                          {p.body}
                        </div>

                        <div className="mt-2 text-[11px] text-muted-foreground flex flex-wrap items-center gap-x-2 gap-y-1">
                          {p.createdAt ? (
                            <span>
                              Posted{" "}
                              {formatDateTime(new Date(p.createdAt as any))}
                            </span>
                          ) : null}

                          <button
                            type="button"
                            className="underline"
                            onClick={() => navigate(`/news/${p.id}`)}
                          >
                            Open
                          </button>
                        </div>
                      </div>

                      <div className="shrink-0 flex items-center gap-2">
                        <Button
                          size="sm"
                          variant="secondary"
                          className="h-8 px-3"
                          onClick={() => doShare(p)}
                        >
                          <Share2 className="h-3.5 w-3.5 mr-2" />
                          Share
                        </Button>

                        {canManageNews && (
                          <Button
                            size="sm"
                            variant="outline"
                            className="h-8 px-3"
                            disabled={deleteMutation.isLoading}
                            onClick={() =>
                              deleteMutation.mutate({
                                id: p.id,
                                accessToken: supa.accessToken ?? undefined,
                              })
                            }
                          >
                            Delete
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
          )}
        </div>
      </>
    );
  };

  const Content = () => {
    if (topic === "market") {
      return (
        <>
          <div className="text-2xl font-extrabold tracking-tight">Market</div>
          <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
            <div className="font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT IT IS
            </div>
            <div className="mt-1">
              The live PPC market with a real-time chart and current price.
            </div>
            <div className="mt-3 font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT YOU CAN DO
            </div>
            <div className="mt-1">
              Track the price, review price history, and buy or sell PPC
              directly in the app.
            </div>
          </div>
        </>
      );
    }

    if (topic === "map") {
      return (
        <>
          <div className="text-2xl font-extrabold tracking-tight">Map</div>
          <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
            <div className="font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT IT IS
            </div>
            <div className="mt-1">
              The world map where virtual land is displayed as individual grid
              cells.
            </div>
            <div className="mt-3 font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT YOU CAN DO
            </div>
            <div className="mt-1">
              Pan and zoom, tap cells to inspect details, buy and claim plots,
              and manage what you build on your land.
            </div>
          </div>
        </>
      );
    }

    if (topic === "islands") {
      return (
        <>
          <div className="text-2xl font-extrabold tracking-tight">Islands</div>
          <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
            <div className="font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT IT IS
            </div>
            <div className="mt-1">
              Community-driven island assets you can invest in like shares.
            </div>
            <div className="mt-3 font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT YOU CAN DO
            </div>
            <div className="mt-1">
              Browse islands, see holders and performance, and buy or sell
              island shares.
            </div>
          </div>
        </>
      );
    }

    if (topic === "secondary") {
      return (
        <>
          <div className="text-2xl font-extrabold tracking-tight">
            2nd Market
          </div>
          <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
            <div className="font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT IT IS
            </div>
            <div className="mt-1">
              A peer-to-peer marketplace where players list land for sale.
            </div>
            <div className="mt-3 font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT YOU CAN DO
            </div>
            <div className="mt-1">
              Browse other players’ listings, buy listed plots, and list your
              own plots independently from the main market pricing.
            </div>
          </div>
        </>
      );
    }

    if (topic === "wallet") {
      return (
        <>
          <div className="text-2xl font-extrabold tracking-tight">Wallet</div>
          <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
            <div className="font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT IT IS
            </div>
            <div className="mt-1">
              Your personal portfolio dashboard for everything you own and do in
              the app.
            </div>
            <div className="mt-3 font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT YOU CAN DO
            </div>
            <div className="mt-1">
              Track your PPC balance, land value, certificates, and your full
              transaction history in one place.
            </div>
          </div>
        </>
      );
    }

    if (topic === "ppc") {
      return (
        <>
          <div className="text-2xl font-extrabold tracking-tight">
            PPC (PP coins)
          </div>
          <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
            <div className="font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT IT IS
            </div>
            <div className="mt-1">
              PPC (PP coins) are in-app credits used across the whole PP15.ONE
              ecosystem.
            </div>
            <div className="mt-3 font-extrabold text-xs tracking-wide text-foreground/80">
              WHAT YOU CAN DO
            </div>
            <div className="mt-1">
              Top up a package, then use PPC to trade, buy land, invest in
              islands, and grow your virtual holdings.
            </div>
          </div>

          <div className="mt-5 rounded-xl border p-3 bg-background/40">
            <div className="text-xs font-extrabold tracking-wide">
              Important note
            </div>
            <div className="mt-1 text-xs text-muted-foreground leading-relaxed">
              PPC are usable only inside PP15.ONE. They are not transferable
              between users, not redeemable for cash, and not tradable outside
              the app.
            </div>
          </div>
        </>
      );
    }

    if (topic === "news") {
      return <NewsContent />;
    }

    // pp15
    return (
      <>
        <div className="text-2xl font-extrabold tracking-tight">
          What is PP15.ONE
        </div>
        <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
          PP15.ONE is a mobile-first virtual land ecosystem. Inside the app you
          can trade PPC (PP coins), explore the world map, buy/claim plots, and
          invest in community islands.
        </div>

        <div className="mt-4 text-sm text-muted-foreground leading-relaxed">
          Main areas you’ll use:
          <ul className="list-disc pl-5 mt-2 space-y-1">
            <li>
              <span className="font-semibold text-foreground">Market</span>: see
              the live PPC price, chart, and buy/sell.
            </li>
            <li>
              <span className="font-semibold text-foreground">Map</span>: browse
              the world grid and manage your land.
            </li>
            <li>
              <span className="font-semibold text-foreground">Islands</span>:
              invest in island shares and track performance.
            </li>
            <li>
              <span className="font-semibold text-foreground">2nd Market</span>:
              player-to-player land listings.
            </li>
            <li>
              <span className="font-semibold text-foreground">Wallet</span>:
              your balances, holdings, certificates and transaction history.
            </li>
          </ul>
        </div>

        <div className="mt-5 rounded-xl border p-3 bg-background/40">
          <div className="text-xs font-extrabold tracking-wide">
            Important note
          </div>
          <div className="mt-1 text-xs text-muted-foreground leading-relaxed">
            PP15.ONE is for entertainment and collecting. Nothing here is
            financial advice, and there are no promises of profits or guaranteed
            value.
          </div>
        </div>

        <div
          id="pp15-how-it-works"
          className="mt-6 rounded-2xl bg-background/10 p-4 sm:p-5"
        >
          <div className="text-xl sm:text-2xl font-extrabold tracking-tight">
            How it works
          </div>
          <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
            A simple step-by-step overview of how to use PP15.ONE.
          </div>

          <ol className="mt-4 list-decimal pl-6 space-y-2 text-sm leading-relaxed">
            <li>
              <span className="font-semibold text-foreground">
                Fill up your Wallet
              </span>{" "}
              with PPC (PP coins) so you can buy and trade.
            </li>
            <li>
              Open <span className="font-semibold text-foreground">Market</span>{" "}
              to see the live chart and price (PPC/m²).
            </li>
            <li>
              Choose what you want to do —{" "}
              <span className="font-semibold text-foreground">buy</span> or{" "}
              <span className="font-semibold text-foreground">sell</span> PPC.
            </li>
            <li>
              Go to the{" "}
              <span className="font-semibold text-foreground">Map</span> to buy
              and claim plots (m²).
            </li>
            <li>
              Use the{" "}
              <span className="font-semibold text-foreground">2nd Market</span>{" "}
              to list specific plots for other players (player-to-player).
            </li>
            <li>
              Check your{" "}
              <span className="font-semibold text-foreground">Wallet</span> to
              see what you currently hold, your value overview, and your
              transactions.
            </li>
          </ol>
        </div>

        <div className="mt-8 text-2xl font-extrabold tracking-tight">
          Why PP15.ONE
        </div>
        <div className="mt-2 text-sm text-muted-foreground leading-relaxed">
          PP15.ONE is built to make virtual ownership simple, fast, and fun —
          with everything in one place.
        </div>

        <div className="mt-4 text-sm text-muted-foreground leading-relaxed">
          Reasons people use it:
          <ul className="list-disc pl-5 mt-2 space-y-1">
            <li>
              <span className="font-semibold text-foreground">All-in-one</span>:
              trade PPC, buy land, and invest in islands in one app.
            </li>
            <li>
              <span className="font-semibold text-foreground">
                Clear overview
              </span>
              : your Wallet shows what you own and what you did.
            </li>
            <li>
              <span className="font-semibold text-foreground">
                Community-driven
              </span>
              : islands and the 2nd market enable player activity and discovery.
            </li>
            <li>
              <span className="font-semibold text-foreground">
                Mobile-first
              </span>
              : designed for quick actions and simple navigation.
            </li>
          </ul>
        </div>

        <div className="mt-6 text-xs text-muted-foreground leading-relaxed">
          Tip: If you’re new, open the{" "}
          <span className="font-semibold text-foreground">Quick Tour</span> (the
          “i” button) to see what each page does.
        </div>
      </>
    );
  };

  return (
    <ScreenContainer title="General">
      <div className="max-w-[1180px] mx-auto h-full min-h-0">
        {" "}
        {/* Mobile: scrollable topic chips */}
        <div className="md:hidden mb-4 flex items-center gap-2 overflow-x-auto pb-1">
          {topics.map((t) => (
            <Chip key={t.key} t={t} />
          ))}
        </div>
        <div className="grid grid-cols-1 md:grid-cols-[260px_1fr] md:grid-rows-[minmax(0,1fr)] gap-6 md:h-full min-h-0">
          {/* Desktop: left topic list */}
          <aside className="hidden md:block">
            <div className="sticky top-24">
              <div className="rounded-2xl bg-card/20 p-2">
                <div className="px-2 pt-2 pb-1 text-xs font-extrabold tracking-wide text-muted-foreground">
                  TOPICS
                </div>
                <div className="flex flex-col gap-1">
                  {topics.map((t) => (
                    <MenuItem key={t.key} t={t} />
                  ))}
                </div>
              </div>
            </div>
          </aside>

          {/* Content */}
          <div className="rounded-2xl bg-card/20 p-4 sm:p-6 md:h-full md:min-h-0 md:overflow-y-auto overscroll-contain">
            <div className="text-xs font-extrabold tracking-wide text-muted-foreground">
              {active.label}
            </div>
            <div className="mt-2">
              <Content />
            </div>
          </div>
        </div>
      </div>
    </ScreenContainer>
  );
}

export default function App() {
  const [reportOpen, setReportOpen] = React.useState<boolean>(false);
  const [deviceId] = React.useState<string>(() => {
    const KEY = "pp_device_id_v1";
    try {
      const existing = localStorage.getItem(KEY);
      if (existing) return existing;
      const created = _genDeviceId();
      localStorage.setItem(KEY, created);
      return created;
    } catch {
      return _genDeviceId();
    }
  });

  const openReport = React.useCallback(() => {
    setReportOpen(true);
  }, []);

  React.useEffect(() => {
    try {
      (window as any).__openReport = openReport;
    } catch {}
    return () => {
      try {
        delete (window as any).__openReport;
      } catch {}
    };
  }, [openReport]);

  // Note: We no longer auto-open the report form on app start.

  // Removed global refresh-all interval to avoid excessive network requests and rate limits.
  // Each screen now opts into lightweight, scoped refetch intervals where needed (e.g., market and 2nd market).
  // Suppress benign global errors/rejections (e.g., Event objects without stack) to avoid noisy logs
  React.useEffect(() => {
    const onError = (e: any) => {
      const err = (e && "error" in e ? e.error : e) as any;
      const isBenignEvent =
        err && typeof err === "object" && !("message" in err) && "type" in err;
      const isBenignLoadFailed =
        err &&
        typeof err === "object" &&
        "message" in err &&
        typeof (err as any).message === "string" &&
        /load failed/i.test((err as any).message);
      if (isBenignEvent || isBenignLoadFailed) {
        // Prevent Event objects or resource load noise from disrupting UX
        if (typeof e?.preventDefault === "function") e.preventDefault();
        return true;
      }
      return undefined;
    };
    const onRejection = (e: any) => {
      const r = e?.reason;
      if (r && typeof r === "object" && !("message" in r) && "type" in r) {
        if (typeof e?.preventDefault === "function") e.preventDefault();
        if (typeof e?.stopImmediatePropagation === "function")
          e.stopImmediatePropagation();
        return true;
      }
      return undefined;
    };
    window.addEventListener("error", onError as any, { capture: true } as any);
    window.addEventListener("unhandledrejection", onRejection as any);
    return () => {
      window.removeEventListener(
        "error",
        onError as any,
        { capture: true } as any,
      );
      window.removeEventListener("unhandledrejection", onRejection as any);
    };
  }, []);
  return (
    <Router>
      <AppErrorBoundary>
        <DeviceIdContext.Provider value={deviceId}>
          <SupabaseProvider>
            <AuthGate>
              <LanguageProvider>
                <OnboardingGate>
                  <NavBridge />{" "}
                  {/* Password reset is handled on https://reset.pp15.one */}{" "}
                  <ReportDialog
                    open={reportOpen}
                    onOpenChange={setReportOpen}
                  />
                  <Routes>
                    {" "}
                    <Route path="/" element={<MarketScreen />} />
                    <Route path="/pp-landing" element={<PPLandingScreen />} />
                    <Route path="/general" element={<GeneralScreen />} />
                    <Route path="/news/:id" element={<NewsDetailScreen />} />
                    <Route path="/map" element={<MapScreen />} />{" "}
                    <Route
                      path="/secondary"
                      element={<SecondaryMarketScreen />}
                    />
                    <Route path="/portfolio" element={<WalletScreen />} />
                    <Route path="/profile" element={<ProfileScreen />} />
                    <Route path="/topup" element={<TopupScreen />} />
                    <Route path="/quick-buy" element={<QuickBuyScreen />} />
                    <Route path="/quick-sell" element={<QuickSellScreen />} />
                    <Route path="/islands" element={<IslandsScreen />} />
                    <Route
                      path="/islands/:id"
                      element={<IslandDetailScreen />}
                    />
                    <Route path="/auth" element={<Navigate to="/" replace />} />
                    <Route
                      path="/certificate/:id"
                      element={<CertificateFullScreen />}
                    />
                    <Route
                      path="/legal/terms"
                      element={
                        <div className="min-h-screen bg-background text-foreground">
                          <ScreenContainer title="Terms of Use">
                            <div className="flex items-center justify-end mb-3">
                              <Button size="sm" variant="secondary" asChild>
                                <a
                                  href="https://app.termly.io/policy-viewer/policy.html?policyUUID=6c3626db-00ce-4818-ace9-6f0ef0d06a1b"
                                  target="_blank"
                                  rel="noreferrer"
                                >
                                  Open in new tab
                                </a>
                              </Button>
                            </div>
                            <div
                              className="mt-2 rounded-lg border overflow-hidden"
                              style={{
                                backgroundColor: "hsl(var(--auth-pill-bg))",
                                color: "hsl(var(--auth-pill-fg))",
                              }}
                            >
                              <iframe
                                src="https://app.termly.io/policy-viewer/policy.html?policyUUID=6c3626db-00ce-4818-ace9-6f0ef0d06a1b"
                                title="Terms of Use"
                                className="w-full h-[70vh]"
                                loading="lazy"
                                referrerPolicy="no-referrer"
                                style={{ background: "#ffffff" }}
                              />
                            </div>
                            <div className="text-xs text-muted-foreground mt-2">
                              If the page doesn’t display,{" "}
                              <a
                                className="underline"
                                href="https://app.termly.io/policy-viewer/policy.html?policyUUID=6c3626db-00ce-4818-ace9-6f0ef0d06a1b"
                                target="_blank"
                                rel="noreferrer"
                              >
                                open it in a new tab
                              </a>
                              .
                            </div>
                          </ScreenContainer>
                        </div>
                      }
                    />
                    <Route
                      path="/legal/terms-en"
                      element={
                        <div className="min-h-screen bg-background text-foreground">
                          <ScreenContainer title="Acceptable Use Policy">
                            <div className="flex items-center justify-end mb-3">
                              <Button size="sm" variant="secondary" asChild>
                                <a
                                  href="https://app.termly.io/policy-viewer/policy.html?policyUUID=71baf290-28b2-44cf-8051-9a49aaad553d"
                                  target="_blank"
                                  rel="noreferrer"
                                >
                                  Open in new tab
                                </a>
                              </Button>
                            </div>
                            <div
                              className="mt-2 rounded-lg border overflow-hidden"
                              style={{
                                backgroundColor: "hsl(var(--auth-pill-bg))",
                                color: "hsl(var(--auth-pill-fg))",
                              }}
                            >
                              <iframe
                                src="https://app.termly.io/policy-viewer/policy.html?policyUUID=71baf290-28b2-44cf-8051-9a49aaad553d"
                                title="Acceptable Use Policy"
                                className="w-full h-[70vh]"
                                loading="lazy"
                                referrerPolicy="no-referrer"
                                style={{ background: "#ffffff" }}
                              />
                            </div>
                            <div className="text-xs text-muted-foreground mt-2">
                              If the page doesn’t display,{" "}
                              <a
                                className="underline"
                                href="https://app.termly.io/policy-viewer/policy.html?policyUUID=71baf290-28b2-44cf-8051-9a49aaad553d"
                                target="_blank"
                                rel="noreferrer"
                              >
                                open it in a new tab
                              </a>
                              .
                            </div>
                          </ScreenContainer>
                        </div>
                      }
                    />
                    <Route
                      path="/legal/cookies"
                      element={
                        <div className="min-h-screen bg-background text-foreground">
                          <ScreenContainer title="Cookie Policy">
                            <div className="flex items-center justify-end mb-3">
                              <Button size="sm" variant="secondary" asChild>
                                <a
                                  href="https://app.termly.io/policy-viewer/policy.html?policyUUID=d97bd300-2162-4862-ac8e-5513457fe160"
                                  target="_blank"
                                  rel="noreferrer"
                                >
                                  Open in new tab
                                </a>
                              </Button>
                            </div>
                            <div
                              className="mt-2 rounded-lg border overflow-hidden"
                              style={{
                                backgroundColor: "hsl(var(--auth-pill-bg))",
                                color: "hsl(var(--auth-pill-fg))",
                              }}
                            >
                              <iframe
                                src="https://app.termly.io/policy-viewer/policy.html?policyUUID=d97bd300-2162-4862-ac8e-5513457fe160"
                                title="Cookie Policy"
                                className="w-full h-[70vh]"
                                loading="lazy"
                                referrerPolicy="no-referrer"
                                style={{ background: "#ffffff" }}
                              />
                            </div>
                            <div className="text-xs text-muted-foreground mt-2">
                              If the page doesn’t display,{" "}
                              <a
                                className="underline"
                                href="https://app.termly.io/policy-viewer/policy.html?policyUUID=d97bd300-2162-4862-ac8e-5513457fe160"
                                target="_blank"
                                rel="noreferrer"
                              >
                                open it in a new tab
                              </a>
                              .
                            </div>
                          </ScreenContainer>
                        </div>
                      }
                    />
                    <Route
                      path="/legal/privacy-en"
                      element={
                        <div className="min-h-screen bg-background text-foreground">
                          <ScreenContainer title="Privacy Policy">
                            <div className="flex items-center justify-end mb-3">
                              <Button size="sm" variant="secondary" asChild>
                                <a
                                  href="https://app.termly.io/policy-viewer/policy.html?policyUUID=1de0de06-4aec-4dd6-9570-b667cbaed718"
                                  target="_blank"
                                  rel="noreferrer"
                                >
                                  Open in new tab
                                </a>
                              </Button>
                            </div>
                            <div
                              className="mt-2 rounded-lg border overflow-hidden"
                              style={{
                                backgroundColor: "hsl(var(--auth-pill-bg))",
                                color: "hsl(var(--auth-pill-fg))",
                              }}
                            >
                              <iframe
                                src="https://app.termly.io/policy-viewer/policy.html?policyUUID=1de0de06-4aec-4dd6-9570-b667cbaed718"
                                title="Privacy Policy"
                                className="w-full h-[70vh]"
                                loading="lazy"
                                referrerPolicy="no-referrer"
                                style={{ background: "#ffffff" }}
                              />
                            </div>
                            <div className="text-xs text-muted-foreground mt-2">
                              If the page doesn’t display,{" "}
                              <a
                                className="underline"
                                href="https://app.termly.io/policy-viewer/policy.html?policyUUID=1de0de06-4aec-4dd6-9570-b667cbaed718"
                                target="_blank"
                                rel="noreferrer"
                              >
                                open it in a new tab
                              </a>
                              .
                            </div>
                          </ScreenContainer>
                        </div>
                      }
                    />
                    <Route path="*" element={<Navigate to="/" replace />} />
                  </Routes>
                </OnboardingGate>
              </LanguageProvider>
            </AuthGate>
          </SupabaseProvider>
        </DeviceIdContext.Provider>
      </AppErrorBoundary>
    </Router>
  );
}
